{"remainingRequest":"/Users/id-repair/Documents/SEOL/4c-dashboard/node_modules/babel-loader/lib/index.js!/Users/id-repair/Documents/SEOL/4c-dashboard/node_modules/echarts/lib/layout/barGrid.js","dependencies":[{"path":"/Users/id-repair/Documents/SEOL/4c-dashboard/node_modules/echarts/lib/layout/barGrid.js","mtime":499162500000},{"path":"/Users/id-repair/Documents/SEOL/4c-dashboard/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/id-repair/Documents/SEOL/4c-dashboard/node_modules/babel-loader/lib/index.js","mtime":315532800000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:cmVxdWlyZSgiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LWJ1ZmZlci5zbGljZS5qcyIpOwoKcmVxdWlyZSgiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanMiKTsKCnJlcXVpcmUoImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5mbG9hdDMyLWFycmF5LmpzIik7CgpyZXF1aXJlKCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuY29weS13aXRoaW4uanMiKTsKCnJlcXVpcmUoImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5ldmVyeS5qcyIpOwoKcmVxdWlyZSgiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbGwuanMiKTsKCnJlcXVpcmUoImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maWx0ZXIuanMiKTsKCnJlcXVpcmUoImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maW5kLmpzIik7CgpyZXF1aXJlKCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmluZC1pbmRleC5qcyIpOwoKcmVxdWlyZSgiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZvci1lYWNoLmpzIik7CgpyZXF1aXJlKCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuaW5jbHVkZXMuanMiKTsKCnJlcXVpcmUoImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbmRleC1vZi5qcyIpOwoKcmVxdWlyZSgiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lml0ZXJhdG9yLmpzIik7CgpyZXF1aXJlKCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuam9pbi5qcyIpOwoKcmVxdWlyZSgiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lmxhc3QtaW5kZXgtb2YuanMiKTsKCnJlcXVpcmUoImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5tYXAuanMiKTsKCnJlcXVpcmUoImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZWR1Y2UuanMiKTsKCnJlcXVpcmUoImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZWR1Y2UtcmlnaHQuanMiKTsKCnJlcXVpcmUoImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZXZlcnNlLmpzIik7CgpyZXF1aXJlKCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc2V0LmpzIik7CgpyZXF1aXJlKCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc2xpY2UuanMiKTsKCnJlcXVpcmUoImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zb21lLmpzIik7CgpyZXF1aXJlKCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc29ydC5qcyIpOwoKcmVxdWlyZSgiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnN1YmFycmF5LmpzIik7CgpyZXF1aXJlKCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudG8tbG9jYWxlLXN0cmluZy5qcyIpOwoKcmVxdWlyZSgiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnRvLXN0cmluZy5qcyIpOwoKLyoKKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lCiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlCiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24KKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlCiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZQoqICJMaWNlbnNlIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2UKKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0CioKKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMAoqCiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLAoqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuCiogIkFTIElTIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZCiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlCiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucwoqIHVuZGVyIHRoZSBMaWNlbnNlLgoqLwp2YXIgenJVdGlsID0gcmVxdWlyZSgienJlbmRlci9saWIvY29yZS91dGlsIik7Cgp2YXIgX251bWJlciA9IHJlcXVpcmUoIi4uL3V0aWwvbnVtYmVyIik7Cgp2YXIgcGFyc2VQZXJjZW50ID0gX251bWJlci5wYXJzZVBlcmNlbnQ7Cgp2YXIgX2RhdGFTdGFja0hlbHBlciA9IHJlcXVpcmUoIi4uL2RhdGEvaGVscGVyL2RhdGFTdGFja0hlbHBlciIpOwoKdmFyIGlzRGltZW5zaW9uU3RhY2tlZCA9IF9kYXRhU3RhY2tIZWxwZXIuaXNEaW1lbnNpb25TdGFja2VkOwoKdmFyIGNyZWF0ZVJlbmRlclBsYW5uZXIgPSByZXF1aXJlKCIuLi9jaGFydC9oZWxwZXIvY3JlYXRlUmVuZGVyUGxhbm5lciIpOwovKgoqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmUKKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGUKKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbgoqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGUKKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlCiogIkxpY2Vuc2UiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZQoqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQKKgoqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wCioKKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsCiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4KKiAiQVMgSVMiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkKKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUKKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zCiogdW5kZXIgdGhlIExpY2Vuc2UuCiovCgovKiBnbG9iYWwgRmxvYXQzMkFycmF5ICovCgoKdmFyIFNUQUNLX1BSRUZJWCA9ICdfX2VjX3N0YWNrXyc7CnZhciBMQVJHRV9CQVJfTUlOX1dJRFRIID0gMC41Owp2YXIgTGFyZ2VBcnIgPSB0eXBlb2YgRmxvYXQzMkFycmF5ICE9PSAndW5kZWZpbmVkJyA/IEZsb2F0MzJBcnJheSA6IEFycmF5OwoKZnVuY3Rpb24gZ2V0U2VyaWVzU3RhY2tJZChzZXJpZXNNb2RlbCkgewogIHJldHVybiBzZXJpZXNNb2RlbC5nZXQoJ3N0YWNrJykgfHwgU1RBQ0tfUFJFRklYICsgc2VyaWVzTW9kZWwuc2VyaWVzSW5kZXg7Cn0KCmZ1bmN0aW9uIGdldEF4aXNLZXkoYXhpcykgewogIHJldHVybiBheGlzLmRpbSArIGF4aXMuaW5kZXg7Cn0KLyoqCiAqIEBwYXJhbSB7T2JqZWN0fSBvcHQKICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9BeGlzfSBvcHQuYXhpcyBPbmx5IHN1cHBvcnQgY2F0ZWdvcnkgYXhpcyBjdXJyZW50bHkuCiAqIEBwYXJhbSB7bnVtYmVyfSBvcHQuY291bnQgUG9zaXRpdmUgaW50ZXJnZXIuCiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0LmJhcldpZHRoXQogKiBAcGFyYW0ge251bWJlcn0gW29wdC5iYXJNYXhXaWR0aF0KICogQHBhcmFtIHtudW1iZXJ9IFtvcHQuYmFyTWluV2lkdGhdCiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0LmJhckdhcF0KICogQHBhcmFtIHtudW1iZXJ9IFtvcHQuYmFyQ2F0ZWdvcnlHYXBdCiAqIEByZXR1cm4ge09iamVjdH0ge3dpZHRoLCBvZmZzZXQsIG9mZnNldENlbnRlcn0gSWYgYXhpcy50eXBlIGlzIG5vdCAnY2F0ZWdvcnknLCByZXR1cm4gdW5kZWZpbmVkLgogKi8KCgpmdW5jdGlvbiBnZXRMYXlvdXRPbkF4aXMob3B0KSB7CiAgdmFyIHBhcmFtcyA9IFtdOwogIHZhciBiYXNlQXhpcyA9IG9wdC5heGlzOwogIHZhciBheGlzS2V5ID0gJ2F4aXMwJzsKCiAgaWYgKGJhc2VBeGlzLnR5cGUgIT09ICdjYXRlZ29yeScpIHsKICAgIHJldHVybjsKICB9CgogIHZhciBiYW5kV2lkdGggPSBiYXNlQXhpcy5nZXRCYW5kV2lkdGgoKTsKCiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHQuY291bnQgfHwgMDsgaSsrKSB7CiAgICBwYXJhbXMucHVzaCh6clV0aWwuZGVmYXVsdHMoewogICAgICBiYW5kV2lkdGg6IGJhbmRXaWR0aCwKICAgICAgYXhpc0tleTogYXhpc0tleSwKICAgICAgc3RhY2tJZDogU1RBQ0tfUFJFRklYICsgaQogICAgfSwgb3B0KSk7CiAgfQoKICB2YXIgd2lkdGhBbmRPZmZzZXRzID0gZG9DYWxCYXJXaWR0aEFuZE9mZnNldChwYXJhbXMpOwogIHZhciByZXN1bHQgPSBbXTsKCiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHQuY291bnQ7IGkrKykgewogICAgdmFyIGl0ZW0gPSB3aWR0aEFuZE9mZnNldHNbYXhpc0tleV1bU1RBQ0tfUFJFRklYICsgaV07CiAgICBpdGVtLm9mZnNldENlbnRlciA9IGl0ZW0ub2Zmc2V0ICsgaXRlbS53aWR0aCAvIDI7CiAgICByZXN1bHQucHVzaChpdGVtKTsKICB9CgogIHJldHVybiByZXN1bHQ7Cn0KCmZ1bmN0aW9uIHByZXBhcmVMYXlvdXRCYXJTZXJpZXMoc2VyaWVzVHlwZSwgZWNNb2RlbCkgewogIHZhciBzZXJpZXNNb2RlbHMgPSBbXTsKICBlY01vZGVsLmVhY2hTZXJpZXNCeVR5cGUoc2VyaWVzVHlwZSwgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7CiAgICAvLyBDaGVjayBzZXJpZXMgY29vcmRpbmF0ZSwgZG8gbGF5b3V0IGZvciBjYXJ0ZXNpYW4yZCBvbmx5CiAgICBpZiAoaXNPbkNhcnRlc2lhbihzZXJpZXNNb2RlbCkgJiYgIWlzSW5MYXJnZU1vZGUoc2VyaWVzTW9kZWwpKSB7CiAgICAgIHNlcmllc01vZGVscy5wdXNoKHNlcmllc01vZGVsKTsKICAgIH0KICB9KTsKICByZXR1cm4gc2VyaWVzTW9kZWxzOwp9Ci8qKgogKiBNYXAgZnJvbSAoYmFzZUF4aXMuZGltICsgJ18nICsgYmFzZUF4aXMuaW5kZXgpIHRvIG1pbiBnYXAgb2YgdHdvIGFkamFjZW50CiAqIHZhbHVlcy4KICogVGhpcyB3b3JrcyBmb3IgdGltZSBheGVzLCB2YWx1ZSBheGVzLCBhbmQgbG9nIGF4ZXMuCiAqIEZvciBhIHNpbmdsZSB0aW1lIGF4aXMsIHJldHVybiB2YWx1ZSBpcyBpbiB0aGUgZm9ybSBsaWtlCiAqIHsneF8wJzogWzEwMDAwMDBdfS4KICogVGhlIHZhbHVlIG9mIDEwMDAwMDAgaXMgaW4gbWlsbGlzZWNvbmRzLgogKi8KCgpmdW5jdGlvbiBnZXRWYWx1ZUF4ZXNNaW5HYXBzKGJhclNlcmllcykgewogIC8qKgogICAqIE1hcCBmcm9tIGF4aXMuaW5kZXggdG8gdmFsdWVzLgogICAqIEZvciBhIHNpbmdsZSB0aW1lIGF4aXMsIGF4aXNWYWx1ZXMgaXMgaW4gdGhlIGZvcm0gbGlrZQogICAqIHsneF8wJzogWzE0OTU1NTUyMDAwMDAsIDE0OTU2NDE2MDAwMDAsIDE0OTU3MjgwMDAwMDBdfS4KICAgKiBJdGVtcyBpbiBheGlzVmFsdWVzW3hdLCBlLmcuIDE0OTU1NTUyMDAwMDAsIGFyZSB0aW1lIHZhbHVlcyBvZiBhbGwKICAgKiBzZXJpZXMuCiAgICovCiAgdmFyIGF4aXNWYWx1ZXMgPSB7fTsKICB6clV0aWwuZWFjaChiYXJTZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkgewogICAgdmFyIGNhcnRlc2lhbiA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07CiAgICB2YXIgYmFzZUF4aXMgPSBjYXJ0ZXNpYW4uZ2V0QmFzZUF4aXMoKTsKCiAgICBpZiAoYmFzZUF4aXMudHlwZSAhPT0gJ3RpbWUnICYmIGJhc2VBeGlzLnR5cGUgIT09ICd2YWx1ZScpIHsKICAgICAgcmV0dXJuOwogICAgfQoKICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpOwogICAgdmFyIGtleSA9IGJhc2VBeGlzLmRpbSArICdfJyArIGJhc2VBeGlzLmluZGV4OwogICAgdmFyIGRpbSA9IGRhdGEubWFwRGltZW5zaW9uKGJhc2VBeGlzLmRpbSk7CgogICAgZm9yICh2YXIgaSA9IDAsIGNudCA9IGRhdGEuY291bnQoKTsgaSA8IGNudDsgKytpKSB7CiAgICAgIHZhciB2YWx1ZSA9IGRhdGEuZ2V0KGRpbSwgaSk7CgogICAgICBpZiAoIWF4aXNWYWx1ZXNba2V5XSkgewogICAgICAgIC8vIE5vIHByZXZpb3VzIGRhdGEgZm9yIHRoZSBheGlzCiAgICAgICAgYXhpc1ZhbHVlc1trZXldID0gW3ZhbHVlXTsKICAgICAgfSBlbHNlIHsKICAgICAgICAvLyBObyB2YWx1ZSBpbiBwcmV2aW91cyBzZXJpZXMKICAgICAgICBheGlzVmFsdWVzW2tleV0ucHVzaCh2YWx1ZSk7CiAgICAgIH0gLy8gSWdub3JlIGR1cGxpY2F0ZWQgdGltZSB2YWx1ZXMgaW4gdGhlIHNhbWUgYXhpcwoKICAgIH0KICB9KTsKICB2YXIgYXhpc01pbkdhcHMgPSBbXTsKCiAgZm9yICh2YXIga2V5IGluIGF4aXNWYWx1ZXMpIHsKICAgIGlmIChheGlzVmFsdWVzLmhhc093blByb3BlcnR5KGtleSkpIHsKICAgICAgdmFyIHZhbHVlc0luQXhpcyA9IGF4aXNWYWx1ZXNba2V5XTsKCiAgICAgIGlmICh2YWx1ZXNJbkF4aXMpIHsKICAgICAgICAvLyBTb3J0IGF4aXMgdmFsdWVzIGludG8gYXNjZW5kaW5nIG9yZGVyIHRvIGNhbGN1bGF0ZSBnYXBzCiAgICAgICAgdmFsdWVzSW5BeGlzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsKICAgICAgICAgIHJldHVybiBhIC0gYjsKICAgICAgICB9KTsKICAgICAgICB2YXIgbWluID0gbnVsbDsKCiAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCB2YWx1ZXNJbkF4aXMubGVuZ3RoOyArK2opIHsKICAgICAgICAgIHZhciBkZWx0YSA9IHZhbHVlc0luQXhpc1tqXSAtIHZhbHVlc0luQXhpc1tqIC0gMV07CgogICAgICAgICAgaWYgKGRlbHRhID4gMCkgewogICAgICAgICAgICAvLyBJZ25vcmUgMCBkZWx0YSBiZWNhdXNlIHRoZXkgYXJlIG9mIHRoZSBzYW1lIGF4aXMgdmFsdWUKICAgICAgICAgICAgbWluID0gbWluID09PSBudWxsID8gZGVsdGEgOiBNYXRoLm1pbihtaW4sIGRlbHRhKTsKICAgICAgICAgIH0KICAgICAgICB9IC8vIFNldCB0byBudWxsIGlmIG9ubHkgaGF2ZSBvbmUgZGF0YQoKCiAgICAgICAgYXhpc01pbkdhcHNba2V5XSA9IG1pbjsKICAgICAgfQogICAgfQogIH0KCiAgcmV0dXJuIGF4aXNNaW5HYXBzOwp9CgpmdW5jdGlvbiBtYWtlQ29sdW1uTGF5b3V0KGJhclNlcmllcykgewogIHZhciBheGlzTWluR2FwcyA9IGdldFZhbHVlQXhlc01pbkdhcHMoYmFyU2VyaWVzKTsKICB2YXIgc2VyaWVzSW5mb0xpc3QgPSBbXTsKICB6clV0aWwuZWFjaChiYXJTZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkgewogICAgdmFyIGNhcnRlc2lhbiA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07CiAgICB2YXIgYmFzZUF4aXMgPSBjYXJ0ZXNpYW4uZ2V0QmFzZUF4aXMoKTsKICAgIHZhciBheGlzRXh0ZW50ID0gYmFzZUF4aXMuZ2V0RXh0ZW50KCk7CiAgICB2YXIgYmFuZFdpZHRoOwoKICAgIGlmIChiYXNlQXhpcy50eXBlID09PSAnY2F0ZWdvcnknKSB7CiAgICAgIGJhbmRXaWR0aCA9IGJhc2VBeGlzLmdldEJhbmRXaWR0aCgpOwogICAgfSBlbHNlIGlmIChiYXNlQXhpcy50eXBlID09PSAndmFsdWUnIHx8IGJhc2VBeGlzLnR5cGUgPT09ICd0aW1lJykgewogICAgICB2YXIga2V5ID0gYmFzZUF4aXMuZGltICsgJ18nICsgYmFzZUF4aXMuaW5kZXg7CiAgICAgIHZhciBtaW5HYXAgPSBheGlzTWluR2Fwc1trZXldOwogICAgICB2YXIgZXh0ZW50U3BhbiA9IE1hdGguYWJzKGF4aXNFeHRlbnRbMV0gLSBheGlzRXh0ZW50WzBdKTsKICAgICAgdmFyIHNjYWxlID0gYmFzZUF4aXMuc2NhbGUuZ2V0RXh0ZW50KCk7CiAgICAgIHZhciBzY2FsZVNwYW4gPSBNYXRoLmFicyhzY2FsZVsxXSAtIHNjYWxlWzBdKTsKICAgICAgYmFuZFdpZHRoID0gbWluR2FwID8gZXh0ZW50U3BhbiAvIHNjYWxlU3BhbiAqIG1pbkdhcCA6IGV4dGVudFNwYW47IC8vIFdoZW4gdGhlcmUgaXMgb25seSBvbmUgZGF0YSB2YWx1ZQogICAgfSBlbHNlIHsKICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7CiAgICAgIGJhbmRXaWR0aCA9IE1hdGguYWJzKGF4aXNFeHRlbnRbMV0gLSBheGlzRXh0ZW50WzBdKSAvIGRhdGEuY291bnQoKTsKICAgIH0KCiAgICB2YXIgYmFyV2lkdGggPSBwYXJzZVBlcmNlbnQoc2VyaWVzTW9kZWwuZ2V0KCdiYXJXaWR0aCcpLCBiYW5kV2lkdGgpOwogICAgdmFyIGJhck1heFdpZHRoID0gcGFyc2VQZXJjZW50KHNlcmllc01vZGVsLmdldCgnYmFyTWF4V2lkdGgnKSwgYmFuZFdpZHRoKTsKICAgIHZhciBiYXJNaW5XaWR0aCA9IHBhcnNlUGVyY2VudCggLy8gYmFyTWluV2lkdGggYnkgZGVmYXVsdCBpcyAxIGluIGNhcnRlc2lhbi4gQmVjYXVzZSBpbiB2YWx1ZSBheGlzLAogICAgLy8gdGhlIGF1dG8tY2FsY3VsYXRlZCBiYXIgd2lkdGggbWlnaHQgYmUgbGVzcyB0aGFuIDEuCiAgICBzZXJpZXNNb2RlbC5nZXQoJ2Jhck1pbldpZHRoJykgfHwgMSwgYmFuZFdpZHRoKTsKICAgIHZhciBiYXJHYXAgPSBzZXJpZXNNb2RlbC5nZXQoJ2JhckdhcCcpOwogICAgdmFyIGJhckNhdGVnb3J5R2FwID0gc2VyaWVzTW9kZWwuZ2V0KCdiYXJDYXRlZ29yeUdhcCcpOwogICAgc2VyaWVzSW5mb0xpc3QucHVzaCh7CiAgICAgIGJhbmRXaWR0aDogYmFuZFdpZHRoLAogICAgICBiYXJXaWR0aDogYmFyV2lkdGgsCiAgICAgIGJhck1heFdpZHRoOiBiYXJNYXhXaWR0aCwKICAgICAgYmFyTWluV2lkdGg6IGJhck1pbldpZHRoLAogICAgICBiYXJHYXA6IGJhckdhcCwKICAgICAgYmFyQ2F0ZWdvcnlHYXA6IGJhckNhdGVnb3J5R2FwLAogICAgICBheGlzS2V5OiBnZXRBeGlzS2V5KGJhc2VBeGlzKSwKICAgICAgc3RhY2tJZDogZ2V0U2VyaWVzU3RhY2tJZChzZXJpZXNNb2RlbCkKICAgIH0pOwogIH0pOwogIHJldHVybiBkb0NhbEJhcldpZHRoQW5kT2Zmc2V0KHNlcmllc0luZm9MaXN0KTsKfQoKZnVuY3Rpb24gZG9DYWxCYXJXaWR0aEFuZE9mZnNldChzZXJpZXNJbmZvTGlzdCkgewogIC8vIENvbHVtbnMgaW5mbyBvbiBlYWNoIGNhdGVnb3J5IGF4aXMuIEtleSBpcyBjYXJ0ZXNpYW4gbmFtZQogIHZhciBjb2x1bW5zTWFwID0ge307CiAgenJVdGlsLmVhY2goc2VyaWVzSW5mb0xpc3QsIGZ1bmN0aW9uIChzZXJpZXNJbmZvLCBpZHgpIHsKICAgIHZhciBheGlzS2V5ID0gc2VyaWVzSW5mby5heGlzS2V5OwogICAgdmFyIGJhbmRXaWR0aCA9IHNlcmllc0luZm8uYmFuZFdpZHRoOwogICAgdmFyIGNvbHVtbnNPbkF4aXMgPSBjb2x1bW5zTWFwW2F4aXNLZXldIHx8IHsKICAgICAgYmFuZFdpZHRoOiBiYW5kV2lkdGgsCiAgICAgIHJlbWFpbmVkV2lkdGg6IGJhbmRXaWR0aCwKICAgICAgYXV0b1dpZHRoQ291bnQ6IDAsCiAgICAgIGNhdGVnb3J5R2FwOiAnMjAlJywKICAgICAgZ2FwOiAnMzAlJywKICAgICAgc3RhY2tzOiB7fQogICAgfTsKICAgIHZhciBzdGFja3MgPSBjb2x1bW5zT25BeGlzLnN0YWNrczsKICAgIGNvbHVtbnNNYXBbYXhpc0tleV0gPSBjb2x1bW5zT25BeGlzOwogICAgdmFyIHN0YWNrSWQgPSBzZXJpZXNJbmZvLnN0YWNrSWQ7CgogICAgaWYgKCFzdGFja3Nbc3RhY2tJZF0pIHsKICAgICAgY29sdW1uc09uQXhpcy5hdXRvV2lkdGhDb3VudCsrOwogICAgfQoKICAgIHN0YWNrc1tzdGFja0lkXSA9IHN0YWNrc1tzdGFja0lkXSB8fCB7CiAgICAgIHdpZHRoOiAwLAogICAgICBtYXhXaWR0aDogMAogICAgfTsgLy8gQ2F1dGlvbjogSW4gYSBzaW5nbGUgY29vcmRpbmF0ZSBzeXN0ZW0sIHRoZXNlIGJhckdyaWQgYXR0cmlidXRlcwogICAgLy8gd2lsbCBiZSBzaGFyZWQgYnkgc2VyaWVzLiBDb25zaWRlciB0aGF0IHRoZXkgaGF2ZSBkZWZhdWx0IHZhbHVlcywKICAgIC8vIG9ubHkgdGhlIGF0dHJpYnV0ZXMgc2V0IG9uIHRoZSBsYXN0IHNlcmllcyB3aWxsIHdvcmsuCiAgICAvLyBEbyBub3QgY2hhbmdlIHRoaXMgZmFjdCB1bmxlc3MgdGhlcmUgd2lsbCBiZSBhIGJyZWFrIGNoYW5nZS4KCiAgICB2YXIgYmFyV2lkdGggPSBzZXJpZXNJbmZvLmJhcldpZHRoOwoKICAgIGlmIChiYXJXaWR0aCAmJiAhc3RhY2tzW3N0YWNrSWRdLndpZHRoKSB7CiAgICAgIC8vIFNlZSAjNjMxMiwgZG8gbm90IHJlc3RyaWN0IHdpZHRoLgogICAgICBzdGFja3Nbc3RhY2tJZF0ud2lkdGggPSBiYXJXaWR0aDsKICAgICAgYmFyV2lkdGggPSBNYXRoLm1pbihjb2x1bW5zT25BeGlzLnJlbWFpbmVkV2lkdGgsIGJhcldpZHRoKTsKICAgICAgY29sdW1uc09uQXhpcy5yZW1haW5lZFdpZHRoIC09IGJhcldpZHRoOwogICAgfQoKICAgIHZhciBiYXJNYXhXaWR0aCA9IHNlcmllc0luZm8uYmFyTWF4V2lkdGg7CiAgICBiYXJNYXhXaWR0aCAmJiAoc3RhY2tzW3N0YWNrSWRdLm1heFdpZHRoID0gYmFyTWF4V2lkdGgpOwogICAgdmFyIGJhck1pbldpZHRoID0gc2VyaWVzSW5mby5iYXJNaW5XaWR0aDsKICAgIGJhck1pbldpZHRoICYmIChzdGFja3Nbc3RhY2tJZF0ubWluV2lkdGggPSBiYXJNaW5XaWR0aCk7CiAgICB2YXIgYmFyR2FwID0gc2VyaWVzSW5mby5iYXJHYXA7CiAgICBiYXJHYXAgIT0gbnVsbCAmJiAoY29sdW1uc09uQXhpcy5nYXAgPSBiYXJHYXApOwogICAgdmFyIGJhckNhdGVnb3J5R2FwID0gc2VyaWVzSW5mby5iYXJDYXRlZ29yeUdhcDsKICAgIGJhckNhdGVnb3J5R2FwICE9IG51bGwgJiYgKGNvbHVtbnNPbkF4aXMuY2F0ZWdvcnlHYXAgPSBiYXJDYXRlZ29yeUdhcCk7CiAgfSk7CiAgdmFyIHJlc3VsdCA9IHt9OwogIHpyVXRpbC5lYWNoKGNvbHVtbnNNYXAsIGZ1bmN0aW9uIChjb2x1bW5zT25BeGlzLCBjb29yZFN5c05hbWUpIHsKICAgIHJlc3VsdFtjb29yZFN5c05hbWVdID0ge307CiAgICB2YXIgc3RhY2tzID0gY29sdW1uc09uQXhpcy5zdGFja3M7CiAgICB2YXIgYmFuZFdpZHRoID0gY29sdW1uc09uQXhpcy5iYW5kV2lkdGg7CiAgICB2YXIgY2F0ZWdvcnlHYXAgPSBwYXJzZVBlcmNlbnQoY29sdW1uc09uQXhpcy5jYXRlZ29yeUdhcCwgYmFuZFdpZHRoKTsKICAgIHZhciBiYXJHYXBQZXJjZW50ID0gcGFyc2VQZXJjZW50KGNvbHVtbnNPbkF4aXMuZ2FwLCAxKTsKICAgIHZhciByZW1haW5lZFdpZHRoID0gY29sdW1uc09uQXhpcy5yZW1haW5lZFdpZHRoOwogICAgdmFyIGF1dG9XaWR0aENvdW50ID0gY29sdW1uc09uQXhpcy5hdXRvV2lkdGhDb3VudDsKICAgIHZhciBhdXRvV2lkdGggPSAocmVtYWluZWRXaWR0aCAtIGNhdGVnb3J5R2FwKSAvIChhdXRvV2lkdGhDb3VudCArIChhdXRvV2lkdGhDb3VudCAtIDEpICogYmFyR2FwUGVyY2VudCk7CiAgICBhdXRvV2lkdGggPSBNYXRoLm1heChhdXRvV2lkdGgsIDApOyAvLyBGaW5kIGlmIGFueSBhdXRvIGNhbGN1bGF0ZWQgYmFyIGV4Y2VlZGVkIG1heEJhcldpZHRoCgogICAgenJVdGlsLmVhY2goc3RhY2tzLCBmdW5jdGlvbiAoY29sdW1uKSB7CiAgICAgIHZhciBtYXhXaWR0aCA9IGNvbHVtbi5tYXhXaWR0aDsKICAgICAgdmFyIG1pbldpZHRoID0gY29sdW1uLm1pbldpZHRoOwoKICAgICAgaWYgKCFjb2x1bW4ud2lkdGgpIHsKICAgICAgICB2YXIgZmluYWxXaWR0aCA9IGF1dG9XaWR0aDsKCiAgICAgICAgaWYgKG1heFdpZHRoICYmIG1heFdpZHRoIDwgZmluYWxXaWR0aCkgewogICAgICAgICAgZmluYWxXaWR0aCA9IE1hdGgubWluKG1heFdpZHRoLCByZW1haW5lZFdpZHRoKTsKICAgICAgICB9IC8vIGBtaW5XaWR0aGAgaGFzIGhpZ2hlciBwcmlvcml0eS4gYG1pbldpZHRoYCBkZWNpZGUgdGhhdCB3aGV0ZXIgdGhlCiAgICAgICAgLy8gYmFyIGlzIGFibGUgdG8gYmUgdmlzaWJsZS4gU28gYG1pbldpZHRoYCBzaG91bGQgbm90IGJlIHJlc3RyaWN0ZWQKICAgICAgICAvLyBieSBgbWF4V2lkdGhgIG9yIGByZW1haW5lZFdpZHRoYCAod2hpY2ggaXMgZnJvbSBgYmFuZFdpZHRoYCkuIEluCiAgICAgICAgLy8gdGhlIGV4dHJlbWUgY2FzZXMgZm9yIGB2YWx1ZWAgYXhpcywgYmFycyBhcmUgYWxsb3dlZCB0byBvdmVybGFwCiAgICAgICAgLy8gd2l0aCBlYWNoIG90aGVyIGlmIGBtaW5XaWR0aGAgc3BlY2lmaWVkLgoKCiAgICAgICAgaWYgKG1pbldpZHRoICYmIG1pbldpZHRoID4gZmluYWxXaWR0aCkgewogICAgICAgICAgZmluYWxXaWR0aCA9IG1pbldpZHRoOwogICAgICAgIH0KCiAgICAgICAgaWYgKGZpbmFsV2lkdGggIT09IGF1dG9XaWR0aCkgewogICAgICAgICAgY29sdW1uLndpZHRoID0gZmluYWxXaWR0aDsKICAgICAgICAgIHJlbWFpbmVkV2lkdGggLT0gZmluYWxXaWR0aCArIGJhckdhcFBlcmNlbnQgKiBmaW5hbFdpZHRoOwogICAgICAgICAgYXV0b1dpZHRoQ291bnQtLTsKICAgICAgICB9CiAgICAgIH0gZWxzZSB7CiAgICAgICAgLy8gYGJhck1pbldpZHRoL2Jhck1heFdpZHRoYCBoYXMgaGlnaGVyIHByaW9yaXR5IHRoYW4gYGJhcldpZHRoYCwgYXMKICAgICAgICAvLyBDU1MgZG9lcy4gQmVjdWFzZSBiYXJXaWR0aCBjYW4gYmUgYSBwZXJjZW50IHZhbHVlLCB3aGVyZQogICAgICAgIC8vIGBiYXJNYXhXaWR0aGAgY2FuIGJlIHVzZWQgdG8gcmVzdHJpY3QgdGhlIGZpbmFsIHdpZHRoLgogICAgICAgIHZhciBmaW5hbFdpZHRoID0gY29sdW1uLndpZHRoOwoKICAgICAgICBpZiAobWF4V2lkdGgpIHsKICAgICAgICAgIGZpbmFsV2lkdGggPSBNYXRoLm1pbihmaW5hbFdpZHRoLCBtYXhXaWR0aCk7CiAgICAgICAgfSAvLyBgbWluV2lkdGhgIGhhcyBoaWdoZXIgcHJpb3JpdHksIGFzIGRlc2NyaWJlZCBhYm92ZQoKCiAgICAgICAgaWYgKG1pbldpZHRoKSB7CiAgICAgICAgICBmaW5hbFdpZHRoID0gTWF0aC5tYXgoZmluYWxXaWR0aCwgbWluV2lkdGgpOwogICAgICAgIH0KCiAgICAgICAgY29sdW1uLndpZHRoID0gZmluYWxXaWR0aDsKICAgICAgICByZW1haW5lZFdpZHRoIC09IGZpbmFsV2lkdGggKyBiYXJHYXBQZXJjZW50ICogZmluYWxXaWR0aDsKICAgICAgICBhdXRvV2lkdGhDb3VudC0tOwogICAgICB9CiAgICB9KTsgLy8gUmVjYWxjdWxhdGUgd2lkdGggYWdhaW4KCiAgICBhdXRvV2lkdGggPSAocmVtYWluZWRXaWR0aCAtIGNhdGVnb3J5R2FwKSAvIChhdXRvV2lkdGhDb3VudCArIChhdXRvV2lkdGhDb3VudCAtIDEpICogYmFyR2FwUGVyY2VudCk7CiAgICBhdXRvV2lkdGggPSBNYXRoLm1heChhdXRvV2lkdGgsIDApOwogICAgdmFyIHdpZHRoU3VtID0gMDsKICAgIHZhciBsYXN0Q29sdW1uOwogICAgenJVdGlsLmVhY2goc3RhY2tzLCBmdW5jdGlvbiAoY29sdW1uLCBpZHgpIHsKICAgICAgaWYgKCFjb2x1bW4ud2lkdGgpIHsKICAgICAgICBjb2x1bW4ud2lkdGggPSBhdXRvV2lkdGg7CiAgICAgIH0KCiAgICAgIGxhc3RDb2x1bW4gPSBjb2x1bW47CiAgICAgIHdpZHRoU3VtICs9IGNvbHVtbi53aWR0aCAqICgxICsgYmFyR2FwUGVyY2VudCk7CiAgICB9KTsKCiAgICBpZiAobGFzdENvbHVtbikgewogICAgICB3aWR0aFN1bSAtPSBsYXN0Q29sdW1uLndpZHRoICogYmFyR2FwUGVyY2VudDsKICAgIH0KCiAgICB2YXIgb2Zmc2V0ID0gLXdpZHRoU3VtIC8gMjsKICAgIHpyVXRpbC5lYWNoKHN0YWNrcywgZnVuY3Rpb24gKGNvbHVtbiwgc3RhY2tJZCkgewogICAgICByZXN1bHRbY29vcmRTeXNOYW1lXVtzdGFja0lkXSA9IHJlc3VsdFtjb29yZFN5c05hbWVdW3N0YWNrSWRdIHx8IHsKICAgICAgICBiYW5kV2lkdGg6IGJhbmRXaWR0aCwKICAgICAgICBvZmZzZXQ6IG9mZnNldCwKICAgICAgICB3aWR0aDogY29sdW1uLndpZHRoCiAgICAgIH07CiAgICAgIG9mZnNldCArPSBjb2x1bW4ud2lkdGggKiAoMSArIGJhckdhcFBlcmNlbnQpOwogICAgfSk7CiAgfSk7CiAgcmV0dXJuIHJlc3VsdDsKfQovKioKICogQHBhcmFtIHtPYmplY3R9IGJhcldpZHRoQW5kT2Zmc2V0IFRoZSByZXN1bHQgb2YgbWFrZUNvbHVtbkxheW91dAogKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkL0F4aXN9IGF4aXMKICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9TZXJpZXN9IFtzZXJpZXNNb2RlbF0gSWYgbm90IHByb3ZpZGVkLCByZXR1cm4gYWxsLgogKiBAcmV0dXJuIHtPYmplY3R9IHtzdGFja0lkOiB7b2Zmc2V0LCB3aWR0aH19IG9yIHtvZmZzZXQsIHdpZHRofSBpZiBzZXJpZXNNb2RlbCBwcm92aWRlZC4KICovCgoKZnVuY3Rpb24gcmV0cmlldmVDb2x1bW5MYXlvdXQoYmFyV2lkdGhBbmRPZmZzZXQsIGF4aXMsIHNlcmllc01vZGVsKSB7CiAgaWYgKGJhcldpZHRoQW5kT2Zmc2V0ICYmIGF4aXMpIHsKICAgIHZhciByZXN1bHQgPSBiYXJXaWR0aEFuZE9mZnNldFtnZXRBeGlzS2V5KGF4aXMpXTsKCiAgICBpZiAocmVzdWx0ICE9IG51bGwgJiYgc2VyaWVzTW9kZWwgIT0gbnVsbCkgewogICAgICByZXN1bHQgPSByZXN1bHRbZ2V0U2VyaWVzU3RhY2tJZChzZXJpZXNNb2RlbCldOwogICAgfQoKICAgIHJldHVybiByZXN1bHQ7CiAgfQp9Ci8qKgogKiBAcGFyYW0ge3N0cmluZ30gc2VyaWVzVHlwZQogKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbAogKi8KCgpmdW5jdGlvbiBsYXlvdXQoc2VyaWVzVHlwZSwgZWNNb2RlbCkgewogIHZhciBzZXJpZXNNb2RlbHMgPSBwcmVwYXJlTGF5b3V0QmFyU2VyaWVzKHNlcmllc1R5cGUsIGVjTW9kZWwpOwogIHZhciBiYXJXaWR0aEFuZE9mZnNldCA9IG1ha2VDb2x1bW5MYXlvdXQoc2VyaWVzTW9kZWxzKTsKICB2YXIgbGFzdFN0YWNrQ29vcmRzID0ge307CiAgdmFyIGxhc3RTdGFja0Nvb3Jkc09yaWdpbiA9IHt9OwogIHpyVXRpbC5lYWNoKHNlcmllc01vZGVscywgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7CiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTsKICAgIHZhciBjYXJ0ZXNpYW4gPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtOwogICAgdmFyIGJhc2VBeGlzID0gY2FydGVzaWFuLmdldEJhc2VBeGlzKCk7CiAgICB2YXIgc3RhY2tJZCA9IGdldFNlcmllc1N0YWNrSWQoc2VyaWVzTW9kZWwpOwogICAgdmFyIGNvbHVtbkxheW91dEluZm8gPSBiYXJXaWR0aEFuZE9mZnNldFtnZXRBeGlzS2V5KGJhc2VBeGlzKV1bc3RhY2tJZF07CiAgICB2YXIgY29sdW1uT2Zmc2V0ID0gY29sdW1uTGF5b3V0SW5mby5vZmZzZXQ7CiAgICB2YXIgY29sdW1uV2lkdGggPSBjb2x1bW5MYXlvdXRJbmZvLndpZHRoOwogICAgdmFyIHZhbHVlQXhpcyA9IGNhcnRlc2lhbi5nZXRPdGhlckF4aXMoYmFzZUF4aXMpOwogICAgdmFyIGJhck1pbkhlaWdodCA9IHNlcmllc01vZGVsLmdldCgnYmFyTWluSGVpZ2h0JykgfHwgMDsKICAgIGxhc3RTdGFja0Nvb3Jkc1tzdGFja0lkXSA9IGxhc3RTdGFja0Nvb3Jkc1tzdGFja0lkXSB8fCBbXTsKICAgIGxhc3RTdGFja0Nvb3Jkc09yaWdpbltzdGFja0lkXSA9IGxhc3RTdGFja0Nvb3Jkc09yaWdpbltzdGFja0lkXSB8fCBbXTsgLy8gRml4ICM0MjQzCgogICAgZGF0YS5zZXRMYXlvdXQoewogICAgICBiYW5kV2lkdGg6IGNvbHVtbkxheW91dEluZm8uYmFuZFdpZHRoLAogICAgICBvZmZzZXQ6IGNvbHVtbk9mZnNldCwKICAgICAgc2l6ZTogY29sdW1uV2lkdGgKICAgIH0pOwogICAgdmFyIHZhbHVlRGltID0gZGF0YS5tYXBEaW1lbnNpb24odmFsdWVBeGlzLmRpbSk7CiAgICB2YXIgYmFzZURpbSA9IGRhdGEubWFwRGltZW5zaW9uKGJhc2VBeGlzLmRpbSk7CiAgICB2YXIgc3RhY2tlZCA9IGlzRGltZW5zaW9uU3RhY2tlZChkYXRhLCB2YWx1ZURpbQogICAgLyosIGJhc2VEaW0qLwogICAgKTsKICAgIHZhciBpc1ZhbHVlQXhpc0ggPSB2YWx1ZUF4aXMuaXNIb3Jpem9udGFsKCk7CiAgICB2YXIgdmFsdWVBeGlzU3RhcnQgPSBnZXRWYWx1ZUF4aXNTdGFydChiYXNlQXhpcywgdmFsdWVBeGlzLCBzdGFja2VkKTsKCiAgICBmb3IgKHZhciBpZHggPSAwLCBsZW4gPSBkYXRhLmNvdW50KCk7IGlkeCA8IGxlbjsgaWR4KyspIHsKICAgICAgdmFyIHZhbHVlID0gZGF0YS5nZXQodmFsdWVEaW0sIGlkeCk7CiAgICAgIHZhciBiYXNlVmFsdWUgPSBkYXRhLmdldChiYXNlRGltLCBpZHgpOwogICAgICB2YXIgc2lnbiA9IHZhbHVlID49IDAgPyAncCcgOiAnbic7CiAgICAgIHZhciBiYXNlQ29vcmQgPSB2YWx1ZUF4aXNTdGFydDsgLy8gQmVjYXVzZSBvZiB0aGUgYmFyTWluSGVpZ2h0LCB3ZSBjYW4gbm90IHVzZSB0aGUgdmFsdWUgaW4KICAgICAgLy8gc3RhY2tSZXN1bHREaW1lbnNpb24gZGlyZWN0bHkuCgogICAgICBpZiAoc3RhY2tlZCkgewogICAgICAgIC8vIE9ubHkgb3JkaW5hbCBheGlzIGNhbiBiZSBzdGFja2VkLgogICAgICAgIGlmICghbGFzdFN0YWNrQ29vcmRzW3N0YWNrSWRdW2Jhc2VWYWx1ZV0pIHsKICAgICAgICAgIGxhc3RTdGFja0Nvb3Jkc1tzdGFja0lkXVtiYXNlVmFsdWVdID0gewogICAgICAgICAgICBwOiB2YWx1ZUF4aXNTdGFydCwKICAgICAgICAgICAgLy8gUG9zaXRpdmUgc3RhY2sKICAgICAgICAgICAgbjogdmFsdWVBeGlzU3RhcnQgLy8gTmVnYXRpdmUgc3RhY2sKCiAgICAgICAgICB9OwogICAgICAgIH0gLy8gU2hvdWxkIGFsc28gY29uc2lkZXIgIzQyNDMKCgogICAgICAgIGJhc2VDb29yZCA9IGxhc3RTdGFja0Nvb3Jkc1tzdGFja0lkXVtiYXNlVmFsdWVdW3NpZ25dOwogICAgICB9CgogICAgICB2YXIgeDsKICAgICAgdmFyIHk7CiAgICAgIHZhciB3aWR0aDsKICAgICAgdmFyIGhlaWdodDsKCiAgICAgIGlmIChpc1ZhbHVlQXhpc0gpIHsKICAgICAgICB2YXIgY29vcmQgPSBjYXJ0ZXNpYW4uZGF0YVRvUG9pbnQoW3ZhbHVlLCBiYXNlVmFsdWVdKTsKICAgICAgICB4ID0gYmFzZUNvb3JkOwogICAgICAgIHkgPSBjb29yZFsxXSArIGNvbHVtbk9mZnNldDsKICAgICAgICB3aWR0aCA9IGNvb3JkWzBdIC0gdmFsdWVBeGlzU3RhcnQ7CiAgICAgICAgaGVpZ2h0ID0gY29sdW1uV2lkdGg7CgogICAgICAgIGlmIChNYXRoLmFicyh3aWR0aCkgPCBiYXJNaW5IZWlnaHQpIHsKICAgICAgICAgIHdpZHRoID0gKHdpZHRoIDwgMCA/IC0xIDogMSkgKiBiYXJNaW5IZWlnaHQ7CiAgICAgICAgfSAvLyBJZ25vcmUgc3RhY2sgZnJvbSBOYU4gdmFsdWUKCgogICAgICAgIGlmICghaXNOYU4od2lkdGgpKSB7CiAgICAgICAgICBzdGFja2VkICYmIChsYXN0U3RhY2tDb29yZHNbc3RhY2tJZF1bYmFzZVZhbHVlXVtzaWduXSArPSB3aWR0aCk7CiAgICAgICAgfQogICAgICB9IGVsc2UgewogICAgICAgIHZhciBjb29yZCA9IGNhcnRlc2lhbi5kYXRhVG9Qb2ludChbYmFzZVZhbHVlLCB2YWx1ZV0pOwogICAgICAgIHggPSBjb29yZFswXSArIGNvbHVtbk9mZnNldDsKICAgICAgICB5ID0gYmFzZUNvb3JkOwogICAgICAgIHdpZHRoID0gY29sdW1uV2lkdGg7CiAgICAgICAgaGVpZ2h0ID0gY29vcmRbMV0gLSB2YWx1ZUF4aXNTdGFydDsKCiAgICAgICAgaWYgKE1hdGguYWJzKGhlaWdodCkgPCBiYXJNaW5IZWlnaHQpIHsKICAgICAgICAgIC8vIEluY2x1ZGUgemVybyB0byBoYXMgYSBwb3NpdGl2ZSBiYXIKICAgICAgICAgIGhlaWdodCA9IChoZWlnaHQgPD0gMCA/IC0xIDogMSkgKiBiYXJNaW5IZWlnaHQ7CiAgICAgICAgfSAvLyBJZ25vcmUgc3RhY2sgZnJvbSBOYU4gdmFsdWUKCgogICAgICAgIGlmICghaXNOYU4oaGVpZ2h0KSkgewogICAgICAgICAgc3RhY2tlZCAmJiAobGFzdFN0YWNrQ29vcmRzW3N0YWNrSWRdW2Jhc2VWYWx1ZV1bc2lnbl0gKz0gaGVpZ2h0KTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIGRhdGEuc2V0SXRlbUxheW91dChpZHgsIHsKICAgICAgICB4OiB4LAogICAgICAgIHk6IHksCiAgICAgICAgd2lkdGg6IHdpZHRoLAogICAgICAgIGhlaWdodDogaGVpZ2h0CiAgICAgIH0pOwogICAgfQogIH0sIHRoaXMpOwp9IC8vIFRPRE86IERvIG5vdCBzdXBwb3J0IHN0YWNrIGluIGxhcmdlIG1vZGUgeWV0LgoKCnZhciBsYXJnZUxheW91dCA9IHsKICBzZXJpZXNUeXBlOiAnYmFyJywKICBwbGFuOiBjcmVhdGVSZW5kZXJQbGFubmVyKCksCiAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KHNlcmllc01vZGVsKSB7CiAgICBpZiAoIWlzT25DYXJ0ZXNpYW4oc2VyaWVzTW9kZWwpIHx8ICFpc0luTGFyZ2VNb2RlKHNlcmllc01vZGVsKSkgewogICAgICByZXR1cm47CiAgICB9CgogICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7CiAgICB2YXIgY2FydGVzaWFuID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTsKICAgIHZhciBjb29yZExheW91dCA9IGNhcnRlc2lhbi5ncmlkLmdldFJlY3QoKTsKICAgIHZhciBiYXNlQXhpcyA9IGNhcnRlc2lhbi5nZXRCYXNlQXhpcygpOwogICAgdmFyIHZhbHVlQXhpcyA9IGNhcnRlc2lhbi5nZXRPdGhlckF4aXMoYmFzZUF4aXMpOwogICAgdmFyIHZhbHVlRGltID0gZGF0YS5tYXBEaW1lbnNpb24odmFsdWVBeGlzLmRpbSk7CiAgICB2YXIgYmFzZURpbSA9IGRhdGEubWFwRGltZW5zaW9uKGJhc2VBeGlzLmRpbSk7CiAgICB2YXIgdmFsdWVBeGlzSG9yaXpvbnRhbCA9IHZhbHVlQXhpcy5pc0hvcml6b250YWwoKTsKICAgIHZhciB2YWx1ZURpbUlkeCA9IHZhbHVlQXhpc0hvcml6b250YWwgPyAwIDogMTsKICAgIHZhciBiYXJXaWR0aCA9IHJldHJpZXZlQ29sdW1uTGF5b3V0KG1ha2VDb2x1bW5MYXlvdXQoW3Nlcmllc01vZGVsXSksIGJhc2VBeGlzLCBzZXJpZXNNb2RlbCkud2lkdGg7CgogICAgaWYgKCEoYmFyV2lkdGggPiBMQVJHRV9CQVJfTUlOX1dJRFRIKSkgewogICAgICAvLyBqc2hpbnQgaWdub3JlOmxpbmUKICAgICAgYmFyV2lkdGggPSBMQVJHRV9CQVJfTUlOX1dJRFRIOwogICAgfQoKICAgIHJldHVybiB7CiAgICAgIHByb2dyZXNzOiBwcm9ncmVzcwogICAgfTsKCiAgICBmdW5jdGlvbiBwcm9ncmVzcyhwYXJhbXMsIGRhdGEpIHsKICAgICAgdmFyIGNvdW50ID0gcGFyYW1zLmNvdW50OwogICAgICB2YXIgbGFyZ2VQb2ludHMgPSBuZXcgTGFyZ2VBcnIoY291bnQgKiAyKTsKICAgICAgdmFyIGxhcmdlQmFja2dyb3VuZFBvaW50cyA9IG5ldyBMYXJnZUFycihjb3VudCAqIDIpOwogICAgICB2YXIgbGFyZ2VEYXRhSW5kaWNlcyA9IG5ldyBMYXJnZUFycihjb3VudCk7CiAgICAgIHZhciBkYXRhSW5kZXg7CiAgICAgIHZhciBjb29yZCA9IFtdOwogICAgICB2YXIgdmFsdWVQYWlyID0gW107CiAgICAgIHZhciBwb2ludHNPZmZzZXQgPSAwOwogICAgICB2YXIgaWR4T2Zmc2V0ID0gMDsKCiAgICAgIHdoaWxlICgoZGF0YUluZGV4ID0gcGFyYW1zLm5leHQoKSkgIT0gbnVsbCkgewogICAgICAgIHZhbHVlUGFpclt2YWx1ZURpbUlkeF0gPSBkYXRhLmdldCh2YWx1ZURpbSwgZGF0YUluZGV4KTsKICAgICAgICB2YWx1ZVBhaXJbMSAtIHZhbHVlRGltSWR4XSA9IGRhdGEuZ2V0KGJhc2VEaW0sIGRhdGFJbmRleCk7CiAgICAgICAgY29vcmQgPSBjYXJ0ZXNpYW4uZGF0YVRvUG9pbnQodmFsdWVQYWlyLCBudWxsLCBjb29yZCk7IC8vIERhdGEgaW5kZXggbWlnaHQgbm90IGJlIGluIG9yZGVyLCBkZXBlbmRzIG9uIGBwcm9ncmVzc2l2ZUNodW5rTW9kZWAuCgogICAgICAgIGxhcmdlQmFja2dyb3VuZFBvaW50c1twb2ludHNPZmZzZXRdID0gdmFsdWVBeGlzSG9yaXpvbnRhbCA/IGNvb3JkTGF5b3V0LnggKyBjb29yZExheW91dC53aWR0aCA6IGNvb3JkWzBdOwogICAgICAgIGxhcmdlUG9pbnRzW3BvaW50c09mZnNldCsrXSA9IGNvb3JkWzBdOwogICAgICAgIGxhcmdlQmFja2dyb3VuZFBvaW50c1twb2ludHNPZmZzZXRdID0gdmFsdWVBeGlzSG9yaXpvbnRhbCA/IGNvb3JkWzFdIDogY29vcmRMYXlvdXQueSArIGNvb3JkTGF5b3V0LmhlaWdodDsKICAgICAgICBsYXJnZVBvaW50c1twb2ludHNPZmZzZXQrK10gPSBjb29yZFsxXTsKICAgICAgICBsYXJnZURhdGFJbmRpY2VzW2lkeE9mZnNldCsrXSA9IGRhdGFJbmRleDsKICAgICAgfQoKICAgICAgZGF0YS5zZXRMYXlvdXQoewogICAgICAgIGxhcmdlUG9pbnRzOiBsYXJnZVBvaW50cywKICAgICAgICBsYXJnZURhdGFJbmRpY2VzOiBsYXJnZURhdGFJbmRpY2VzLAogICAgICAgIGxhcmdlQmFja2dyb3VuZFBvaW50czogbGFyZ2VCYWNrZ3JvdW5kUG9pbnRzLAogICAgICAgIGJhcldpZHRoOiBiYXJXaWR0aCwKICAgICAgICB2YWx1ZUF4aXNTdGFydDogZ2V0VmFsdWVBeGlzU3RhcnQoYmFzZUF4aXMsIHZhbHVlQXhpcywgZmFsc2UpLAogICAgICAgIGJhY2tncm91bmRTdGFydDogdmFsdWVBeGlzSG9yaXpvbnRhbCA/IGNvb3JkTGF5b3V0LnggOiBjb29yZExheW91dC55LAogICAgICAgIHZhbHVlQXhpc0hvcml6b250YWw6IHZhbHVlQXhpc0hvcml6b250YWwKICAgICAgfSk7CiAgICB9CiAgfQp9OwoKZnVuY3Rpb24gaXNPbkNhcnRlc2lhbihzZXJpZXNNb2RlbCkgewogIHJldHVybiBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtICYmIHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW0udHlwZSA9PT0gJ2NhcnRlc2lhbjJkJzsKfQoKZnVuY3Rpb24gaXNJbkxhcmdlTW9kZShzZXJpZXNNb2RlbCkgewogIHJldHVybiBzZXJpZXNNb2RlbC5waXBlbGluZUNvbnRleHQgJiYgc2VyaWVzTW9kZWwucGlwZWxpbmVDb250ZXh0LmxhcmdlOwp9IC8vIFNlZSBjYXNlcyBpbiBgdGVzdC9iYXItc3RhcnQuaHRtbGAgYW5kIGAjNzQxMmAsIGAjODc0N2AuCgoKZnVuY3Rpb24gZ2V0VmFsdWVBeGlzU3RhcnQoYmFzZUF4aXMsIHZhbHVlQXhpcywgc3RhY2tlZCkgewogIHJldHVybiB2YWx1ZUF4aXMudG9HbG9iYWxDb29yZCh2YWx1ZUF4aXMuZGF0YVRvQ29vcmQodmFsdWVBeGlzLnR5cGUgPT09ICdsb2cnID8gMSA6IDApKTsKfQoKZXhwb3J0cy5nZXRMYXlvdXRPbkF4aXMgPSBnZXRMYXlvdXRPbkF4aXM7CmV4cG9ydHMucHJlcGFyZUxheW91dEJhclNlcmllcyA9IHByZXBhcmVMYXlvdXRCYXJTZXJpZXM7CmV4cG9ydHMubWFrZUNvbHVtbkxheW91dCA9IG1ha2VDb2x1bW5MYXlvdXQ7CmV4cG9ydHMucmV0cmlldmVDb2x1bW5MYXlvdXQgPSByZXRyaWV2ZUNvbHVtbkxheW91dDsKZXhwb3J0cy5sYXlvdXQgPSBsYXlvdXQ7CmV4cG9ydHMubGFyZ2VMYXlvdXQgPSBsYXJnZUxheW91dDs="},{"version":3,"sources":["/Users/id-repair/Documents/SEOL/4c-dashboard/node_modules/echarts/lib/layout/barGrid.js"],"names":["zrUtil","require","_number","parsePercent","_dataStackHelper","isDimensionStacked","createRenderPlanner","STACK_PREFIX","LARGE_BAR_MIN_WIDTH","LargeArr","Float32Array","Array","getSeriesStackId","seriesModel","get","seriesIndex","getAxisKey","axis","dim","index","getLayoutOnAxis","opt","params","baseAxis","axisKey","type","bandWidth","getBandWidth","i","count","push","defaults","stackId","widthAndOffsets","doCalBarWidthAndOffset","result","item","offsetCenter","offset","width","prepareLayoutBarSeries","seriesType","ecModel","seriesModels","eachSeriesByType","isOnCartesian","isInLargeMode","getValueAxesMinGaps","barSeries","axisValues","each","cartesian","coordinateSystem","getBaseAxis","data","getData","key","mapDimension","cnt","value","axisMinGaps","hasOwnProperty","valuesInAxis","sort","a","b","min","j","length","delta","Math","makeColumnLayout","seriesInfoList","axisExtent","getExtent","minGap","extentSpan","abs","scale","scaleSpan","barWidth","barMaxWidth","barMinWidth","barGap","barCategoryGap","columnsMap","seriesInfo","idx","columnsOnAxis","remainedWidth","autoWidthCount","categoryGap","gap","stacks","maxWidth","minWidth","coordSysName","barGapPercent","autoWidth","max","column","finalWidth","widthSum","lastColumn","retrieveColumnLayout","barWidthAndOffset","layout","lastStackCoords","lastStackCoordsOrigin","columnLayoutInfo","columnOffset","columnWidth","valueAxis","getOtherAxis","barMinHeight","setLayout","size","valueDim","baseDim","stacked","isValueAxisH","isHorizontal","valueAxisStart","getValueAxisStart","len","baseValue","sign","baseCoord","p","n","x","y","height","coord","dataToPoint","isNaN","setItemLayout","largeLayout","plan","reset","coordLayout","grid","getRect","valueAxisHorizontal","valueDimIdx","progress","largePoints","largeBackgroundPoints","largeDataIndices","dataIndex","valuePair","pointsOffset","idxOffset","next","backgroundStart","pipelineContext","large","toGlobalCoord","dataToCoord","exports"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar _number = require(\"../util/number\");\n\nvar parsePercent = _number.parsePercent;\n\nvar _dataStackHelper = require(\"../data/helper/dataStackHelper\");\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\n\nvar createRenderPlanner = require(\"../chart/helper/createRenderPlanner\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/* global Float32Array */\nvar STACK_PREFIX = '__ec_stack_';\nvar LARGE_BAR_MIN_WIDTH = 0.5;\nvar LargeArr = typeof Float32Array !== 'undefined' ? Float32Array : Array;\n\nfunction getSeriesStackId(seriesModel) {\n  return seriesModel.get('stack') || STACK_PREFIX + seriesModel.seriesIndex;\n}\n\nfunction getAxisKey(axis) {\n  return axis.dim + axis.index;\n}\n/**\n * @param {Object} opt\n * @param {module:echarts/coord/Axis} opt.axis Only support category axis currently.\n * @param {number} opt.count Positive interger.\n * @param {number} [opt.barWidth]\n * @param {number} [opt.barMaxWidth]\n * @param {number} [opt.barMinWidth]\n * @param {number} [opt.barGap]\n * @param {number} [opt.barCategoryGap]\n * @return {Object} {width, offset, offsetCenter} If axis.type is not 'category', return undefined.\n */\n\n\nfunction getLayoutOnAxis(opt) {\n  var params = [];\n  var baseAxis = opt.axis;\n  var axisKey = 'axis0';\n\n  if (baseAxis.type !== 'category') {\n    return;\n  }\n\n  var bandWidth = baseAxis.getBandWidth();\n\n  for (var i = 0; i < opt.count || 0; i++) {\n    params.push(zrUtil.defaults({\n      bandWidth: bandWidth,\n      axisKey: axisKey,\n      stackId: STACK_PREFIX + i\n    }, opt));\n  }\n\n  var widthAndOffsets = doCalBarWidthAndOffset(params);\n  var result = [];\n\n  for (var i = 0; i < opt.count; i++) {\n    var item = widthAndOffsets[axisKey][STACK_PREFIX + i];\n    item.offsetCenter = item.offset + item.width / 2;\n    result.push(item);\n  }\n\n  return result;\n}\n\nfunction prepareLayoutBarSeries(seriesType, ecModel) {\n  var seriesModels = [];\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    // Check series coordinate, do layout for cartesian2d only\n    if (isOnCartesian(seriesModel) && !isInLargeMode(seriesModel)) {\n      seriesModels.push(seriesModel);\n    }\n  });\n  return seriesModels;\n}\n/**\n * Map from (baseAxis.dim + '_' + baseAxis.index) to min gap of two adjacent\n * values.\n * This works for time axes, value axes, and log axes.\n * For a single time axis, return value is in the form like\n * {'x_0': [1000000]}.\n * The value of 1000000 is in milliseconds.\n */\n\n\nfunction getValueAxesMinGaps(barSeries) {\n  /**\n   * Map from axis.index to values.\n   * For a single time axis, axisValues is in the form like\n   * {'x_0': [1495555200000, 1495641600000, 1495728000000]}.\n   * Items in axisValues[x], e.g. 1495555200000, are time values of all\n   * series.\n   */\n  var axisValues = {};\n  zrUtil.each(barSeries, function (seriesModel) {\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n\n    if (baseAxis.type !== 'time' && baseAxis.type !== 'value') {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var key = baseAxis.dim + '_' + baseAxis.index;\n    var dim = data.mapDimension(baseAxis.dim);\n\n    for (var i = 0, cnt = data.count(); i < cnt; ++i) {\n      var value = data.get(dim, i);\n\n      if (!axisValues[key]) {\n        // No previous data for the axis\n        axisValues[key] = [value];\n      } else {\n        // No value in previous series\n        axisValues[key].push(value);\n      } // Ignore duplicated time values in the same axis\n\n    }\n  });\n  var axisMinGaps = [];\n\n  for (var key in axisValues) {\n    if (axisValues.hasOwnProperty(key)) {\n      var valuesInAxis = axisValues[key];\n\n      if (valuesInAxis) {\n        // Sort axis values into ascending order to calculate gaps\n        valuesInAxis.sort(function (a, b) {\n          return a - b;\n        });\n        var min = null;\n\n        for (var j = 1; j < valuesInAxis.length; ++j) {\n          var delta = valuesInAxis[j] - valuesInAxis[j - 1];\n\n          if (delta > 0) {\n            // Ignore 0 delta because they are of the same axis value\n            min = min === null ? delta : Math.min(min, delta);\n          }\n        } // Set to null if only have one data\n\n\n        axisMinGaps[key] = min;\n      }\n    }\n  }\n\n  return axisMinGaps;\n}\n\nfunction makeColumnLayout(barSeries) {\n  var axisMinGaps = getValueAxesMinGaps(barSeries);\n  var seriesInfoList = [];\n  zrUtil.each(barSeries, function (seriesModel) {\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var axisExtent = baseAxis.getExtent();\n    var bandWidth;\n\n    if (baseAxis.type === 'category') {\n      bandWidth = baseAxis.getBandWidth();\n    } else if (baseAxis.type === 'value' || baseAxis.type === 'time') {\n      var key = baseAxis.dim + '_' + baseAxis.index;\n      var minGap = axisMinGaps[key];\n      var extentSpan = Math.abs(axisExtent[1] - axisExtent[0]);\n      var scale = baseAxis.scale.getExtent();\n      var scaleSpan = Math.abs(scale[1] - scale[0]);\n      bandWidth = minGap ? extentSpan / scaleSpan * minGap : extentSpan; // When there is only one data value\n    } else {\n      var data = seriesModel.getData();\n      bandWidth = Math.abs(axisExtent[1] - axisExtent[0]) / data.count();\n    }\n\n    var barWidth = parsePercent(seriesModel.get('barWidth'), bandWidth);\n    var barMaxWidth = parsePercent(seriesModel.get('barMaxWidth'), bandWidth);\n    var barMinWidth = parsePercent( // barMinWidth by default is 1 in cartesian. Because in value axis,\n    // the auto-calculated bar width might be less than 1.\n    seriesModel.get('barMinWidth') || 1, bandWidth);\n    var barGap = seriesModel.get('barGap');\n    var barCategoryGap = seriesModel.get('barCategoryGap');\n    seriesInfoList.push({\n      bandWidth: bandWidth,\n      barWidth: barWidth,\n      barMaxWidth: barMaxWidth,\n      barMinWidth: barMinWidth,\n      barGap: barGap,\n      barCategoryGap: barCategoryGap,\n      axisKey: getAxisKey(baseAxis),\n      stackId: getSeriesStackId(seriesModel)\n    });\n  });\n  return doCalBarWidthAndOffset(seriesInfoList);\n}\n\nfunction doCalBarWidthAndOffset(seriesInfoList) {\n  // Columns info on each category axis. Key is cartesian name\n  var columnsMap = {};\n  zrUtil.each(seriesInfoList, function (seriesInfo, idx) {\n    var axisKey = seriesInfo.axisKey;\n    var bandWidth = seriesInfo.bandWidth;\n    var columnsOnAxis = columnsMap[axisKey] || {\n      bandWidth: bandWidth,\n      remainedWidth: bandWidth,\n      autoWidthCount: 0,\n      categoryGap: '20%',\n      gap: '30%',\n      stacks: {}\n    };\n    var stacks = columnsOnAxis.stacks;\n    columnsMap[axisKey] = columnsOnAxis;\n    var stackId = seriesInfo.stackId;\n\n    if (!stacks[stackId]) {\n      columnsOnAxis.autoWidthCount++;\n    }\n\n    stacks[stackId] = stacks[stackId] || {\n      width: 0,\n      maxWidth: 0\n    }; // Caution: In a single coordinate system, these barGrid attributes\n    // will be shared by series. Consider that they have default values,\n    // only the attributes set on the last series will work.\n    // Do not change this fact unless there will be a break change.\n\n    var barWidth = seriesInfo.barWidth;\n\n    if (barWidth && !stacks[stackId].width) {\n      // See #6312, do not restrict width.\n      stacks[stackId].width = barWidth;\n      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n      columnsOnAxis.remainedWidth -= barWidth;\n    }\n\n    var barMaxWidth = seriesInfo.barMaxWidth;\n    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n    var barMinWidth = seriesInfo.barMinWidth;\n    barMinWidth && (stacks[stackId].minWidth = barMinWidth);\n    var barGap = seriesInfo.barGap;\n    barGap != null && (columnsOnAxis.gap = barGap);\n    var barCategoryGap = seriesInfo.barCategoryGap;\n    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);\n  });\n  var result = {};\n  zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n    result[coordSysName] = {};\n    var stacks = columnsOnAxis.stacks;\n    var bandWidth = columnsOnAxis.bandWidth;\n    var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);\n    var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n    var remainedWidth = columnsOnAxis.remainedWidth;\n    var autoWidthCount = columnsOnAxis.autoWidthCount;\n    var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0); // Find if any auto calculated bar exceeded maxBarWidth\n\n    zrUtil.each(stacks, function (column) {\n      var maxWidth = column.maxWidth;\n      var minWidth = column.minWidth;\n\n      if (!column.width) {\n        var finalWidth = autoWidth;\n\n        if (maxWidth && maxWidth < finalWidth) {\n          finalWidth = Math.min(maxWidth, remainedWidth);\n        } // `minWidth` has higher priority. `minWidth` decide that wheter the\n        // bar is able to be visible. So `minWidth` should not be restricted\n        // by `maxWidth` or `remainedWidth` (which is from `bandWidth`). In\n        // the extreme cases for `value` axis, bars are allowed to overlap\n        // with each other if `minWidth` specified.\n\n\n        if (minWidth && minWidth > finalWidth) {\n          finalWidth = minWidth;\n        }\n\n        if (finalWidth !== autoWidth) {\n          column.width = finalWidth;\n          remainedWidth -= finalWidth + barGapPercent * finalWidth;\n          autoWidthCount--;\n        }\n      } else {\n        // `barMinWidth/barMaxWidth` has higher priority than `barWidth`, as\n        // CSS does. Becuase barWidth can be a percent value, where\n        // `barMaxWidth` can be used to restrict the final width.\n        var finalWidth = column.width;\n\n        if (maxWidth) {\n          finalWidth = Math.min(finalWidth, maxWidth);\n        } // `minWidth` has higher priority, as described above\n\n\n        if (minWidth) {\n          finalWidth = Math.max(finalWidth, minWidth);\n        }\n\n        column.width = finalWidth;\n        remainedWidth -= finalWidth + barGapPercent * finalWidth;\n        autoWidthCount--;\n      }\n    }); // Recalculate width again\n\n    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0);\n    var widthSum = 0;\n    var lastColumn;\n    zrUtil.each(stacks, function (column, idx) {\n      if (!column.width) {\n        column.width = autoWidth;\n      }\n\n      lastColumn = column;\n      widthSum += column.width * (1 + barGapPercent);\n    });\n\n    if (lastColumn) {\n      widthSum -= lastColumn.width * barGapPercent;\n    }\n\n    var offset = -widthSum / 2;\n    zrUtil.each(stacks, function (column, stackId) {\n      result[coordSysName][stackId] = result[coordSysName][stackId] || {\n        bandWidth: bandWidth,\n        offset: offset,\n        width: column.width\n      };\n      offset += column.width * (1 + barGapPercent);\n    });\n  });\n  return result;\n}\n/**\n * @param {Object} barWidthAndOffset The result of makeColumnLayout\n * @param {module:echarts/coord/Axis} axis\n * @param {module:echarts/model/Series} [seriesModel] If not provided, return all.\n * @return {Object} {stackId: {offset, width}} or {offset, width} if seriesModel provided.\n */\n\n\nfunction retrieveColumnLayout(barWidthAndOffset, axis, seriesModel) {\n  if (barWidthAndOffset && axis) {\n    var result = barWidthAndOffset[getAxisKey(axis)];\n\n    if (result != null && seriesModel != null) {\n      result = result[getSeriesStackId(seriesModel)];\n    }\n\n    return result;\n  }\n}\n/**\n * @param {string} seriesType\n * @param {module:echarts/model/Global} ecModel\n */\n\n\nfunction layout(seriesType, ecModel) {\n  var seriesModels = prepareLayoutBarSeries(seriesType, ecModel);\n  var barWidthAndOffset = makeColumnLayout(seriesModels);\n  var lastStackCoords = {};\n  var lastStackCoordsOrigin = {};\n  zrUtil.each(seriesModels, function (seriesModel) {\n    var data = seriesModel.getData();\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var stackId = getSeriesStackId(seriesModel);\n    var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n    var columnOffset = columnLayoutInfo.offset;\n    var columnWidth = columnLayoutInfo.width;\n    var valueAxis = cartesian.getOtherAxis(baseAxis);\n    var barMinHeight = seriesModel.get('barMinHeight') || 0;\n    lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n    lastStackCoordsOrigin[stackId] = lastStackCoordsOrigin[stackId] || []; // Fix #4243\n\n    data.setLayout({\n      bandWidth: columnLayoutInfo.bandWidth,\n      offset: columnOffset,\n      size: columnWidth\n    });\n    var valueDim = data.mapDimension(valueAxis.dim);\n    var baseDim = data.mapDimension(baseAxis.dim);\n    var stacked = isDimensionStacked(data, valueDim\n    /*, baseDim*/\n    );\n    var isValueAxisH = valueAxis.isHorizontal();\n    var valueAxisStart = getValueAxisStart(baseAxis, valueAxis, stacked);\n\n    for (var idx = 0, len = data.count(); idx < len; idx++) {\n      var value = data.get(valueDim, idx);\n      var baseValue = data.get(baseDim, idx);\n      var sign = value >= 0 ? 'p' : 'n';\n      var baseCoord = valueAxisStart; // Because of the barMinHeight, we can not use the value in\n      // stackResultDimension directly.\n\n      if (stacked) {\n        // Only ordinal axis can be stacked.\n        if (!lastStackCoords[stackId][baseValue]) {\n          lastStackCoords[stackId][baseValue] = {\n            p: valueAxisStart,\n            // Positive stack\n            n: valueAxisStart // Negative stack\n\n          };\n        } // Should also consider #4243\n\n\n        baseCoord = lastStackCoords[stackId][baseValue][sign];\n      }\n\n      var x;\n      var y;\n      var width;\n      var height;\n\n      if (isValueAxisH) {\n        var coord = cartesian.dataToPoint([value, baseValue]);\n        x = baseCoord;\n        y = coord[1] + columnOffset;\n        width = coord[0] - valueAxisStart;\n        height = columnWidth;\n\n        if (Math.abs(width) < barMinHeight) {\n          width = (width < 0 ? -1 : 1) * barMinHeight;\n        } // Ignore stack from NaN value\n\n\n        if (!isNaN(width)) {\n          stacked && (lastStackCoords[stackId][baseValue][sign] += width);\n        }\n      } else {\n        var coord = cartesian.dataToPoint([baseValue, value]);\n        x = coord[0] + columnOffset;\n        y = baseCoord;\n        width = columnWidth;\n        height = coord[1] - valueAxisStart;\n\n        if (Math.abs(height) < barMinHeight) {\n          // Include zero to has a positive bar\n          height = (height <= 0 ? -1 : 1) * barMinHeight;\n        } // Ignore stack from NaN value\n\n\n        if (!isNaN(height)) {\n          stacked && (lastStackCoords[stackId][baseValue][sign] += height);\n        }\n      }\n\n      data.setItemLayout(idx, {\n        x: x,\n        y: y,\n        width: width,\n        height: height\n      });\n    }\n  }, this);\n} // TODO: Do not support stack in large mode yet.\n\n\nvar largeLayout = {\n  seriesType: 'bar',\n  plan: createRenderPlanner(),\n  reset: function (seriesModel) {\n    if (!isOnCartesian(seriesModel) || !isInLargeMode(seriesModel)) {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var cartesian = seriesModel.coordinateSystem;\n    var coordLayout = cartesian.grid.getRect();\n    var baseAxis = cartesian.getBaseAxis();\n    var valueAxis = cartesian.getOtherAxis(baseAxis);\n    var valueDim = data.mapDimension(valueAxis.dim);\n    var baseDim = data.mapDimension(baseAxis.dim);\n    var valueAxisHorizontal = valueAxis.isHorizontal();\n    var valueDimIdx = valueAxisHorizontal ? 0 : 1;\n    var barWidth = retrieveColumnLayout(makeColumnLayout([seriesModel]), baseAxis, seriesModel).width;\n\n    if (!(barWidth > LARGE_BAR_MIN_WIDTH)) {\n      // jshint ignore:line\n      barWidth = LARGE_BAR_MIN_WIDTH;\n    }\n\n    return {\n      progress: progress\n    };\n\n    function progress(params, data) {\n      var count = params.count;\n      var largePoints = new LargeArr(count * 2);\n      var largeBackgroundPoints = new LargeArr(count * 2);\n      var largeDataIndices = new LargeArr(count);\n      var dataIndex;\n      var coord = [];\n      var valuePair = [];\n      var pointsOffset = 0;\n      var idxOffset = 0;\n\n      while ((dataIndex = params.next()) != null) {\n        valuePair[valueDimIdx] = data.get(valueDim, dataIndex);\n        valuePair[1 - valueDimIdx] = data.get(baseDim, dataIndex);\n        coord = cartesian.dataToPoint(valuePair, null, coord); // Data index might not be in order, depends on `progressiveChunkMode`.\n\n        largeBackgroundPoints[pointsOffset] = valueAxisHorizontal ? coordLayout.x + coordLayout.width : coord[0];\n        largePoints[pointsOffset++] = coord[0];\n        largeBackgroundPoints[pointsOffset] = valueAxisHorizontal ? coord[1] : coordLayout.y + coordLayout.height;\n        largePoints[pointsOffset++] = coord[1];\n        largeDataIndices[idxOffset++] = dataIndex;\n      }\n\n      data.setLayout({\n        largePoints: largePoints,\n        largeDataIndices: largeDataIndices,\n        largeBackgroundPoints: largeBackgroundPoints,\n        barWidth: barWidth,\n        valueAxisStart: getValueAxisStart(baseAxis, valueAxis, false),\n        backgroundStart: valueAxisHorizontal ? coordLayout.x : coordLayout.y,\n        valueAxisHorizontal: valueAxisHorizontal\n      });\n    }\n  }\n};\n\nfunction isOnCartesian(seriesModel) {\n  return seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'cartesian2d';\n}\n\nfunction isInLargeMode(seriesModel) {\n  return seriesModel.pipelineContext && seriesModel.pipelineContext.large;\n} // See cases in `test/bar-start.html` and `#7412`, `#8747`.\n\n\nfunction getValueAxisStart(baseAxis, valueAxis, stacked) {\n  return valueAxis.toGlobalCoord(valueAxis.dataToCoord(valueAxis.type === 'log' ? 1 : 0));\n}\n\nexports.getLayoutOnAxis = getLayoutOnAxis;\nexports.prepareLayoutBarSeries = prepareLayoutBarSeries;\nexports.makeColumnLayout = makeColumnLayout;\nexports.retrieveColumnLayout = retrieveColumnLayout;\nexports.layout = layout;\nexports.largeLayout = largeLayout;"]}]}