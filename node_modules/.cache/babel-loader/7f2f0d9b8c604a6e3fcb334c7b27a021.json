{"remainingRequest":"/Users/id-repair/Documents/SEOL/4c-dashboard/node_modules/babel-loader/lib/index.js!/Users/id-repair/Documents/SEOL/4c-dashboard/node_modules/echarts/lib/coord/axisHelper.js","dependencies":[{"path":"/Users/id-repair/Documents/SEOL/4c-dashboard/node_modules/echarts/lib/coord/axisHelper.js","mtime":499162500000},{"path":"/Users/id-repair/Documents/SEOL/4c-dashboard/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/id-repair/Documents/SEOL/4c-dashboard/node_modules/babel-loader/lib/index.js","mtime":315532800000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:cmVxdWlyZSgiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjLmpzIik7CgpyZXF1aXJlKCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnJlcGxhY2UuanMiKTsKCi8qCiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZQoqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZQoqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uCiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZQoqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUKKiAiTGljZW5zZSIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlCiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdAoqCiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAKKgoqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywKKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbgoqICJBUyBJUyIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWQoqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZQoqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMKKiB1bmRlciB0aGUgTGljZW5zZS4KKi8KdmFyIF9jb25maWcgPSByZXF1aXJlKCIuLi9jb25maWciKTsKCnZhciBfX0RFVl9fID0gX2NvbmZpZy5fX0RFVl9fOwoKdmFyIHpyVXRpbCA9IHJlcXVpcmUoInpyZW5kZXIvbGliL2NvcmUvdXRpbCIpOwoKdmFyIE9yZGluYWxTY2FsZSA9IHJlcXVpcmUoIi4uL3NjYWxlL09yZGluYWwiKTsKCnZhciBJbnRlcnZhbFNjYWxlID0gcmVxdWlyZSgiLi4vc2NhbGUvSW50ZXJ2YWwiKTsKCnZhciBTY2FsZSA9IHJlcXVpcmUoIi4uL3NjYWxlL1NjYWxlIik7Cgp2YXIgbnVtYmVyVXRpbCA9IHJlcXVpcmUoIi4uL3V0aWwvbnVtYmVyIik7Cgp2YXIgX2JhckdyaWQgPSByZXF1aXJlKCIuLi9sYXlvdXQvYmFyR3JpZCIpOwoKdmFyIHByZXBhcmVMYXlvdXRCYXJTZXJpZXMgPSBfYmFyR3JpZC5wcmVwYXJlTGF5b3V0QmFyU2VyaWVzOwp2YXIgbWFrZUNvbHVtbkxheW91dCA9IF9iYXJHcmlkLm1ha2VDb2x1bW5MYXlvdXQ7CnZhciByZXRyaWV2ZUNvbHVtbkxheW91dCA9IF9iYXJHcmlkLnJldHJpZXZlQ29sdW1uTGF5b3V0OwoKdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoInpyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0Iik7CgpyZXF1aXJlKCIuLi9zY2FsZS9UaW1lIik7CgpyZXF1aXJlKCIuLi9zY2FsZS9Mb2ciKTsKLyoKKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lCiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlCiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24KKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlCiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZQoqICJMaWNlbnNlIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2UKKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0CioKKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMAoqCiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLAoqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuCiogIkFTIElTIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZCiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlCiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucwoqIHVuZGVyIHRoZSBMaWNlbnNlLgoqLwoKLyoqCiAqIEdldCBheGlzIHNjYWxlIGV4dGVudCBiZWZvcmUgbmljZWQuCiAqIEl0ZW0gb2YgcmV0dXJuZWQgYXJyYXkgY2FuIG9ubHkgYmUgbnVtYmVyIChpbmNsdWRpbmcgSW5maW5pdHkgYW5kIE5hTikuCiAqLwoKCmZ1bmN0aW9uIGdldFNjYWxlRXh0ZW50KHNjYWxlLCBtb2RlbCkgewogIHZhciBzY2FsZVR5cGUgPSBzY2FsZS50eXBlOwogIHZhciBtaW4gPSBtb2RlbC5nZXRNaW4oKTsKICB2YXIgbWF4ID0gbW9kZWwuZ2V0TWF4KCk7CiAgdmFyIG9yaWdpbmFsRXh0ZW50ID0gc2NhbGUuZ2V0RXh0ZW50KCk7CiAgdmFyIGF4aXNEYXRhTGVuOwogIHZhciBib3VuZGFyeUdhcDsKICB2YXIgc3BhbjsKCiAgaWYgKHNjYWxlVHlwZSA9PT0gJ29yZGluYWwnKSB7CiAgICBheGlzRGF0YUxlbiA9IG1vZGVsLmdldENhdGVnb3JpZXMoKS5sZW5ndGg7CiAgfSBlbHNlIHsKICAgIGJvdW5kYXJ5R2FwID0gbW9kZWwuZ2V0KCdib3VuZGFyeUdhcCcpOwoKICAgIGlmICghenJVdGlsLmlzQXJyYXkoYm91bmRhcnlHYXApKSB7CiAgICAgIGJvdW5kYXJ5R2FwID0gW2JvdW5kYXJ5R2FwIHx8IDAsIGJvdW5kYXJ5R2FwIHx8IDBdOwogICAgfQoKICAgIGlmICh0eXBlb2YgYm91bmRhcnlHYXBbMF0gPT09ICdib29sZWFuJykgewogICAgICBib3VuZGFyeUdhcCA9IFswLCAwXTsKICAgIH0KCiAgICBib3VuZGFyeUdhcFswXSA9IG51bWJlclV0aWwucGFyc2VQZXJjZW50KGJvdW5kYXJ5R2FwWzBdLCAxKTsKICAgIGJvdW5kYXJ5R2FwWzFdID0gbnVtYmVyVXRpbC5wYXJzZVBlcmNlbnQoYm91bmRhcnlHYXBbMV0sIDEpOwogICAgc3BhbiA9IG9yaWdpbmFsRXh0ZW50WzFdIC0gb3JpZ2luYWxFeHRlbnRbMF0gfHwgTWF0aC5hYnMob3JpZ2luYWxFeHRlbnRbMF0pOwogIH0gLy8gTm90aWNlOiBXaGVuIG1pbi9tYXggaXMgbm90IHNldCAodGhhdCBpcywgd2hlbiB0aGVyZSBhcmUgbnVsbC91bmRlZmluZWQsCiAgLy8gd2hpY2ggaXMgdGhlIG1vc3QgY29tbW9uIGNhc2UpLCB0aGVzZSBjYXNlcyBzaG91bGQgYmUgZW5zdXJlZDoKICAvLyAoMSkgRm9yICdvcmRpbmFsJywgc2hvdyBhbGwgYXhpcy5kYXRhLgogIC8vICgyKSBGb3Igb3RoZXJzOgogIC8vICAgICAgKyBgYm91bmRhcnlHYXBgIGlzIGFwcGxpZWQgKGlmIG1pbi9tYXggc2V0LCBib3VuZGFyeUdhcCBpcwogIC8vICAgICAgZGlzYWJsZWQpLgogIC8vICAgICAgKyBJZiBgbmVlZENyb3NzWmVyb2AsIG1pbi9tYXggc2hvdWxkIGJlIHplcm8sIG90aGVyd2lzZSwgbWluL21heCBzaG91bGQKICAvLyAgICAgIGJlIHRoZSByZXN1bHQgdGhhdCBvcmlnaW5hbEV4dGVudCBlbmxhcmdlZCBieSBib3VuZGFyeUdhcC4KICAvLyAoMykgSWYgbm8gZGF0YSwgaXQgc2hvdWxkIGJlIGVuc3VyZWQgdGhhdCBgc2NhbGUuc2V0QmxhbmtgIGlzIHNldC4KICAvLyBGSVhNRQogIC8vICgxKSBXaGVuIG1pbi9tYXggaXMgJ2RhdGFNaW4nIG9yICdkYXRhTWF4Jywgc2hvdWxkIGJvdW5kYXJ5R2FwIGJlIGFibGUgdG8gdXNlZD8KICAvLyAoMikgV2hlbiBgbmVlZENyb3NzWmVyb2AgYW5kIGFsbCBkYXRhIGlzIHBvc2l0aXZlL25lZ2F0aXZlLCBzaG91bGQgaXQgYmUgZW5zdXJlZAogIC8vIHRoYXQgdGhlIHJlc3VsdHMgcHJvY2Vzc2VkIGJ5IGJvdW5kYXJ5R2FwIGFyZSBwb3NpdGl2ZS9uZWdhdGl2ZT8KCgogIGlmIChtaW4gPT09ICdkYXRhTWluJykgewogICAgbWluID0gb3JpZ2luYWxFeHRlbnRbMF07CiAgfSBlbHNlIGlmICh0eXBlb2YgbWluID09PSAnZnVuY3Rpb24nKSB7CiAgICBtaW4gPSBtaW4oewogICAgICBtaW46IG9yaWdpbmFsRXh0ZW50WzBdLAogICAgICBtYXg6IG9yaWdpbmFsRXh0ZW50WzFdCiAgICB9KTsKICB9CgogIGlmIChtYXggPT09ICdkYXRhTWF4JykgewogICAgbWF4ID0gb3JpZ2luYWxFeHRlbnRbMV07CiAgfSBlbHNlIGlmICh0eXBlb2YgbWF4ID09PSAnZnVuY3Rpb24nKSB7CiAgICBtYXggPSBtYXgoewogICAgICBtaW46IG9yaWdpbmFsRXh0ZW50WzBdLAogICAgICBtYXg6IG9yaWdpbmFsRXh0ZW50WzFdCiAgICB9KTsKICB9CgogIHZhciBmaXhNaW4gPSBtaW4gIT0gbnVsbDsKICB2YXIgZml4TWF4ID0gbWF4ICE9IG51bGw7CgogIGlmIChtaW4gPT0gbnVsbCkgewogICAgbWluID0gc2NhbGVUeXBlID09PSAnb3JkaW5hbCcgPyBheGlzRGF0YUxlbiA/IDAgOiBOYU4gOiBvcmlnaW5hbEV4dGVudFswXSAtIGJvdW5kYXJ5R2FwWzBdICogc3BhbjsKICB9CgogIGlmIChtYXggPT0gbnVsbCkgewogICAgbWF4ID0gc2NhbGVUeXBlID09PSAnb3JkaW5hbCcgPyBheGlzRGF0YUxlbiA/IGF4aXNEYXRhTGVuIC0gMSA6IE5hTiA6IG9yaWdpbmFsRXh0ZW50WzFdICsgYm91bmRhcnlHYXBbMV0gKiBzcGFuOwogIH0KCiAgKG1pbiA9PSBudWxsIHx8ICFpc0Zpbml0ZShtaW4pKSAmJiAobWluID0gTmFOKTsKICAobWF4ID09IG51bGwgfHwgIWlzRmluaXRlKG1heCkpICYmIChtYXggPSBOYU4pOwogIHNjYWxlLnNldEJsYW5rKHpyVXRpbC5lcU5hTihtaW4pIHx8IHpyVXRpbC5lcU5hTihtYXgpIHx8IHNjYWxlVHlwZSA9PT0gJ29yZGluYWwnICYmICFzY2FsZS5nZXRPcmRpbmFsTWV0YSgpLmNhdGVnb3JpZXMubGVuZ3RoKTsgLy8gRXZhbHVhdGUgaWYgYXhpcyBuZWVkcyBjcm9zcyB6ZXJvCgogIGlmIChtb2RlbC5nZXROZWVkQ3Jvc3NaZXJvKCkpIHsKICAgIC8vIEF4aXMgaXMgb3ZlciB6ZXJvIGFuZCBtaW4gaXMgbm90IHNldAogICAgaWYgKG1pbiA+IDAgJiYgbWF4ID4gMCAmJiAhZml4TWluKSB7CiAgICAgIG1pbiA9IDA7CiAgICB9IC8vIEF4aXMgaXMgdW5kZXIgemVybyBhbmQgbWF4IGlzIG5vdCBzZXQKCgogICAgaWYgKG1pbiA8IDAgJiYgbWF4IDwgMCAmJiAhZml4TWF4KSB7CiAgICAgIG1heCA9IDA7CiAgICB9CiAgfSAvLyBJZiBiYXJzIGFyZSBwbGFjZWQgb24gYSBiYXNlIGF4aXMgb2YgdHlwZSB0aW1lIG9yIGludGVydmFsIGFjY291bnQgZm9yIGF4aXMgYm91bmRhcnkgb3ZlcmZsb3cgYW5kIGN1cnJlbnQgYXhpcwogIC8vIGlzIGJhc2UgYXhpcwogIC8vIEZJWE1FCiAgLy8gKDEpIENvbnNpZGVyIHN1cHBvcnQgdmFsdWUgYXhpcywgd2hlcmUgYmVsb3cgemVybyBhbmQgYXhpcyBgb25aZXJvYCBzaG91bGQgYmUgaGFuZGxlZCBwcm9wZXJseS4KICAvLyAoMikgUmVmYWN0b3IgdGhlIGxvZ2ljIHdpdGggYGJhckdyaWRgLiBJcyBpdCBub3QgbmVlZCB0byBgbWFrZUJhcldpZHRoQW5kT2Zmc2V0SW5mb2AgdHdpY2Ugd2l0aCBkaWZmZXJlbnQgZXh0ZW50PwogIC8vICAgICBTaG91bGQgbm90IGRlcGVuZCBvbiBzZXJpZXMgdHlwZSBgYmFyYD8KICAvLyAoMykgRml4IHRoYXQgbWlnaHQgb3ZlcmxhcCB3aGVuIHVzaW5nIGRhdGFab29tLgogIC8vICg0KSBDb25zaWRlciBvdGhlciBjaGFydCB0eXBlcyB1c2luZyBgYmFyR3JpZGA/CiAgLy8gU2VlICM2NzI4LCAjNDg2MiwgYHRlc3QvYmFyLW92ZXJmbG93LXRpbWUtcGxvdC5odG1sYAoKCiAgdmFyIGVjTW9kZWwgPSBtb2RlbC5lY01vZGVsOwoKICBpZiAoZWNNb2RlbCAmJiBzY2FsZVR5cGUgPT09ICd0aW1lJwogIC8qfHwgc2NhbGVUeXBlID09PSAnaW50ZXJ2YWwnICovCiAgKSB7CiAgICAgIHZhciBiYXJTZXJpZXNNb2RlbHMgPSBwcmVwYXJlTGF5b3V0QmFyU2VyaWVzKCdiYXInLCBlY01vZGVsKTsKICAgICAgdmFyIGlzQmFzZUF4aXNBbmRIYXNCYXJTZXJpZXM7CiAgICAgIHpyVXRpbC5lYWNoKGJhclNlcmllc01vZGVscywgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7CiAgICAgICAgaXNCYXNlQXhpc0FuZEhhc0JhclNlcmllcyB8PSBzZXJpZXNNb2RlbC5nZXRCYXNlQXhpcygpID09PSBtb2RlbC5heGlzOwogICAgICB9KTsKCiAgICAgIGlmIChpc0Jhc2VBeGlzQW5kSGFzQmFyU2VyaWVzKSB7CiAgICAgICAgLy8gQ2FsY3VsYXRlIHBsYWNlbWVudCBvZiBiYXJzIG9uIGF4aXMKICAgICAgICB2YXIgYmFyV2lkdGhBbmRPZmZzZXQgPSBtYWtlQ29sdW1uTGF5b3V0KGJhclNlcmllc01vZGVscyk7IC8vIEFkanVzdCBheGlzIG1pbiBhbmQgbWF4IHRvIGFjY291bnQgZm9yIG92ZXJmbG93CgogICAgICAgIHZhciBhZGp1c3RlZFNjYWxlID0gYWRqdXN0U2NhbGVGb3JPdmVyZmxvdyhtaW4sIG1heCwgbW9kZWwsIGJhcldpZHRoQW5kT2Zmc2V0KTsKICAgICAgICBtaW4gPSBhZGp1c3RlZFNjYWxlLm1pbjsKICAgICAgICBtYXggPSBhZGp1c3RlZFNjYWxlLm1heDsKICAgICAgfQogICAgfQoKICByZXR1cm4gewogICAgZXh0ZW50OiBbbWluLCBtYXhdLAogICAgLy8gImZpeCIgbWVhbnMgImZpeGVkIiwgdGhlIHZhbHVlIHNob3VsZCBub3QgYmUKICAgIC8vIGNoYW5nZWQgaW4gdGhlIHN1YnNlcXVlbnQgc3RlcHMuCiAgICBmaXhNaW46IGZpeE1pbiwKICAgIGZpeE1heDogZml4TWF4CiAgfTsKfQoKZnVuY3Rpb24gYWRqdXN0U2NhbGVGb3JPdmVyZmxvdyhtaW4sIG1heCwgbW9kZWwsIGJhcldpZHRoQW5kT2Zmc2V0KSB7CiAgLy8gR2V0IEF4aXMgTGVuZ3RoCiAgdmFyIGF4aXNFeHRlbnQgPSBtb2RlbC5heGlzLmdldEV4dGVudCgpOwogIHZhciBheGlzTGVuZ3RoID0gYXhpc0V4dGVudFsxXSAtIGF4aXNFeHRlbnRbMF07IC8vIEdldCBiYXJzIG9uIGN1cnJlbnQgYmFzZSBheGlzIGFuZCBjYWxjdWxhdGUgbWluIGFuZCBtYXggb3ZlcmZsb3cKCiAgdmFyIGJhcnNPbkN1cnJlbnRBeGlzID0gcmV0cmlldmVDb2x1bW5MYXlvdXQoYmFyV2lkdGhBbmRPZmZzZXQsIG1vZGVsLmF4aXMpOwoKICBpZiAoYmFyc09uQ3VycmVudEF4aXMgPT09IHVuZGVmaW5lZCkgewogICAgcmV0dXJuIHsKICAgICAgbWluOiBtaW4sCiAgICAgIG1heDogbWF4CiAgICB9OwogIH0KCiAgdmFyIG1pbk92ZXJmbG93ID0gSW5maW5pdHk7CiAgenJVdGlsLmVhY2goYmFyc09uQ3VycmVudEF4aXMsIGZ1bmN0aW9uIChpdGVtKSB7CiAgICBtaW5PdmVyZmxvdyA9IE1hdGgubWluKGl0ZW0ub2Zmc2V0LCBtaW5PdmVyZmxvdyk7CiAgfSk7CiAgdmFyIG1heE92ZXJmbG93ID0gLUluZmluaXR5OwogIHpyVXRpbC5lYWNoKGJhcnNPbkN1cnJlbnRBeGlzLCBmdW5jdGlvbiAoaXRlbSkgewogICAgbWF4T3ZlcmZsb3cgPSBNYXRoLm1heChpdGVtLm9mZnNldCArIGl0ZW0ud2lkdGgsIG1heE92ZXJmbG93KTsKICB9KTsKICBtaW5PdmVyZmxvdyA9IE1hdGguYWJzKG1pbk92ZXJmbG93KTsKICBtYXhPdmVyZmxvdyA9IE1hdGguYWJzKG1heE92ZXJmbG93KTsKICB2YXIgdG90YWxPdmVyRmxvdyA9IG1pbk92ZXJmbG93ICsgbWF4T3ZlcmZsb3c7IC8vIENhbHVsYXRlIHJlcXVpcmVkIGJ1ZmZlciBiYXNlZCBvbiBvbGQgcmFuZ2UgYW5kIG92ZXJmbG93CgogIHZhciBvbGRSYW5nZSA9IG1heCAtIG1pbjsKICB2YXIgb2xkUmFuZ2VQZXJjZW50T2ZOZXcgPSAxIC0gKG1pbk92ZXJmbG93ICsgbWF4T3ZlcmZsb3cpIC8gYXhpc0xlbmd0aDsKICB2YXIgb3ZlcmZsb3dCdWZmZXIgPSBvbGRSYW5nZSAvIG9sZFJhbmdlUGVyY2VudE9mTmV3IC0gb2xkUmFuZ2U7CiAgbWF4ICs9IG92ZXJmbG93QnVmZmVyICogKG1heE92ZXJmbG93IC8gdG90YWxPdmVyRmxvdyk7CiAgbWluIC09IG92ZXJmbG93QnVmZmVyICogKG1pbk92ZXJmbG93IC8gdG90YWxPdmVyRmxvdyk7CiAgcmV0dXJuIHsKICAgIG1pbjogbWluLAogICAgbWF4OiBtYXgKICB9Owp9CgpmdW5jdGlvbiBuaWNlU2NhbGVFeHRlbnQoc2NhbGUsIG1vZGVsKSB7CiAgdmFyIGV4dGVudEluZm8gPSBnZXRTY2FsZUV4dGVudChzY2FsZSwgbW9kZWwpOwogIHZhciBleHRlbnQgPSBleHRlbnRJbmZvLmV4dGVudDsKICB2YXIgc3BsaXROdW1iZXIgPSBtb2RlbC5nZXQoJ3NwbGl0TnVtYmVyJyk7CgogIGlmIChzY2FsZS50eXBlID09PSAnbG9nJykgewogICAgc2NhbGUuYmFzZSA9IG1vZGVsLmdldCgnbG9nQmFzZScpOwogIH0KCiAgdmFyIHNjYWxlVHlwZSA9IHNjYWxlLnR5cGU7CiAgc2NhbGUuc2V0RXh0ZW50KGV4dGVudFswXSwgZXh0ZW50WzFdKTsKICBzY2FsZS5uaWNlRXh0ZW50KHsKICAgIHNwbGl0TnVtYmVyOiBzcGxpdE51bWJlciwKICAgIGZpeE1pbjogZXh0ZW50SW5mby5maXhNaW4sCiAgICBmaXhNYXg6IGV4dGVudEluZm8uZml4TWF4LAogICAgbWluSW50ZXJ2YWw6IHNjYWxlVHlwZSA9PT0gJ2ludGVydmFsJyB8fCBzY2FsZVR5cGUgPT09ICd0aW1lJyA/IG1vZGVsLmdldCgnbWluSW50ZXJ2YWwnKSA6IG51bGwsCiAgICBtYXhJbnRlcnZhbDogc2NhbGVUeXBlID09PSAnaW50ZXJ2YWwnIHx8IHNjYWxlVHlwZSA9PT0gJ3RpbWUnID8gbW9kZWwuZ2V0KCdtYXhJbnRlcnZhbCcpIDogbnVsbAogIH0pOyAvLyBJZiBzb21lIG9uZSBzcGVjaWZpZWQgdGhlIG1pbiwgbWF4LiBBbmQgdGhlIGRlZmF1bHQgY2FsY3VsYXRlZCBpbnRlcnZhbAogIC8vIGlzIG5vdCBnb29kIGVub3VnaC4gSGUgY2FuIHNwZWNpZnkgdGhlIGludGVydmFsLiBJdCBpcyBvZnRlbiBhcHBlYXJlZAogIC8vIGluIGFuZ2xlIGF4aXMgd2l0aCBhbmdsZSAwIC0gMzYwLiBJbnRlcnZhbCBjYWxjdWxhdGVkIGluIGludGVydmFsIHNjYWxlIGlzIGhhcmQKICAvLyB0byBiZSA2MC4KICAvLyBGSVhNRQoKICB2YXIgaW50ZXJ2YWwgPSBtb2RlbC5nZXQoJ2ludGVydmFsJyk7CgogIGlmIChpbnRlcnZhbCAhPSBudWxsKSB7CiAgICBzY2FsZS5zZXRJbnRlcnZhbCAmJiBzY2FsZS5zZXRJbnRlcnZhbChpbnRlcnZhbCk7CiAgfQp9Ci8qKgogKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBtb2RlbAogKiBAcGFyYW0ge3N0cmluZ30gW2F4aXNUeXBlXSBEZWZhdWx0IHJldHJpZXZlIGZyb20gbW9kZWwudHlwZQogKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9zY2FsZS8qfQogKi8KCgpmdW5jdGlvbiBjcmVhdGVTY2FsZUJ5TW9kZWwobW9kZWwsIGF4aXNUeXBlKSB7CiAgYXhpc1R5cGUgPSBheGlzVHlwZSB8fCBtb2RlbC5nZXQoJ3R5cGUnKTsKCiAgaWYgKGF4aXNUeXBlKSB7CiAgICBzd2l0Y2ggKGF4aXNUeXBlKSB7CiAgICAgIC8vIEJ1aWxkaW4gc2NhbGUKICAgICAgY2FzZSAnY2F0ZWdvcnknOgogICAgICAgIHJldHVybiBuZXcgT3JkaW5hbFNjYWxlKG1vZGVsLmdldE9yZGluYWxNZXRhID8gbW9kZWwuZ2V0T3JkaW5hbE1ldGEoKSA6IG1vZGVsLmdldENhdGVnb3JpZXMoKSwgW0luZmluaXR5LCAtSW5maW5pdHldKTsKCiAgICAgIGNhc2UgJ3ZhbHVlJzoKICAgICAgICByZXR1cm4gbmV3IEludGVydmFsU2NhbGUoKTsKICAgICAgLy8gRXh0ZW5kZWQgc2NhbGUsIGxpa2UgdGltZSBhbmQgbG9nCgogICAgICBkZWZhdWx0OgogICAgICAgIHJldHVybiAoU2NhbGUuZ2V0Q2xhc3MoYXhpc1R5cGUpIHx8IEludGVydmFsU2NhbGUpLmNyZWF0ZShtb2RlbCk7CiAgICB9CiAgfQp9Ci8qKgogKiBDaGVjayBpZiB0aGUgYXhpcyBjb3JzcyAwCiAqLwoKCmZ1bmN0aW9uIGlmQXhpc0Nyb3NzWmVybyhheGlzKSB7CiAgdmFyIGRhdGFFeHRlbnQgPSBheGlzLnNjYWxlLmdldEV4dGVudCgpOwogIHZhciBtaW4gPSBkYXRhRXh0ZW50WzBdOwogIHZhciBtYXggPSBkYXRhRXh0ZW50WzFdOwogIHJldHVybiAhKG1pbiA+IDAgJiYgbWF4ID4gMCB8fCBtaW4gPCAwICYmIG1heCA8IDApOwp9Ci8qKgogKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkL0F4aXN9IGF4aXMKICogQHJldHVybiB7RnVuY3Rpb259IExhYmVsIGZvcm1hdHRlciBmdW5jdGlvbi4KICogICAgICAgICBwYXJhbToge251bWJlcn0gdGlja1ZhbHVlLAogKiAgICAgICAgIHBhcmFtOiB7bnVtYmVyfSBpZHgsIHRoZSBpbmRleCBpbiBhbGwgdGlja3MuCiAqICAgICAgICAgICAgICAgICAgICAgICAgIElmIGNhdGVnb3J5IGF4aXMsIHRoaXMgcGFyYW0gaXMgbm90IHJlcXVpZWQuCiAqICAgICAgICAgcmV0dXJuOiB7c3RyaW5nfSBsYWJlbCBzdHJpbmcuCiAqLwoKCmZ1bmN0aW9uIG1ha2VMYWJlbEZvcm1hdHRlcihheGlzKSB7CiAgdmFyIGxhYmVsRm9ybWF0dGVyID0gYXhpcy5nZXRMYWJlbE1vZGVsKCkuZ2V0KCdmb3JtYXR0ZXInKTsKICB2YXIgY2F0ZWdvcnlUaWNrU3RhcnQgPSBheGlzLnR5cGUgPT09ICdjYXRlZ29yeScgPyBheGlzLnNjYWxlLmdldEV4dGVudCgpWzBdIDogbnVsbDsKCiAgaWYgKHR5cGVvZiBsYWJlbEZvcm1hdHRlciA9PT0gJ3N0cmluZycpIHsKICAgIGxhYmVsRm9ybWF0dGVyID0gZnVuY3Rpb24gKHRwbCkgewogICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCkgewogICAgICAgIC8vIEZvciBjYXRlZ29yeSBheGlzLCBnZXQgcmF3IHZhbHVlOyBmb3IgbnVtZXJpYyBheGlzLAogICAgICAgIC8vIGdldCBmb3JhbXR0ZWQgbGFiZWwgbGlrZSAnMSwzMzMsNDQ0Jy4KICAgICAgICB2YWwgPSBheGlzLnNjYWxlLmdldExhYmVsKHZhbCk7CiAgICAgICAgcmV0dXJuIHRwbC5yZXBsYWNlKCd7dmFsdWV9JywgdmFsICE9IG51bGwgPyB2YWwgOiAnJyk7CiAgICAgIH07CiAgICB9KGxhYmVsRm9ybWF0dGVyKTsgLy8gQ29uc2lkZXIgZW1wdHkgYXJyYXkKCgogICAgcmV0dXJuIGxhYmVsRm9ybWF0dGVyOwogIH0gZWxzZSBpZiAodHlwZW9mIGxhYmVsRm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7CiAgICByZXR1cm4gZnVuY3Rpb24gKHRpY2tWYWx1ZSwgaWR4KSB7CiAgICAgIC8vIFRoZSBvcmlnaW5hbCBpbnRlbnRpb24gb2YgYGlkeGAgaXMgInRoZSBpbmRleCBvZiB0aGUgdGljayBpbiBhbGwgdGlja3MiLgogICAgICAvLyBCdXQgdGhlIHByZXZpb3VzIGltcGxlbWVudGF0aW9uIG9mIGNhdGVnb3J5IGF4aXMgZG8gbm90IGNvbnNpZGVyIHRoZQogICAgICAvLyBgYXhpc0xhYmVsLmludGVydmFsYCwgd2hpY2ggY2F1c2UgdGhhdCwgZm9yIGV4YW1wbGUsIHRoZSBgaW50ZXJ2YWxgIGlzCiAgICAgIC8vIGAxYCwgdGhlbiB0aGUgdGlja3MgIm5hbWU1IiwgIm5hbWU3IiwgIm5hbWU5IiBhcmUgZGlzcGxheWVkLCB3aGVyZSB0aGUKICAgICAgLy8gY29ycmVzcG9uZGluZyBgaWR4YCBhcmUgYDBgLCBgMmAsIGA0YCwgYnV0IG5vdCBgMGAsIGAxYCwgYDJgLiBTbyB3ZSBrZWVwCiAgICAgIC8vIHRoZSBkZWZpbml0aW9uIGhlcmUgZm9yIGJhY2sgY29tcGF0aWJpbGl0eS4KICAgICAgaWYgKGNhdGVnb3J5VGlja1N0YXJ0ICE9IG51bGwpIHsKICAgICAgICBpZHggPSB0aWNrVmFsdWUgLSBjYXRlZ29yeVRpY2tTdGFydDsKICAgICAgfQoKICAgICAgcmV0dXJuIGxhYmVsRm9ybWF0dGVyKGdldEF4aXNSYXdWYWx1ZShheGlzLCB0aWNrVmFsdWUpLCBpZHgpOwogICAgfTsKICB9IGVsc2UgewogICAgcmV0dXJuIGZ1bmN0aW9uICh0aWNrKSB7CiAgICAgIHJldHVybiBheGlzLnNjYWxlLmdldExhYmVsKHRpY2spOwogICAgfTsKICB9Cn0KCmZ1bmN0aW9uIGdldEF4aXNSYXdWYWx1ZShheGlzLCB2YWx1ZSkgewogIC8vIEluIGNhdGVnb3J5IGF4aXMgd2l0aCBkYXRhIHpvb20sIHRpY2sgaXMgbm90IHRoZSBvcmlnaW5hbAogIC8vIGluZGV4IG9mIGF4aXMuZGF0YS4gU28gdGljayBzaG91bGQgbm90IGJlIGV4cG9zZWQgdG8gdXNlcgogIC8vIGluIGNhdGVnb3J5IGF4aXMuCiAgcmV0dXJuIGF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JyA/IGF4aXMuc2NhbGUuZ2V0TGFiZWwodmFsdWUpIDogdmFsdWU7Cn0KLyoqCiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29vcmQvQXhpc30gYXhpcwogKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH0gQmUgbnVsbC91bmRlZmluZWQgaWYgbm8gbGFiZWxzLgogKi8KCgpmdW5jdGlvbiBlc3RpbWF0ZUxhYmVsVW5pb25SZWN0KGF4aXMpIHsKICB2YXIgYXhpc01vZGVsID0gYXhpcy5tb2RlbDsKICB2YXIgc2NhbGUgPSBheGlzLnNjYWxlOwoKICBpZiAoIWF4aXNNb2RlbC5nZXQoJ2F4aXNMYWJlbC5zaG93JykgfHwgc2NhbGUuaXNCbGFuaygpKSB7CiAgICByZXR1cm47CiAgfQoKICB2YXIgaXNDYXRlZ29yeSA9IGF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JzsKICB2YXIgcmVhbE51bWJlclNjYWxlVGlja3M7CiAgdmFyIHRpY2tDb3VudDsKICB2YXIgY2F0ZWdvcnlTY2FsZUV4dGVudCA9IHNjYWxlLmdldEV4dGVudCgpOyAvLyBPcHRpbWl6ZSBmb3IgbGFyZ2UgY2F0ZWdvcnkgZGF0YSwgYXZvaWQgY2FsbCBgZ2V0VGlja3MoKWAuCgogIGlmIChpc0NhdGVnb3J5KSB7CiAgICB0aWNrQ291bnQgPSBzY2FsZS5jb3VudCgpOwogIH0gZWxzZSB7CiAgICByZWFsTnVtYmVyU2NhbGVUaWNrcyA9IHNjYWxlLmdldFRpY2tzKCk7CiAgICB0aWNrQ291bnQgPSByZWFsTnVtYmVyU2NhbGVUaWNrcy5sZW5ndGg7CiAgfQoKICB2YXIgYXhpc0xhYmVsTW9kZWwgPSBheGlzLmdldExhYmVsTW9kZWwoKTsKICB2YXIgbGFiZWxGb3JtYXR0ZXIgPSBtYWtlTGFiZWxGb3JtYXR0ZXIoYXhpcyk7CiAgdmFyIHJlY3Q7CiAgdmFyIHN0ZXAgPSAxOyAvLyBTaW1wbGUgb3B0aW1pemF0aW9uIGZvciBsYXJnZSBhbW91bnQgb2YgbGFiZWxzCgogIGlmICh0aWNrQ291bnQgPiA0MCkgewogICAgc3RlcCA9IE1hdGguY2VpbCh0aWNrQ291bnQgLyA0MCk7CiAgfQoKICBmb3IgKHZhciBpID0gMDsgaSA8IHRpY2tDb3VudDsgaSArPSBzdGVwKSB7CiAgICB2YXIgdGlja1ZhbHVlID0gcmVhbE51bWJlclNjYWxlVGlja3MgPyByZWFsTnVtYmVyU2NhbGVUaWNrc1tpXSA6IGNhdGVnb3J5U2NhbGVFeHRlbnRbMF0gKyBpOwogICAgdmFyIGxhYmVsID0gbGFiZWxGb3JtYXR0ZXIodGlja1ZhbHVlKTsKICAgIHZhciB1bnJvdGF0ZWRTaW5nbGVSZWN0ID0gYXhpc0xhYmVsTW9kZWwuZ2V0VGV4dFJlY3QobGFiZWwpOwogICAgdmFyIHNpbmdsZVJlY3QgPSByb3RhdGVUZXh0UmVjdCh1bnJvdGF0ZWRTaW5nbGVSZWN0LCBheGlzTGFiZWxNb2RlbC5nZXQoJ3JvdGF0ZScpIHx8IDApOwogICAgcmVjdCA/IHJlY3QudW5pb24oc2luZ2xlUmVjdCkgOiByZWN0ID0gc2luZ2xlUmVjdDsKICB9CgogIHJldHVybiByZWN0Owp9CgpmdW5jdGlvbiByb3RhdGVUZXh0UmVjdCh0ZXh0UmVjdCwgcm90YXRlKSB7CiAgdmFyIHJvdGF0ZVJhZGlhbnMgPSByb3RhdGUgKiBNYXRoLlBJIC8gMTgwOwogIHZhciBib3VuZGluZ0JveCA9IHRleHRSZWN0LnBsYWluKCk7CiAgdmFyIGJlZm9yZVdpZHRoID0gYm91bmRpbmdCb3gud2lkdGg7CiAgdmFyIGJlZm9yZUhlaWdodCA9IGJvdW5kaW5nQm94LmhlaWdodDsKICB2YXIgYWZ0ZXJXaWR0aCA9IGJlZm9yZVdpZHRoICogTWF0aC5hYnMoTWF0aC5jb3Mocm90YXRlUmFkaWFucykpICsgTWF0aC5hYnMoYmVmb3JlSGVpZ2h0ICogTWF0aC5zaW4ocm90YXRlUmFkaWFucykpOwogIHZhciBhZnRlckhlaWdodCA9IGJlZm9yZVdpZHRoICogTWF0aC5hYnMoTWF0aC5zaW4ocm90YXRlUmFkaWFucykpICsgTWF0aC5hYnMoYmVmb3JlSGVpZ2h0ICogTWF0aC5jb3Mocm90YXRlUmFkaWFucykpOwogIHZhciByb3RhdGVkUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoYm91bmRpbmdCb3gueCwgYm91bmRpbmdCb3gueSwgYWZ0ZXJXaWR0aCwgYWZ0ZXJIZWlnaHQpOwogIHJldHVybiByb3RhdGVkUmVjdDsKfQovKioKICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9zcmMvbW9kZWwvTW9kZWx9IG1vZGVsIGF4aXNMYWJlbE1vZGVsIG9yIGF4aXNUaWNrTW9kZWwKICogQHJldHVybiB7bnVtYmVyfFN0cmluZ30gQ2FuIGJlIG51bGx8J2F1dG8nfG51bWJlcnxmdW5jdGlvbgogKi8KCgpmdW5jdGlvbiBnZXRPcHRpb25DYXRlZ29yeUludGVydmFsKG1vZGVsKSB7CiAgdmFyIGludGVydmFsID0gbW9kZWwuZ2V0KCdpbnRlcnZhbCcpOwogIHJldHVybiBpbnRlcnZhbCA9PSBudWxsID8gJ2F1dG8nIDogaW50ZXJ2YWw7Cn0KLyoqCiAqIFNldCBgY2F0ZWdvcnlJbnRlcnZhbGAgYXMgMCBpbXBsaWNpdGx5IGluZGljYXRlcyB0aGF0CiAqIHNob3cgYWxsIGxhYmVscyByZWd1YXJkbGVzcyBvZiBvdmVybGFwLgogKiBAcGFyYW0ge09iamVjdH0gYXhpcyBheGlzTW9kZWwuYXhpcwogKiBAcmV0dXJuIHtib29sZWFufQogKi8KCgpmdW5jdGlvbiBzaG91bGRTaG93QWxsTGFiZWxzKGF4aXMpIHsKICByZXR1cm4gYXhpcy50eXBlID09PSAnY2F0ZWdvcnknICYmIGdldE9wdGlvbkNhdGVnb3J5SW50ZXJ2YWwoYXhpcy5nZXRMYWJlbE1vZGVsKCkpID09PSAwOwp9CgpleHBvcnRzLmdldFNjYWxlRXh0ZW50ID0gZ2V0U2NhbGVFeHRlbnQ7CmV4cG9ydHMubmljZVNjYWxlRXh0ZW50ID0gbmljZVNjYWxlRXh0ZW50OwpleHBvcnRzLmNyZWF0ZVNjYWxlQnlNb2RlbCA9IGNyZWF0ZVNjYWxlQnlNb2RlbDsKZXhwb3J0cy5pZkF4aXNDcm9zc1plcm8gPSBpZkF4aXNDcm9zc1plcm87CmV4cG9ydHMubWFrZUxhYmVsRm9ybWF0dGVyID0gbWFrZUxhYmVsRm9ybWF0dGVyOwpleHBvcnRzLmdldEF4aXNSYXdWYWx1ZSA9IGdldEF4aXNSYXdWYWx1ZTsKZXhwb3J0cy5lc3RpbWF0ZUxhYmVsVW5pb25SZWN0ID0gZXN0aW1hdGVMYWJlbFVuaW9uUmVjdDsKZXhwb3J0cy5nZXRPcHRpb25DYXRlZ29yeUludGVydmFsID0gZ2V0T3B0aW9uQ2F0ZWdvcnlJbnRlcnZhbDsKZXhwb3J0cy5zaG91bGRTaG93QWxsTGFiZWxzID0gc2hvdWxkU2hvd0FsbExhYmVsczs="},{"version":3,"sources":["/Users/id-repair/Documents/SEOL/4c-dashboard/node_modules/echarts/lib/coord/axisHelper.js"],"names":["_config","require","__DEV__","zrUtil","OrdinalScale","IntervalScale","Scale","numberUtil","_barGrid","prepareLayoutBarSeries","makeColumnLayout","retrieveColumnLayout","BoundingRect","getScaleExtent","scale","model","scaleType","type","min","getMin","max","getMax","originalExtent","getExtent","axisDataLen","boundaryGap","span","getCategories","length","get","isArray","parsePercent","Math","abs","fixMin","fixMax","NaN","isFinite","setBlank","eqNaN","getOrdinalMeta","categories","getNeedCrossZero","ecModel","barSeriesModels","isBaseAxisAndHasBarSeries","each","seriesModel","getBaseAxis","axis","barWidthAndOffset","adjustedScale","adjustScaleForOverflow","extent","axisExtent","axisLength","barsOnCurrentAxis","undefined","minOverflow","Infinity","item","offset","maxOverflow","width","totalOverFlow","oldRange","oldRangePercentOfNew","overflowBuffer","niceScaleExtent","extentInfo","splitNumber","base","setExtent","niceExtent","minInterval","maxInterval","interval","setInterval","createScaleByModel","axisType","getClass","create","ifAxisCrossZero","dataExtent","makeLabelFormatter","labelFormatter","getLabelModel","categoryTickStart","tpl","val","getLabel","replace","tickValue","idx","getAxisRawValue","tick","value","estimateLabelUnionRect","axisModel","isBlank","isCategory","realNumberScaleTicks","tickCount","categoryScaleExtent","count","getTicks","axisLabelModel","rect","step","ceil","i","label","unrotatedSingleRect","getTextRect","singleRect","rotateTextRect","union","textRect","rotate","rotateRadians","PI","boundingBox","plain","beforeWidth","beforeHeight","height","afterWidth","cos","sin","afterHeight","rotatedRect","x","y","getOptionCategoryInterval","shouldShowAllLabels","exports"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar _config = require(\"../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar OrdinalScale = require(\"../scale/Ordinal\");\n\nvar IntervalScale = require(\"../scale/Interval\");\n\nvar Scale = require(\"../scale/Scale\");\n\nvar numberUtil = require(\"../util/number\");\n\nvar _barGrid = require(\"../layout/barGrid\");\n\nvar prepareLayoutBarSeries = _barGrid.prepareLayoutBarSeries;\nvar makeColumnLayout = _barGrid.makeColumnLayout;\nvar retrieveColumnLayout = _barGrid.retrieveColumnLayout;\n\nvar BoundingRect = require(\"zrender/lib/core/BoundingRect\");\n\nrequire(\"../scale/Time\");\n\nrequire(\"../scale/Log\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Get axis scale extent before niced.\n * Item of returned array can only be number (including Infinity and NaN).\n */\nfunction getScaleExtent(scale, model) {\n  var scaleType = scale.type;\n  var min = model.getMin();\n  var max = model.getMax();\n  var originalExtent = scale.getExtent();\n  var axisDataLen;\n  var boundaryGap;\n  var span;\n\n  if (scaleType === 'ordinal') {\n    axisDataLen = model.getCategories().length;\n  } else {\n    boundaryGap = model.get('boundaryGap');\n\n    if (!zrUtil.isArray(boundaryGap)) {\n      boundaryGap = [boundaryGap || 0, boundaryGap || 0];\n    }\n\n    if (typeof boundaryGap[0] === 'boolean') {\n      boundaryGap = [0, 0];\n    }\n\n    boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1);\n    boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1);\n    span = originalExtent[1] - originalExtent[0] || Math.abs(originalExtent[0]);\n  } // Notice: When min/max is not set (that is, when there are null/undefined,\n  // which is the most common case), these cases should be ensured:\n  // (1) For 'ordinal', show all axis.data.\n  // (2) For others:\n  //      + `boundaryGap` is applied (if min/max set, boundaryGap is\n  //      disabled).\n  //      + If `needCrossZero`, min/max should be zero, otherwise, min/max should\n  //      be the result that originalExtent enlarged by boundaryGap.\n  // (3) If no data, it should be ensured that `scale.setBlank` is set.\n  // FIXME\n  // (1) When min/max is 'dataMin' or 'dataMax', should boundaryGap be able to used?\n  // (2) When `needCrossZero` and all data is positive/negative, should it be ensured\n  // that the results processed by boundaryGap are positive/negative?\n\n\n  if (min === 'dataMin') {\n    min = originalExtent[0];\n  } else if (typeof min === 'function') {\n    min = min({\n      min: originalExtent[0],\n      max: originalExtent[1]\n    });\n  }\n\n  if (max === 'dataMax') {\n    max = originalExtent[1];\n  } else if (typeof max === 'function') {\n    max = max({\n      min: originalExtent[0],\n      max: originalExtent[1]\n    });\n  }\n\n  var fixMin = min != null;\n  var fixMax = max != null;\n\n  if (min == null) {\n    min = scaleType === 'ordinal' ? axisDataLen ? 0 : NaN : originalExtent[0] - boundaryGap[0] * span;\n  }\n\n  if (max == null) {\n    max = scaleType === 'ordinal' ? axisDataLen ? axisDataLen - 1 : NaN : originalExtent[1] + boundaryGap[1] * span;\n  }\n\n  (min == null || !isFinite(min)) && (min = NaN);\n  (max == null || !isFinite(max)) && (max = NaN);\n  scale.setBlank(zrUtil.eqNaN(min) || zrUtil.eqNaN(max) || scaleType === 'ordinal' && !scale.getOrdinalMeta().categories.length); // Evaluate if axis needs cross zero\n\n  if (model.getNeedCrossZero()) {\n    // Axis is over zero and min is not set\n    if (min > 0 && max > 0 && !fixMin) {\n      min = 0;\n    } // Axis is under zero and max is not set\n\n\n    if (min < 0 && max < 0 && !fixMax) {\n      max = 0;\n    }\n  } // If bars are placed on a base axis of type time or interval account for axis boundary overflow and current axis\n  // is base axis\n  // FIXME\n  // (1) Consider support value axis, where below zero and axis `onZero` should be handled properly.\n  // (2) Refactor the logic with `barGrid`. Is it not need to `makeBarWidthAndOffsetInfo` twice with different extent?\n  //     Should not depend on series type `bar`?\n  // (3) Fix that might overlap when using dataZoom.\n  // (4) Consider other chart types using `barGrid`?\n  // See #6728, #4862, `test/bar-overflow-time-plot.html`\n\n\n  var ecModel = model.ecModel;\n\n  if (ecModel && scaleType === 'time'\n  /*|| scaleType === 'interval' */\n  ) {\n    var barSeriesModels = prepareLayoutBarSeries('bar', ecModel);\n    var isBaseAxisAndHasBarSeries;\n    zrUtil.each(barSeriesModels, function (seriesModel) {\n      isBaseAxisAndHasBarSeries |= seriesModel.getBaseAxis() === model.axis;\n    });\n\n    if (isBaseAxisAndHasBarSeries) {\n      // Calculate placement of bars on axis\n      var barWidthAndOffset = makeColumnLayout(barSeriesModels); // Adjust axis min and max to account for overflow\n\n      var adjustedScale = adjustScaleForOverflow(min, max, model, barWidthAndOffset);\n      min = adjustedScale.min;\n      max = adjustedScale.max;\n    }\n  }\n\n  return {\n    extent: [min, max],\n    // \"fix\" means \"fixed\", the value should not be\n    // changed in the subsequent steps.\n    fixMin: fixMin,\n    fixMax: fixMax\n  };\n}\n\nfunction adjustScaleForOverflow(min, max, model, barWidthAndOffset) {\n  // Get Axis Length\n  var axisExtent = model.axis.getExtent();\n  var axisLength = axisExtent[1] - axisExtent[0]; // Get bars on current base axis and calculate min and max overflow\n\n  var barsOnCurrentAxis = retrieveColumnLayout(barWidthAndOffset, model.axis);\n\n  if (barsOnCurrentAxis === undefined) {\n    return {\n      min: min,\n      max: max\n    };\n  }\n\n  var minOverflow = Infinity;\n  zrUtil.each(barsOnCurrentAxis, function (item) {\n    minOverflow = Math.min(item.offset, minOverflow);\n  });\n  var maxOverflow = -Infinity;\n  zrUtil.each(barsOnCurrentAxis, function (item) {\n    maxOverflow = Math.max(item.offset + item.width, maxOverflow);\n  });\n  minOverflow = Math.abs(minOverflow);\n  maxOverflow = Math.abs(maxOverflow);\n  var totalOverFlow = minOverflow + maxOverflow; // Calulate required buffer based on old range and overflow\n\n  var oldRange = max - min;\n  var oldRangePercentOfNew = 1 - (minOverflow + maxOverflow) / axisLength;\n  var overflowBuffer = oldRange / oldRangePercentOfNew - oldRange;\n  max += overflowBuffer * (maxOverflow / totalOverFlow);\n  min -= overflowBuffer * (minOverflow / totalOverFlow);\n  return {\n    min: min,\n    max: max\n  };\n}\n\nfunction niceScaleExtent(scale, model) {\n  var extentInfo = getScaleExtent(scale, model);\n  var extent = extentInfo.extent;\n  var splitNumber = model.get('splitNumber');\n\n  if (scale.type === 'log') {\n    scale.base = model.get('logBase');\n  }\n\n  var scaleType = scale.type;\n  scale.setExtent(extent[0], extent[1]);\n  scale.niceExtent({\n    splitNumber: splitNumber,\n    fixMin: extentInfo.fixMin,\n    fixMax: extentInfo.fixMax,\n    minInterval: scaleType === 'interval' || scaleType === 'time' ? model.get('minInterval') : null,\n    maxInterval: scaleType === 'interval' || scaleType === 'time' ? model.get('maxInterval') : null\n  }); // If some one specified the min, max. And the default calculated interval\n  // is not good enough. He can specify the interval. It is often appeared\n  // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard\n  // to be 60.\n  // FIXME\n\n  var interval = model.get('interval');\n\n  if (interval != null) {\n    scale.setInterval && scale.setInterval(interval);\n  }\n}\n/**\n * @param {module:echarts/model/Model} model\n * @param {string} [axisType] Default retrieve from model.type\n * @return {module:echarts/scale/*}\n */\n\n\nfunction createScaleByModel(model, axisType) {\n  axisType = axisType || model.get('type');\n\n  if (axisType) {\n    switch (axisType) {\n      // Buildin scale\n      case 'category':\n        return new OrdinalScale(model.getOrdinalMeta ? model.getOrdinalMeta() : model.getCategories(), [Infinity, -Infinity]);\n\n      case 'value':\n        return new IntervalScale();\n      // Extended scale, like time and log\n\n      default:\n        return (Scale.getClass(axisType) || IntervalScale).create(model);\n    }\n  }\n}\n/**\n * Check if the axis corss 0\n */\n\n\nfunction ifAxisCrossZero(axis) {\n  var dataExtent = axis.scale.getExtent();\n  var min = dataExtent[0];\n  var max = dataExtent[1];\n  return !(min > 0 && max > 0 || min < 0 && max < 0);\n}\n/**\n * @param {module:echarts/coord/Axis} axis\n * @return {Function} Label formatter function.\n *         param: {number} tickValue,\n *         param: {number} idx, the index in all ticks.\n *                         If category axis, this param is not requied.\n *         return: {string} label string.\n */\n\n\nfunction makeLabelFormatter(axis) {\n  var labelFormatter = axis.getLabelModel().get('formatter');\n  var categoryTickStart = axis.type === 'category' ? axis.scale.getExtent()[0] : null;\n\n  if (typeof labelFormatter === 'string') {\n    labelFormatter = function (tpl) {\n      return function (val) {\n        // For category axis, get raw value; for numeric axis,\n        // get foramtted label like '1,333,444'.\n        val = axis.scale.getLabel(val);\n        return tpl.replace('{value}', val != null ? val : '');\n      };\n    }(labelFormatter); // Consider empty array\n\n\n    return labelFormatter;\n  } else if (typeof labelFormatter === 'function') {\n    return function (tickValue, idx) {\n      // The original intention of `idx` is \"the index of the tick in all ticks\".\n      // But the previous implementation of category axis do not consider the\n      // `axisLabel.interval`, which cause that, for example, the `interval` is\n      // `1`, then the ticks \"name5\", \"name7\", \"name9\" are displayed, where the\n      // corresponding `idx` are `0`, `2`, `4`, but not `0`, `1`, `2`. So we keep\n      // the definition here for back compatibility.\n      if (categoryTickStart != null) {\n        idx = tickValue - categoryTickStart;\n      }\n\n      return labelFormatter(getAxisRawValue(axis, tickValue), idx);\n    };\n  } else {\n    return function (tick) {\n      return axis.scale.getLabel(tick);\n    };\n  }\n}\n\nfunction getAxisRawValue(axis, value) {\n  // In category axis with data zoom, tick is not the original\n  // index of axis.data. So tick should not be exposed to user\n  // in category axis.\n  return axis.type === 'category' ? axis.scale.getLabel(value) : value;\n}\n/**\n * @param {module:echarts/coord/Axis} axis\n * @return {module:zrender/core/BoundingRect} Be null/undefined if no labels.\n */\n\n\nfunction estimateLabelUnionRect(axis) {\n  var axisModel = axis.model;\n  var scale = axis.scale;\n\n  if (!axisModel.get('axisLabel.show') || scale.isBlank()) {\n    return;\n  }\n\n  var isCategory = axis.type === 'category';\n  var realNumberScaleTicks;\n  var tickCount;\n  var categoryScaleExtent = scale.getExtent(); // Optimize for large category data, avoid call `getTicks()`.\n\n  if (isCategory) {\n    tickCount = scale.count();\n  } else {\n    realNumberScaleTicks = scale.getTicks();\n    tickCount = realNumberScaleTicks.length;\n  }\n\n  var axisLabelModel = axis.getLabelModel();\n  var labelFormatter = makeLabelFormatter(axis);\n  var rect;\n  var step = 1; // Simple optimization for large amount of labels\n\n  if (tickCount > 40) {\n    step = Math.ceil(tickCount / 40);\n  }\n\n  for (var i = 0; i < tickCount; i += step) {\n    var tickValue = realNumberScaleTicks ? realNumberScaleTicks[i] : categoryScaleExtent[0] + i;\n    var label = labelFormatter(tickValue);\n    var unrotatedSingleRect = axisLabelModel.getTextRect(label);\n    var singleRect = rotateTextRect(unrotatedSingleRect, axisLabelModel.get('rotate') || 0);\n    rect ? rect.union(singleRect) : rect = singleRect;\n  }\n\n  return rect;\n}\n\nfunction rotateTextRect(textRect, rotate) {\n  var rotateRadians = rotate * Math.PI / 180;\n  var boundingBox = textRect.plain();\n  var beforeWidth = boundingBox.width;\n  var beforeHeight = boundingBox.height;\n  var afterWidth = beforeWidth * Math.abs(Math.cos(rotateRadians)) + Math.abs(beforeHeight * Math.sin(rotateRadians));\n  var afterHeight = beforeWidth * Math.abs(Math.sin(rotateRadians)) + Math.abs(beforeHeight * Math.cos(rotateRadians));\n  var rotatedRect = new BoundingRect(boundingBox.x, boundingBox.y, afterWidth, afterHeight);\n  return rotatedRect;\n}\n/**\n * @param {module:echarts/src/model/Model} model axisLabelModel or axisTickModel\n * @return {number|String} Can be null|'auto'|number|function\n */\n\n\nfunction getOptionCategoryInterval(model) {\n  var interval = model.get('interval');\n  return interval == null ? 'auto' : interval;\n}\n/**\n * Set `categoryInterval` as 0 implicitly indicates that\n * show all labels reguardless of overlap.\n * @param {Object} axis axisModel.axis\n * @return {boolean}\n */\n\n\nfunction shouldShowAllLabels(axis) {\n  return axis.type === 'category' && getOptionCategoryInterval(axis.getLabelModel()) === 0;\n}\n\nexports.getScaleExtent = getScaleExtent;\nexports.niceScaleExtent = niceScaleExtent;\nexports.createScaleByModel = createScaleByModel;\nexports.ifAxisCrossZero = ifAxisCrossZero;\nexports.makeLabelFormatter = makeLabelFormatter;\nexports.getAxisRawValue = getAxisRawValue;\nexports.estimateLabelUnionRect = estimateLabelUnionRect;\nexports.getOptionCategoryInterval = getOptionCategoryInterval;\nexports.shouldShowAllLabels = shouldShowAllLabels;"]}]}