{"remainingRequest":"/Users/id-repair/Documents/SEOL/4c-dashboard/node_modules/babel-loader/lib/index.js!/Users/id-repair/Documents/SEOL/4c-dashboard/node_modules/echarts/lib/data/List.js","dependencies":[{"path":"/Users/id-repair/Documents/SEOL/4c-dashboard/node_modules/echarts/lib/data/List.js","mtime":499162500000},{"path":"/Users/id-repair/Documents/SEOL/4c-dashboard/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/id-repair/Documents/SEOL/4c-dashboard/node_modules/babel-loader/lib/index.js","mtime":315532800000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:dmFyIF90eXBlb2YgPSByZXF1aXJlKCIvVXNlcnMvaWQtcmVwYWlyL0RvY3VtZW50cy9TRU9MLzRjLWRhc2hib2FyZC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YiKS5kZWZhdWx0OwoKcmVxdWlyZSgiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LWJ1ZmZlci5zbGljZS5qcyIpOwoKcmVxdWlyZSgiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanMiKTsKCnJlcXVpcmUoImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5mbG9hdDY0LWFycmF5LmpzIik7CgpyZXF1aXJlKCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuY29weS13aXRoaW4uanMiKTsKCnJlcXVpcmUoImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5ldmVyeS5qcyIpOwoKcmVxdWlyZSgiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbGwuanMiKTsKCnJlcXVpcmUoImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maWx0ZXIuanMiKTsKCnJlcXVpcmUoImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maW5kLmpzIik7CgpyZXF1aXJlKCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmluZC1pbmRleC5qcyIpOwoKcmVxdWlyZSgiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZvci1lYWNoLmpzIik7CgpyZXF1aXJlKCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuaW5jbHVkZXMuanMiKTsKCnJlcXVpcmUoImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbmRleC1vZi5qcyIpOwoKcmVxdWlyZSgiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lml0ZXJhdG9yLmpzIik7CgpyZXF1aXJlKCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuam9pbi5qcyIpOwoKcmVxdWlyZSgiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lmxhc3QtaW5kZXgtb2YuanMiKTsKCnJlcXVpcmUoImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5tYXAuanMiKTsKCnJlcXVpcmUoImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZWR1Y2UuanMiKTsKCnJlcXVpcmUoImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZWR1Y2UtcmlnaHQuanMiKTsKCnJlcXVpcmUoImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZXZlcnNlLmpzIik7CgpyZXF1aXJlKCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc2V0LmpzIik7CgpyZXF1aXJlKCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc2xpY2UuanMiKTsKCnJlcXVpcmUoImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zb21lLmpzIik7CgpyZXF1aXJlKCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc29ydC5qcyIpOwoKcmVxdWlyZSgiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnN1YmFycmF5LmpzIik7CgpyZXF1aXJlKCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudG8tbG9jYWxlLXN0cmluZy5qcyIpOwoKcmVxdWlyZSgiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnRvLXN0cmluZy5qcyIpOwoKcmVxdWlyZSgiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmludDMyLWFycmF5LmpzIik7CgpyZXF1aXJlKCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudWludDMyLWFycmF5LmpzIik7CgpyZXF1aXJlKCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudWludDE2LWFycmF5LmpzIik7CgpyZXF1aXJlKCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2UuanMiKTsKCnJlcXVpcmUoImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb25jYXQuanMiKTsKCnJlcXVpcmUoImNvcmUtanMvbW9kdWxlcy9lcy5mdW5jdGlvbi5uYW1lLmpzIik7CgpyZXF1aXJlKCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkubWFwLmpzIik7CgovKgoqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmUKKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGUKKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbgoqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGUKKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlCiogIkxpY2Vuc2UiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZQoqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQKKgoqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wCioKKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsCiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4KKiAiQVMgSVMiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkKKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUKKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zCiogdW5kZXIgdGhlIExpY2Vuc2UuCiovCnZhciBfY29uZmlnID0gcmVxdWlyZSgiLi4vY29uZmlnIik7Cgp2YXIgX19ERVZfXyA9IF9jb25maWcuX19ERVZfXzsKCnZhciB6clV0aWwgPSByZXF1aXJlKCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWwiKTsKCnZhciBNb2RlbCA9IHJlcXVpcmUoIi4uL21vZGVsL01vZGVsIik7Cgp2YXIgRGF0YURpZmZlciA9IHJlcXVpcmUoIi4vRGF0YURpZmZlciIpOwoKdmFyIFNvdXJjZSA9IHJlcXVpcmUoIi4vU291cmNlIik7Cgp2YXIgX2RhdGFQcm92aWRlciA9IHJlcXVpcmUoIi4vaGVscGVyL2RhdGFQcm92aWRlciIpOwoKdmFyIGRlZmF1bHREaW1WYWx1ZUdldHRlcnMgPSBfZGF0YVByb3ZpZGVyLmRlZmF1bHREaW1WYWx1ZUdldHRlcnM7CnZhciBEZWZhdWx0RGF0YVByb3ZpZGVyID0gX2RhdGFQcm92aWRlci5EZWZhdWx0RGF0YVByb3ZpZGVyOwoKdmFyIF9kaW1lbnNpb25IZWxwZXIgPSByZXF1aXJlKCIuL2hlbHBlci9kaW1lbnNpb25IZWxwZXIiKTsKCnZhciBzdW1tYXJpemVEaW1lbnNpb25zID0gX2RpbWVuc2lvbkhlbHBlci5zdW1tYXJpemVEaW1lbnNpb25zOwoKdmFyIERhdGFEaW1lbnNpb25JbmZvID0gcmVxdWlyZSgiLi9EYXRhRGltZW5zaW9uSW5mbyIpOwovKgoqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmUKKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGUKKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbgoqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGUKKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlCiogIkxpY2Vuc2UiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZQoqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQKKgoqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wCioKKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsCiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4KKiAiQVMgSVMiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkKKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUKKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zCiogdW5kZXIgdGhlIExpY2Vuc2UuCiovCgovKiBnbG9iYWwgRmxvYXQ2NEFycmF5LCBJbnQzMkFycmF5LCBVaW50MzJBcnJheSwgVWludDE2QXJyYXkgKi8KCi8qKgogKiBMaXN0IGZvciBkYXRhIHN0b3JhZ2UKICogQG1vZHVsZSBlY2hhcnRzL2RhdGEvTGlzdAogKi8KCgp2YXIgaXNPYmplY3QgPSB6clV0aWwuaXNPYmplY3Q7CnZhciBVTkRFRklORUQgPSAndW5kZWZpbmVkJzsKdmFyIElOREVYX05PVF9GT1VORCA9IC0xOyAvLyBVc2UgcHJlZml4IHRvIGF2b2lkIGluZGV4IHRvIGJlIHRoZSBzYW1lIGFzIG90aGVySWRMaXN0W2lkeF0sCi8vIHdoaWNoIHdpbGwgY2F1c2Ugd2VpcmQgdWRwYXRlIGFuaW1hdGlvbi4KCnZhciBJRF9QUkVGSVggPSAnZVwwXDAnOwp2YXIgZGF0YUN0b3JzID0gewogICdmbG9hdCc6ICh0eXBlb2YgRmxvYXQ2NEFycmF5ID09PSAidW5kZWZpbmVkIiA/ICJ1bmRlZmluZWQiIDogX3R5cGVvZihGbG9hdDY0QXJyYXkpKSA9PT0gVU5ERUZJTkVEID8gQXJyYXkgOiBGbG9hdDY0QXJyYXksCiAgJ2ludCc6ICh0eXBlb2YgSW50MzJBcnJheSA9PT0gInVuZGVmaW5lZCIgPyAidW5kZWZpbmVkIiA6IF90eXBlb2YoSW50MzJBcnJheSkpID09PSBVTkRFRklORUQgPyBBcnJheSA6IEludDMyQXJyYXksCiAgLy8gT3JkaW5hbCBkYXRhIHR5cGUgY2FuIGJlIHN0cmluZyBvciBpbnQKICAnb3JkaW5hbCc6IEFycmF5LAogICdudW1iZXInOiBBcnJheSwKICAndGltZSc6IEFycmF5Cn07IC8vIENhdXRpb246IE1VU1Qgbm90IHVzZSBgbmV3IEN0b3JVaW50MzJBcnJheShhcnIsIDAsIGxlbilgLCBiZWNhdXNlIHRoZSBDdG9yIG9mIGFycmF5IGlzCi8vIGRpZmZlcmVudCBmcm9tIHRoZSBDdG9yIG9mIHR5cGVkIGFycmF5LgoKdmFyIEN0b3JVaW50MzJBcnJheSA9ICh0eXBlb2YgVWludDMyQXJyYXkgPT09ICJ1bmRlZmluZWQiID8gInVuZGVmaW5lZCIgOiBfdHlwZW9mKFVpbnQzMkFycmF5KSkgPT09IFVOREVGSU5FRCA/IEFycmF5IDogVWludDMyQXJyYXk7CnZhciBDdG9ySW50MzJBcnJheSA9ICh0eXBlb2YgSW50MzJBcnJheSA9PT0gInVuZGVmaW5lZCIgPyAidW5kZWZpbmVkIiA6IF90eXBlb2YoSW50MzJBcnJheSkpID09PSBVTkRFRklORUQgPyBBcnJheSA6IEludDMyQXJyYXk7CnZhciBDdG9yVWludDE2QXJyYXkgPSAodHlwZW9mIFVpbnQxNkFycmF5ID09PSAidW5kZWZpbmVkIiA/ICJ1bmRlZmluZWQiIDogX3R5cGVvZihVaW50MTZBcnJheSkpID09PSBVTkRFRklORUQgPyBBcnJheSA6IFVpbnQxNkFycmF5OwoKZnVuY3Rpb24gZ2V0SW5kaWNlc0N0b3IobGlzdCkgewogIC8vIFRoZSBwb3NzaWJsZSBtYXggdmFsdWUgaW4gdGhpcy5faW5kaWNpZXMgaXMgYWx3YXlzIHRoaXMuX3Jhd0NvdW50IGRlc3BpdGUgb2YgZmlsdGVyaW5nLgogIHJldHVybiBsaXN0Ll9yYXdDb3VudCA+IDY1NTM1ID8gQ3RvclVpbnQzMkFycmF5IDogQ3RvclVpbnQxNkFycmF5Owp9CgpmdW5jdGlvbiBjbG9uZUNodW5rKG9yaWdpbmFsQ2h1bmspIHsKICB2YXIgQ3RvciA9IG9yaWdpbmFsQ2h1bmsuY29uc3RydWN0b3I7IC8vIE9ubHkgc2hhbGxvdyBjbG9uZSBpcyBlbm91Z2ggd2hlbiBBcnJheS4KCiAgcmV0dXJuIEN0b3IgPT09IEFycmF5ID8gb3JpZ2luYWxDaHVuay5zbGljZSgpIDogbmV3IEN0b3Iob3JpZ2luYWxDaHVuayk7Cn0KCnZhciBUUkFOU0ZFUkFCTEVfUFJPUEVSVElFUyA9IFsnaGFzSXRlbU9wdGlvbicsICdfbmFtZUxpc3QnLCAnX2lkTGlzdCcsICdfaW52ZXJ0ZWRJbmRpY2VzTWFwJywgJ19yYXdEYXRhJywgJ19jaHVua1NpemUnLCAnX2NodW5rQ291bnQnLCAnX2RpbVZhbHVlR2V0dGVyJywgJ19jb3VudCcsICdfcmF3Q291bnQnLCAnX25hbWVEaW1JZHgnLCAnX2lkRGltSWR4J107CnZhciBDTE9ORV9QUk9QRVJUSUVTID0gWydfZXh0ZW50JywgJ19hcHByb3hpbWF0ZUV4dGVudCcsICdfcmF3RXh0ZW50J107CgpmdW5jdGlvbiB0cmFuc2ZlclByb3BlcnRpZXModGFyZ2V0LCBzb3VyY2UpIHsKICB6clV0aWwuZWFjaChUUkFOU0ZFUkFCTEVfUFJPUEVSVElFUy5jb25jYXQoc291cmNlLl9fd3JhcHBlZE1ldGhvZHMgfHwgW10pLCBmdW5jdGlvbiAocHJvcE5hbWUpIHsKICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7CiAgICAgIHRhcmdldFtwcm9wTmFtZV0gPSBzb3VyY2VbcHJvcE5hbWVdOwogICAgfQogIH0pOwogIHRhcmdldC5fX3dyYXBwZWRNZXRob2RzID0gc291cmNlLl9fd3JhcHBlZE1ldGhvZHM7CiAgenJVdGlsLmVhY2goQ0xPTkVfUFJPUEVSVElFUywgZnVuY3Rpb24gKHByb3BOYW1lKSB7CiAgICB0YXJnZXRbcHJvcE5hbWVdID0genJVdGlsLmNsb25lKHNvdXJjZVtwcm9wTmFtZV0pOwogIH0pOwogIHRhcmdldC5fY2FsY3VsYXRpb25JbmZvID0genJVdGlsLmV4dGVuZChzb3VyY2UuX2NhbGN1bGF0aW9uSW5mbyk7Cn0KLyoqCiAqIEBjb25zdHJ1Y3RvcgogKiBAYWxpYXMgbW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0CiAqCiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZ3xPYmplY3R8bW9kdWxlOmRhdGEvRGF0YURpbWVuc2lvbkluZm8+fSBkaW1lbnNpb25zCiAqICAgICAgRm9yIGV4YW1wbGUsIFsnc29tZURpbU5hbWUnLCB7bmFtZTogJ3NvbWVEaW1OYW1lJywgdHlwZTogJ3NvbWVEaW1UeXBlJ30sIC4uLl0uCiAqICAgICAgRGltZW5zaW9ucyBzaG91bGQgYmUgY29uY3JldGUgbmFtZXMgbGlrZSB4LCB5LCB6LCBsbmcsIGxhdCwgYW5nbGUsIHJhZGl1cwogKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBob3N0TW9kZWwKICovCgoKdmFyIExpc3QgPSBmdW5jdGlvbiBMaXN0KGRpbWVuc2lvbnMsIGhvc3RNb2RlbCkgewogIGRpbWVuc2lvbnMgPSBkaW1lbnNpb25zIHx8IFsneCcsICd5J107CiAgdmFyIGRpbWVuc2lvbkluZm9zID0ge307CiAgdmFyIGRpbWVuc2lvbk5hbWVzID0gW107CiAgdmFyIGludmVydGVkSW5kaWNlc01hcCA9IHt9OwoKICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbWVuc2lvbnMubGVuZ3RoOyBpKyspIHsKICAgIC8vIFVzZSB0aGUgb3JpZ2luYWwgZGltZW5zaW9uc1tpXSwgd2hlcmUgb3RoZXIgZmxhZyBwcm9wcyBtYXkgZXhpc3RzLgogICAgdmFyIGRpbWVuc2lvbkluZm8gPSBkaW1lbnNpb25zW2ldOwoKICAgIGlmICh6clV0aWwuaXNTdHJpbmcoZGltZW5zaW9uSW5mbykpIHsKICAgICAgZGltZW5zaW9uSW5mbyA9IG5ldyBEYXRhRGltZW5zaW9uSW5mbyh7CiAgICAgICAgbmFtZTogZGltZW5zaW9uSW5mbwogICAgICB9KTsKICAgIH0gZWxzZSBpZiAoIShkaW1lbnNpb25JbmZvIGluc3RhbmNlb2YgRGF0YURpbWVuc2lvbkluZm8pKSB7CiAgICAgIGRpbWVuc2lvbkluZm8gPSBuZXcgRGF0YURpbWVuc2lvbkluZm8oZGltZW5zaW9uSW5mbyk7CiAgICB9CgogICAgdmFyIGRpbWVuc2lvbk5hbWUgPSBkaW1lbnNpb25JbmZvLm5hbWU7CiAgICBkaW1lbnNpb25JbmZvLnR5cGUgPSBkaW1lbnNpb25JbmZvLnR5cGUgfHwgJ2Zsb2F0JzsKCiAgICBpZiAoIWRpbWVuc2lvbkluZm8uY29vcmREaW0pIHsKICAgICAgZGltZW5zaW9uSW5mby5jb29yZERpbSA9IGRpbWVuc2lvbk5hbWU7CiAgICAgIGRpbWVuc2lvbkluZm8uY29vcmREaW1JbmRleCA9IDA7CiAgICB9CgogICAgZGltZW5zaW9uSW5mby5vdGhlckRpbXMgPSBkaW1lbnNpb25JbmZvLm90aGVyRGltcyB8fCB7fTsKICAgIGRpbWVuc2lvbk5hbWVzLnB1c2goZGltZW5zaW9uTmFtZSk7CiAgICBkaW1lbnNpb25JbmZvc1tkaW1lbnNpb25OYW1lXSA9IGRpbWVuc2lvbkluZm87CiAgICBkaW1lbnNpb25JbmZvLmluZGV4ID0gaTsKCiAgICBpZiAoZGltZW5zaW9uSW5mby5jcmVhdGVJbnZlcnRlZEluZGljZXMpIHsKICAgICAgaW52ZXJ0ZWRJbmRpY2VzTWFwW2RpbWVuc2lvbk5hbWVdID0gW107CiAgICB9CiAgfQogIC8qKgogICAqIEByZWFkT25seQogICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn0KICAgKi8KCgogIHRoaXMuZGltZW5zaW9ucyA9IGRpbWVuc2lvbk5hbWVzOwogIC8qKgogICAqIEluZm9tYXRpb24gb2YgZWFjaCBkYXRhIGRpbWVuc2lvbiwgbGlrZSBkYXRhIHR5cGUuCiAgICogQHR5cGUge09iamVjdH0KICAgKi8KCiAgdGhpcy5fZGltZW5zaW9uSW5mb3MgPSBkaW1lbnNpb25JbmZvczsKICAvKioKICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9CiAgICovCgogIHRoaXMuaG9zdE1vZGVsID0gaG9zdE1vZGVsOwogIC8qKgogICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0KICAgKi8KCiAgdGhpcy5kYXRhVHlwZTsKICAvKioKICAgKiBJbmRpY2VzIHN0b3JlcyB0aGUgaW5kaWNlcyBvZiBkYXRhIHN1YnNldCBhZnRlciBmaWx0ZXJlZC4KICAgKiBUaGlzIGRhdGEgc3Vic2V0IHdpbGwgYmUgdXNlZCBpbiBjaGFydC4KICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59CiAgICogQHJlYWRPbmx5CiAgICovCgogIHRoaXMuX2luZGljZXMgPSBudWxsOwogIHRoaXMuX2NvdW50ID0gMDsKICB0aGlzLl9yYXdDb3VudCA9IDA7CiAgLyoqCiAgICogRGF0YSBzdG9yYWdlCiAgICogQHR5cGUge09iamVjdC48a2V5LCBBcnJheS48VHlwZWRBcnJheXxBcnJheT4+fQogICAqIEBwcml2YXRlCiAgICovCgogIHRoaXMuX3N0b3JhZ2UgPSB7fTsKICAvKioKICAgKiBAdHlwZSB7QXJyYXkuPHN0cmluZz59CiAgICovCgogIHRoaXMuX25hbWVMaXN0ID0gW107CiAgLyoqCiAgICogQHR5cGUge0FycmF5LjxzdHJpbmc+fQogICAqLwoKICB0aGlzLl9pZExpc3QgPSBbXTsKICAvKioKICAgKiBNb2RlbHMgb2YgZGF0YSBvcHRpb24gaXMgc3RvcmVkIHNwYXJzZSBmb3Igb3B0aW1pemluZyBtZW1vcnkgY29zdAogICAqIEB0eXBlIHtBcnJheS48bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWw+fQogICAqIEBwcml2YXRlCiAgICovCgogIHRoaXMuX29wdGlvbk1vZGVscyA9IFtdOwogIC8qKgogICAqIEdsb2JhbCB2aXN1YWwgcHJvcGVydGllcyBhZnRlciB2aXN1YWwgY29kaW5nCiAgICogQHR5cGUge09iamVjdH0KICAgKiBAcHJpdmF0ZQogICAqLwoKICB0aGlzLl92aXN1YWwgPSB7fTsKICAvKioKICAgKiBHbG9iZWwgbGF5b3V0IHByb3BlcnRpZXMuCiAgICogQHR5cGUge09iamVjdH0KICAgKiBAcHJpdmF0ZQogICAqLwoKICB0aGlzLl9sYXlvdXQgPSB7fTsKICAvKioKICAgKiBJdGVtIHZpc3VhbCBwcm9wZXJ0aWVzIGFmdGVyIHZpc3VhbCBjb2RpbmcKICAgKiBAdHlwZSB7QXJyYXkuPE9iamVjdD59CiAgICogQHByaXZhdGUKICAgKi8KCiAgdGhpcy5faXRlbVZpc3VhbHMgPSBbXTsKICAvKioKICAgKiBLZXk6IHZpc3VhbCB0eXBlLCBWYWx1ZTogYm9vbGVhbgogICAqIEB0eXBlIHtPYmplY3R9CiAgICogQHJlYWRPbmx5CiAgICovCgogIHRoaXMuaGFzSXRlbVZpc3VhbCA9IHt9OwogIC8qKgogICAqIEl0ZW0gbGF5b3V0IHByb3BlcnRpZXMgYWZ0ZXIgbGF5b3V0CiAgICogQHR5cGUge0FycmF5LjxPYmplY3Q+fQogICAqIEBwcml2YXRlCiAgICovCgogIHRoaXMuX2l0ZW1MYXlvdXRzID0gW107CiAgLyoqCiAgICogR3JhcGhpYyBlbGVtbmVudHMKICAgKiBAdHlwZSB7QXJyYXkuPG1vZHVsZTp6cmVuZGVyL0VsZW1lbnQ+fQogICAqIEBwcml2YXRlCiAgICovCgogIHRoaXMuX2dyYXBoaWNFbHMgPSBbXTsKICAvKioKICAgKiBNYXggc2l6ZSBvZiBlYWNoIGNodW5rLgogICAqIEB0eXBlIHtudW1iZXJ9CiAgICogQHByaXZhdGUKICAgKi8KCiAgdGhpcy5fY2h1bmtTaXplID0gMWU1OwogIC8qKgogICAqIEB0eXBlIHtudW1iZXJ9CiAgICogQHByaXZhdGUKICAgKi8KCiAgdGhpcy5fY2h1bmtDb3VudCA9IDA7CiAgLyoqCiAgICogQHR5cGUge0FycmF5LjxBcnJheXxPYmplY3Q+fQogICAqIEBwcml2YXRlCiAgICovCgogIHRoaXMuX3Jhd0RhdGE7CiAgLyoqCiAgICogUmF3IGV4dGVudCB3aWxsIG5vdCBiZSBjbG9uZWQsIGJ1dCBvbmx5IHRyYW5zZmVyZWQuCiAgICogSXQgd2lsbCBub3QgYmUgY2FsY3VsYXRlZCB1dGlsIG5lZWRlZC4KICAgKiBrZXk6IGRpbSwKICAgKiB2YWx1ZToge2VuZDogbnVtYmVyLCBleHRlbnQ6IEFycmF5LjxudW1iZXI+fQogICAqIEB0eXBlIHtPYmplY3R9CiAgICogQHByaXZhdGUKICAgKi8KCiAgdGhpcy5fcmF3RXh0ZW50ID0ge307CiAgLyoqCiAgICogQHR5cGUge09iamVjdH0KICAgKiBAcHJpdmF0ZQogICAqLwoKICB0aGlzLl9leHRlbnQgPSB7fTsKICAvKioKICAgKiBrZXk6IGRpbQogICAqIHZhbHVlOiBleHRlbnQKICAgKiBAdHlwZSB7T2JqZWN0fQogICAqIEBwcml2YXRlCiAgICovCgogIHRoaXMuX2FwcHJveGltYXRlRXh0ZW50ID0ge307CiAgLyoqCiAgICogQ2FjaGUgc3VtbWFyeSBpbmZvIGZvciBmYXN0IHZpc2l0LiBTZWUgImRpbWVuc2lvbkhlbHBlciIuCiAgICogQHR5cGUge09iamVjdH0KICAgKiBAcHJpdmF0ZQogICAqLwoKICB0aGlzLl9kaW1lbnNpb25zU3VtbWFyeSA9IHN1bW1hcml6ZURpbWVuc2lvbnModGhpcyk7CiAgLyoqCiAgICogQHR5cGUge09iamVjdC48QXJyYXl8VHlwZWRBcnJheT59CiAgICogQHByaXZhdGUKICAgKi8KCiAgdGhpcy5faW52ZXJ0ZWRJbmRpY2VzTWFwID0gaW52ZXJ0ZWRJbmRpY2VzTWFwOwogIC8qKgogICAqIEB0eXBlIHtPYmplY3R9CiAgICogQHByaXZhdGUKICAgKi8KCiAgdGhpcy5fY2FsY3VsYXRpb25JbmZvID0ge307CiAgLyoqCiAgICogVXNlciBvdXRwdXQgaW5mbyBvZiB0aGlzIGRhdGEuCiAgICogRE8gTk9UIHVzZSBpdCBpbiBvdGhlciBwbGFjZXMhCiAgICoKICAgKiBXaGVuIHByZXBhcmluZyB1c2VyIHBhcmFtcyBmb3IgdXNlciBjYWxsYmFja3MsIHdlIGhhdmUKICAgKiB0byBjbG9uZSB0aGVzZSBpbm5lciBkYXRhIHN0cnVjdHVyZXMgdG8gcHJldmVudCB1c2VycwogICAqIGZyb20gbW9kaWZ5aW5nIHRoZW0gdG8gZWZmZWN0IGJ1aWx0LWluIGxvZ2ljLiBBbmQgZm9yCiAgICogcGVyZm9ybWFuY2UgY29uc2lkZXJhdGlvbiB3ZSBtYWtlIHRoaXMgYHVzZXJPdXRwdXRgIHRvCiAgICogYXZvaWQgY2xvbmUgdGhlbSB0b28gbWFueSB0aW1lcy4KICAgKgogICAqIEB0eXBlIHtPYmplY3R9CiAgICogQHJlYWRPbmx5CiAgICovCgogIHRoaXMudXNlck91dHB1dCA9IHRoaXMuX2RpbWVuc2lvbnNTdW1tYXJ5LnVzZXJPdXRwdXQ7Cn07Cgp2YXIgbGlzdFByb3RvID0gTGlzdC5wcm90b3R5cGU7Cmxpc3RQcm90by50eXBlID0gJ2xpc3QnOwovKioKICogSWYgZWFjaCBkYXRhIGl0ZW0gaGFzIGl0J3Mgb3duIG9wdGlvbgogKiBAdHlwZSB7Ym9vbGVhbn0KICovCgpsaXN0UHJvdG8uaGFzSXRlbU9wdGlvbiA9IHRydWU7Ci8qKgogKiBUaGUgbWVhbmluZ3Mgb2YgdGhlIGlucHV0IHBhcmFtZXRlciBgZGltYDoKICoKICogKyBJZiBkaW0gaXMgYSBudW1iZXIgKGUuZy4sIGAxYCksIGl0IG1lYW5zIHRoZSBpbmRleCBvZiB0aGUgZGltZW5zaW9uLgogKiAgIEZvciBleGFtcGxlLCBgZ2V0RGltZW5zaW9uKDApYCB3aWxsIHJldHVybiAneCcgb3IgJ2xuZycgb3IgJ3JhZGl1cycuCiAqICsgSWYgZGltIGlzIGEgbnVtYmVyLWxpa2Ugc3RyaW5nIChlLmcuLCBgIjEiYCk6CiAqICAgICArIElmIHRoZXJlIGlzIHRoZSBzYW1lIGNvbmNyZXRlIGRpbSBuYW1lIGRlZmluZWQgaW4gYHRoaXMuZGltZW5zaW9uc2AsIGl0IG1lYW5zIHRoYXQgY29uY3JldGUgbmFtZS4KICogICAgICsgSWYgbm90LCBpdCB3aWxsIGJlIGNvbnZlcnRlZCB0byBhIG51bWJlciwgd2hpY2ggbWVhbnMgdGhlIGluZGV4IG9mIHRoZSBkaW1lbnNpb24uCiAqICAgICAgICAod2h5PyBiZWNhdXNlIG9mIHRoZSBiYWNrd2FyZCBjb21wYXRiaWxpdHkuIFdlIGhhdmUgYmVlbiB0b2xlcmF0aW5nIG51bWJlci1saWtlIHN0cmluZyBpbgogKiAgICAgICAgZGltZW5zaW9uIHNldHRpbmcsIGFsdGhvdWdoIG5vdyBpdCBzZWVtcyB0aGF0IGl0IGlzIG5vdCBhIGdvb2QgaWRlYS4pCiAqICAgICBGb3IgZXhhbXBsZSwgYHZpc3VhbE1hcFtpXS5kaW1lbnNpb246ICIxImAgaXMgdGhlIHNhbWUgbWVhbmluZyBhcyBgdmlzdWFsTWFwW2ldLmRpbWVuc2lvbjogMWAsCiAqICAgICBpZiBubyBkaW1lbnNpb24gbmFtZSBpcyBkZWZpbmVkIGFzIGAiMSJgLgogKiArIElmIGRpbSBpcyBhIG5vdC1udW1iZXItbGlrZSBzdHJpbmcsIGl0IG1lYW5zIHRoZSBjb25jcmV0ZSBkaW0gbmFtZS4KICogICBGb3IgZXhhbXBsZSwgaXQgY2FuIGJlIGJlIGRlZmF1bHQgbmFtZSBgIngiYCwgYCJ5ImAsIGAieiJgLCBgImxuZyJgLCBgImxhdCJgLCBgImFuZ2xlImAsIGAicmFkaXVzImAsCiAqICAgb3IgY3VzdG9taXplZCBpbiBgZGltZW5zaW9uc2AgcHJvcGVydHkgb2Ygb3B0aW9uIGxpa2UgYCJhZ2UiYC4KICoKICogR2V0IGRpbWVuc2lvbiBuYW1lCiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gZGltIFNlZSBhYm92ZS4KICogQHJldHVybiB7c3RyaW5nfSBDb25jcmV0ZSBkaW0gbmFtZS4KICovCgpsaXN0UHJvdG8uZ2V0RGltZW5zaW9uID0gZnVuY3Rpb24gKGRpbSkgewogIGlmICh0eXBlb2YgZGltID09PSAnbnVtYmVyJyAvLyBJZiBiZWluZyBhIG51bWJlci1saWtlIHN0cmluZyBidXQgbm90IGJlaW5nIGRlZmluZWQgYSBkaW1lbnNpb24gbmFtZS4KICB8fCAhaXNOYU4oZGltKSAmJiAhdGhpcy5fZGltZW5zaW9uSW5mb3MuaGFzT3duUHJvcGVydHkoZGltKSkgewogICAgZGltID0gdGhpcy5kaW1lbnNpb25zW2RpbV07CiAgfQoKICByZXR1cm4gZGltOwp9OwovKioKICogR2V0IHR5cGUgYW5kIGNhbGN1bGF0aW9uIGluZm8gb2YgcGFydGljdWxhciBkaW1lbnNpb24KICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBkaW0KICogICAgICAgIERpbWVuc2lvbiBjYW4gYmUgY29uY3JldGUgbmFtZXMgbGlrZSB4LCB5LCB6LCBsbmcsIGxhdCwgYW5nbGUsIHJhZGl1cwogKiAgICAgICAgT3IgYSBvcmRpbmFsIG51bWJlci4gRm9yIGV4YW1wbGUgZ2V0RGltZW5zaW9uSW5mbygwKSB3aWxsIHJldHVybiAneCcgb3IgJ2xuZycgb3IgJ3JhZGl1cycKICovCgoKbGlzdFByb3RvLmdldERpbWVuc2lvbkluZm8gPSBmdW5jdGlvbiAoZGltKSB7CiAgLy8gRG8gbm90IGNsb25lLCBiZWNhdXNlIHRoZXJlIG1heSBiZSBjYXRlZ29yaWVzIGluIGRpbUluZm8uCiAgcmV0dXJuIHRoaXMuX2RpbWVuc2lvbkluZm9zW3RoaXMuZ2V0RGltZW5zaW9uKGRpbSldOwp9OwovKioKICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59IGNvbmNyZXRlIGRpbWVuc2lvbiBuYW1lIGxpc3Qgb24gY29vcmQuCiAqLwoKCmxpc3RQcm90by5nZXREaW1lbnNpb25zT25Db29yZCA9IGZ1bmN0aW9uICgpIHsKICByZXR1cm4gdGhpcy5fZGltZW5zaW9uc1N1bW1hcnkuZGF0YURpbXNPbkNvb3JkLnNsaWNlKCk7Cn07Ci8qKgogKiBAcGFyYW0ge3N0cmluZ30gY29vcmREaW0KICogQHBhcmFtIHtudW1iZXJ9IFtpZHhdIEEgY29vcmREaW0gbWF5IG1hcCB0byBtb3JlIHRoYW4gb25lIGRhdGEgZGltLgogKiAgICAgICAgSWYgaWR4IGlzIGB0cnVlYCwgcmV0dXJuIGEgYXJyYXkgb2YgYWxsIG1hcHBlZCBkaW1zLgogKiAgICAgICAgSWYgaWR4IGlzIG5vdCBzcGVjaWZpZWQsIHJldHVybiB0aGUgZmlyc3QgZGltIG5vdCBleHRyYS4KICogQHJldHVybiB7c3RyaW5nfEFycmF5LjxzdHJpbmc+fSBjb25jcmV0ZSBkYXRhIGRpbS4KICogICAgICAgIElmIGlkeCBpcyBudW1iZXIsIGFuZCBub3QgZm91bmQsIHJldHVybiBudWxsL3VuZGVmaW5lZC4KICogICAgICAgIElmIGlkeCBpcyBgdHJ1ZWAsIGFuZCBub3QgZm91bmQsIHJldHVybiBlbXB0eSBhcnJheSAoYWx3YXlzIHJldHVybiBhcnJheSkuCiAqLwoKCmxpc3RQcm90by5tYXBEaW1lbnNpb24gPSBmdW5jdGlvbiAoY29vcmREaW0sIGlkeCkgewogIHZhciBkaW1lbnNpb25zU3VtbWFyeSA9IHRoaXMuX2RpbWVuc2lvbnNTdW1tYXJ5OwoKICBpZiAoaWR4ID09IG51bGwpIHsKICAgIHJldHVybiBkaW1lbnNpb25zU3VtbWFyeS5lbmNvZGVGaXJzdERpbU5vdEV4dHJhW2Nvb3JkRGltXTsKICB9CgogIHZhciBkaW1zID0gZGltZW5zaW9uc1N1bW1hcnkuZW5jb2RlW2Nvb3JkRGltXTsKICByZXR1cm4gaWR4ID09PSB0cnVlIC8vIGFsd2F5cyByZXR1cm4gYXJyYXkgaWYgaWR4IGlzIGB0cnVlYAogID8gKGRpbXMgfHwgW10pLnNsaWNlKCkgOiBkaW1zICYmIGRpbXNbaWR4XTsKfTsKLyoqCiAqIEluaXRpYWxpemUgZnJvbSBkYXRhCiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdHxudW1iZXJ8QXJyYXk+fSBkYXRhIHNvdXJjZSBvciBkYXRhIG9yIGRhdGEgcHJvdmlkZXIuCiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IFtuYW1lTElzdF0gVGhlIG5hbWUgb2YgYSBkYXR1bSBpcyB1c2VkIG9uIGRhdGEgZGlmZiBhbmQKICogICAgICAgIGRlZmF1bHQgbGFiZWwvdG9vbHRpcC4KICogICAgICAgIEEgbmFtZSBjYW4gYmUgc3BlY2lmaWVkIGluIGVuY29kZS5pdGVtTmFtZSwKICogICAgICAgIG9yIGRhdGFJdGVtLm5hbWUgKG9ubHkgZm9yIHNlcmllcyBvcHRpb24gZGF0YSksCiAqICAgICAgICBvciBwcm92aWRlZCBpbiBuYW1lTGlzdCBmcm9tIG91dHNpZGUuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtkaW1WYWx1ZUdldHRlcl0gKGRhdGFJdGVtLCBkaW1OYW1lLCBkYXRhSW5kZXgsIGRpbUluZGV4KSA9PiBudW1iZXIKICovCgoKbGlzdFByb3RvLmluaXREYXRhID0gZnVuY3Rpb24gKGRhdGEsIG5hbWVMaXN0LCBkaW1WYWx1ZUdldHRlcikgewogIHZhciBub3RQcm92aWRlciA9IFNvdXJjZS5pc0luc3RhbmNlKGRhdGEpIHx8IHpyVXRpbC5pc0FycmF5TGlrZShkYXRhKTsKCiAgaWYgKG5vdFByb3ZpZGVyKSB7CiAgICBkYXRhID0gbmV3IERlZmF1bHREYXRhUHJvdmlkZXIoZGF0YSwgdGhpcy5kaW1lbnNpb25zLmxlbmd0aCk7CiAgfQoKICB0aGlzLl9yYXdEYXRhID0gZGF0YTsgLy8gQ2xlYXIKCiAgdGhpcy5fc3RvcmFnZSA9IHt9OwogIHRoaXMuX2luZGljZXMgPSBudWxsOwogIHRoaXMuX25hbWVMaXN0ID0gbmFtZUxpc3QgfHwgW107CiAgdGhpcy5faWRMaXN0ID0gW107CiAgdGhpcy5fbmFtZVJlcGVhdENvdW50ID0ge307CgogIGlmICghZGltVmFsdWVHZXR0ZXIpIHsKICAgIHRoaXMuaGFzSXRlbU9wdGlvbiA9IGZhbHNlOwogIH0KICAvKioKICAgKiBAcmVhZE9ubHkKICAgKi8KCgogIHRoaXMuZGVmYXVsdERpbVZhbHVlR2V0dGVyID0gZGVmYXVsdERpbVZhbHVlR2V0dGVyc1t0aGlzLl9yYXdEYXRhLmdldFNvdXJjZSgpLnNvdXJjZUZvcm1hdF07IC8vIERlZmF1bHQgZGltIHZhbHVlIGdldHRlcgoKICB0aGlzLl9kaW1WYWx1ZUdldHRlciA9IGRpbVZhbHVlR2V0dGVyID0gZGltVmFsdWVHZXR0ZXIgfHwgdGhpcy5kZWZhdWx0RGltVmFsdWVHZXR0ZXI7CiAgdGhpcy5fZGltVmFsdWVHZXR0ZXJBcnJheVJvd3MgPSBkZWZhdWx0RGltVmFsdWVHZXR0ZXJzLmFycmF5Um93czsgLy8gUmVzZXQgcmF3IGV4dGVudC4KCiAgdGhpcy5fcmF3RXh0ZW50ID0ge307CgogIHRoaXMuX2luaXREYXRhRnJvbVByb3ZpZGVyKDAsIGRhdGEuY291bnQoKSk7IC8vIElmIGRhdGEgaGFzIG5vIGl0ZW0gb3B0aW9uLgoKCiAgaWYgKGRhdGEucHVyZSkgewogICAgdGhpcy5oYXNJdGVtT3B0aW9uID0gZmFsc2U7CiAgfQp9OwoKbGlzdFByb3RvLmdldFByb3ZpZGVyID0gZnVuY3Rpb24gKCkgewogIHJldHVybiB0aGlzLl9yYXdEYXRhOwp9OwovKioKICogQ2F1dGlvbjogQ2FuIGJlIG9ubHkgY2FsbGVkIG9uIHJhdyBkYXRhIChiZWZvcmUgYHRoaXMuX2luZGljZXNgIGNyZWF0ZWQpLgogKi8KCgpsaXN0UHJvdG8uYXBwZW5kRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7CiAgdmFyIHJhd0RhdGEgPSB0aGlzLl9yYXdEYXRhOwogIHZhciBzdGFydCA9IHRoaXMuY291bnQoKTsKICByYXdEYXRhLmFwcGVuZERhdGEoZGF0YSk7CiAgdmFyIGVuZCA9IHJhd0RhdGEuY291bnQoKTsKCiAgaWYgKCFyYXdEYXRhLnBlcnNpc3RlbnQpIHsKICAgIGVuZCArPSBzdGFydDsKICB9CgogIHRoaXMuX2luaXREYXRhRnJvbVByb3ZpZGVyKHN0YXJ0LCBlbmQpOwp9OwovKioKICogQ2F1dGlvbjogQ2FuIGJlIG9ubHkgY2FsbGVkIG9uIHJhdyBkYXRhIChiZWZvcmUgYHRoaXMuX2luZGljZXNgIGNyZWF0ZWQpLgogKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCBtb2RpZnkgYHJhd0RhdGFgIChgZGF0YVByb3ZpZGVyYCksIGJ1dCBvbmx5CiAqIGFkZCB2YWx1ZXMgdG8gc3RvcmFnZS4KICoKICogVGhlIGZpbmFsIGNvdW50IHdpbGwgYmUgaW5jcmVhc2VkIGJ5IGBNYXRoLm1heCh2YWx1ZXMubGVuZ3RoLCBuYW1lcy5sZW5ndGgpYC4KICoKICogQHBhcmFtIHtBcnJheS48QXJyYXkuPCo+Pn0gdmFsdWVzIFRoYXQgaXMgdGhlIFNvdXJjZVR5cGU6ICdhcnJheVJvd3MnLCBsaWtlCiAqICAgICAgICBbCiAqICAgICAgICAgICAgWzEyLCAzMywgNDRdLAogKiAgICAgICAgICAgIFtOYU4sIDQzLCAxXSwKICogICAgICAgICAgICBbJy0nLCAnYXNkZicsIDBdCiAqICAgICAgICBdCiAqICAgICAgICBFYWNoIGl0ZW0gaXMgZXhhY2x0eSBjb29yZXNwb25kaW5nIHRvIGEgZGltZW5zaW9uLgogKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBbbmFtZXNdCiAqLwoKCmxpc3RQcm90by5hcHBlbmRWYWx1ZXMgPSBmdW5jdGlvbiAodmFsdWVzLCBuYW1lcykgewogIHZhciBjaHVua1NpemUgPSB0aGlzLl9jaHVua1NpemU7CiAgdmFyIHN0b3JhZ2UgPSB0aGlzLl9zdG9yYWdlOwogIHZhciBkaW1lbnNpb25zID0gdGhpcy5kaW1lbnNpb25zOwogIHZhciBkaW1MZW4gPSBkaW1lbnNpb25zLmxlbmd0aDsKICB2YXIgcmF3RXh0ZW50ID0gdGhpcy5fcmF3RXh0ZW50OwogIHZhciBzdGFydCA9IHRoaXMuY291bnQoKTsKICB2YXIgZW5kID0gc3RhcnQgKyBNYXRoLm1heCh2YWx1ZXMubGVuZ3RoLCBuYW1lcyA/IG5hbWVzLmxlbmd0aCA6IDApOwogIHZhciBvcmlnaW5hbENodW5rQ291bnQgPSB0aGlzLl9jaHVua0NvdW50OwoKICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbUxlbjsgaSsrKSB7CiAgICB2YXIgZGltID0gZGltZW5zaW9uc1tpXTsKCiAgICBpZiAoIXJhd0V4dGVudFtkaW1dKSB7CiAgICAgIHJhd0V4dGVudFtkaW1dID0gZ2V0SW5pdGlhbEV4dGVudCgpOwogICAgfQoKICAgIGlmICghc3RvcmFnZVtkaW1dKSB7CiAgICAgIHN0b3JhZ2VbZGltXSA9IFtdOwogICAgfQoKICAgIHByZXBhcmVDaHVua3Moc3RvcmFnZSwgdGhpcy5fZGltZW5zaW9uSW5mb3NbZGltXSwgY2h1bmtTaXplLCBvcmlnaW5hbENodW5rQ291bnQsIGVuZCk7CiAgICB0aGlzLl9jaHVua0NvdW50ID0gc3RvcmFnZVtkaW1dLmxlbmd0aDsKICB9CgogIHZhciBlbXB0eURhdGFJdGVtID0gbmV3IEFycmF5KGRpbUxlbik7CgogIGZvciAodmFyIGlkeCA9IHN0YXJ0OyBpZHggPCBlbmQ7IGlkeCsrKSB7CiAgICB2YXIgc291cmNlSWR4ID0gaWR4IC0gc3RhcnQ7CiAgICB2YXIgY2h1bmtJbmRleCA9IE1hdGguZmxvb3IoaWR4IC8gY2h1bmtTaXplKTsKICAgIHZhciBjaHVua09mZnNldCA9IGlkeCAlIGNodW5rU2l6ZTsgLy8gU3RvcmUgdGhlIGRhdGEgYnkgZGltZW5zaW9ucwoKICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZGltTGVuOyBrKyspIHsKICAgICAgdmFyIGRpbSA9IGRpbWVuc2lvbnNba107CgogICAgICB2YXIgdmFsID0gdGhpcy5fZGltVmFsdWVHZXR0ZXJBcnJheVJvd3ModmFsdWVzW3NvdXJjZUlkeF0gfHwgZW1wdHlEYXRhSXRlbSwgZGltLCBzb3VyY2VJZHgsIGspOwoKICAgICAgc3RvcmFnZVtkaW1dW2NodW5rSW5kZXhdW2NodW5rT2Zmc2V0XSA9IHZhbDsKICAgICAgdmFyIGRpbVJhd0V4dGVudCA9IHJhd0V4dGVudFtkaW1dOwogICAgICB2YWwgPCBkaW1SYXdFeHRlbnRbMF0gJiYgKGRpbVJhd0V4dGVudFswXSA9IHZhbCk7CiAgICAgIHZhbCA+IGRpbVJhd0V4dGVudFsxXSAmJiAoZGltUmF3RXh0ZW50WzFdID0gdmFsKTsKICAgIH0KCiAgICBpZiAobmFtZXMpIHsKICAgICAgdGhpcy5fbmFtZUxpc3RbaWR4XSA9IG5hbWVzW3NvdXJjZUlkeF07CiAgICB9CiAgfQoKICB0aGlzLl9yYXdDb3VudCA9IHRoaXMuX2NvdW50ID0gZW5kOyAvLyBSZXNldCBkYXRhIGV4dGVudAoKICB0aGlzLl9leHRlbnQgPSB7fTsKICBwcmVwYXJlSW52ZXJ0ZWRJbmRleCh0aGlzKTsKfTsKCmxpc3RQcm90by5faW5pdERhdGFGcm9tUHJvdmlkZXIgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkgewogIC8vIE9wdGltaXplLgogIGlmIChzdGFydCA+PSBlbmQpIHsKICAgIHJldHVybjsKICB9CgogIHZhciBjaHVua1NpemUgPSB0aGlzLl9jaHVua1NpemU7CiAgdmFyIHJhd0RhdGEgPSB0aGlzLl9yYXdEYXRhOwogIHZhciBzdG9yYWdlID0gdGhpcy5fc3RvcmFnZTsKICB2YXIgZGltZW5zaW9ucyA9IHRoaXMuZGltZW5zaW9uczsKICB2YXIgZGltTGVuID0gZGltZW5zaW9ucy5sZW5ndGg7CiAgdmFyIGRpbWVuc2lvbkluZm9NYXAgPSB0aGlzLl9kaW1lbnNpb25JbmZvczsKICB2YXIgbmFtZUxpc3QgPSB0aGlzLl9uYW1lTGlzdDsKICB2YXIgaWRMaXN0ID0gdGhpcy5faWRMaXN0OwogIHZhciByYXdFeHRlbnQgPSB0aGlzLl9yYXdFeHRlbnQ7CiAgdmFyIG5hbWVSZXBlYXRDb3VudCA9IHRoaXMuX25hbWVSZXBlYXRDb3VudCA9IHt9OwogIHZhciBuYW1lRGltSWR4OwogIHZhciBvcmlnaW5hbENodW5rQ291bnQgPSB0aGlzLl9jaHVua0NvdW50OwoKICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbUxlbjsgaSsrKSB7CiAgICB2YXIgZGltID0gZGltZW5zaW9uc1tpXTsKCiAgICBpZiAoIXJhd0V4dGVudFtkaW1dKSB7CiAgICAgIHJhd0V4dGVudFtkaW1dID0gZ2V0SW5pdGlhbEV4dGVudCgpOwogICAgfQoKICAgIHZhciBkaW1JbmZvID0gZGltZW5zaW9uSW5mb01hcFtkaW1dOwoKICAgIGlmIChkaW1JbmZvLm90aGVyRGltcy5pdGVtTmFtZSA9PT0gMCkgewogICAgICBuYW1lRGltSWR4ID0gdGhpcy5fbmFtZURpbUlkeCA9IGk7CiAgICB9CgogICAgaWYgKGRpbUluZm8ub3RoZXJEaW1zLml0ZW1JZCA9PT0gMCkgewogICAgICB0aGlzLl9pZERpbUlkeCA9IGk7CiAgICB9CgogICAgaWYgKCFzdG9yYWdlW2RpbV0pIHsKICAgICAgc3RvcmFnZVtkaW1dID0gW107CiAgICB9CgogICAgcHJlcGFyZUNodW5rcyhzdG9yYWdlLCBkaW1JbmZvLCBjaHVua1NpemUsIG9yaWdpbmFsQ2h1bmtDb3VudCwgZW5kKTsKICAgIHRoaXMuX2NodW5rQ291bnQgPSBzdG9yYWdlW2RpbV0ubGVuZ3RoOwogIH0KCiAgdmFyIGRhdGFJdGVtID0gbmV3IEFycmF5KGRpbUxlbik7CgogIGZvciAodmFyIGlkeCA9IHN0YXJ0OyBpZHggPCBlbmQ7IGlkeCsrKSB7CiAgICAvLyBOT1RJQ0U6IFRyeSBub3QgdG8gd3JpdGUgdGhpbmdzIGludG8gZGF0YUl0ZW0KICAgIGRhdGFJdGVtID0gcmF3RGF0YS5nZXRJdGVtKGlkeCwgZGF0YUl0ZW0pOyAvLyBFYWNoIGRhdGEgaXRlbSBpcyB2YWx1ZQogICAgLy8gWzEsIDJdCiAgICAvLyAyCiAgICAvLyBCYXIgY2hhcnQsIGxpbmUgY2hhcnQgd2hpY2ggdXNlcyBjYXRlZ29yeSBheGlzCiAgICAvLyBvbmx5IGdpdmVzIHRoZSAneScgdmFsdWUuICd4JyB2YWx1ZSBpcyB0aGUgaW5kaWNlcyBvZiBjYXRlZ29yeQogICAgLy8gVXNlIGEgdGVtcFZhbHVlIHRvIG5vcm1hbGl6ZSB0aGUgdmFsdWUgdG8gYmUgYSAoeCwgeSkgdmFsdWUKCiAgICB2YXIgY2h1bmtJbmRleCA9IE1hdGguZmxvb3IoaWR4IC8gY2h1bmtTaXplKTsKICAgIHZhciBjaHVua09mZnNldCA9IGlkeCAlIGNodW5rU2l6ZTsgLy8gU3RvcmUgdGhlIGRhdGEgYnkgZGltZW5zaW9ucwoKICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZGltTGVuOyBrKyspIHsKICAgICAgdmFyIGRpbSA9IGRpbWVuc2lvbnNba107CiAgICAgIHZhciBkaW1TdG9yYWdlID0gc3RvcmFnZVtkaW1dW2NodW5rSW5kZXhdOyAvLyBQRU5ESU5HIE5VTEwgaXMgZW1wdHkgb3IgemVybwoKICAgICAgdmFyIHZhbCA9IHRoaXMuX2RpbVZhbHVlR2V0dGVyKGRhdGFJdGVtLCBkaW0sIGlkeCwgayk7CgogICAgICBkaW1TdG9yYWdlW2NodW5rT2Zmc2V0XSA9IHZhbDsKICAgICAgdmFyIGRpbVJhd0V4dGVudCA9IHJhd0V4dGVudFtkaW1dOwogICAgICB2YWwgPCBkaW1SYXdFeHRlbnRbMF0gJiYgKGRpbVJhd0V4dGVudFswXSA9IHZhbCk7CiAgICAgIHZhbCA+IGRpbVJhd0V4dGVudFsxXSAmJiAoZGltUmF3RXh0ZW50WzFdID0gdmFsKTsKICAgIH0gLy8gPz8/IEZJWE1FIG5vdCBjaGVjayBieSBwdXJlIGJ1dCBzb3VyY2VGb3JtYXQ/CiAgICAvLyBUT0RPIHJlZmFjdG9yIHRoZXNlIGxvZ2ljLgoKCiAgICBpZiAoIXJhd0RhdGEucHVyZSkgewogICAgICB2YXIgbmFtZSA9IG5hbWVMaXN0W2lkeF07CgogICAgICBpZiAoZGF0YUl0ZW0gJiYgbmFtZSA9PSBudWxsKSB7CiAgICAgICAgLy8gSWYgZGF0YUl0ZW0gaXMge25hbWU6IC4uLn0sIGl0IGhhcyBoaWdoZXN0IHByaW9yaXR5LgogICAgICAgIC8vIFRoYXQgaXMgYXBwcm9wcmlhdGUgZm9yIG1hbnkgY29tbW9uIGNhc2VzLgogICAgICAgIGlmIChkYXRhSXRlbS5uYW1lICE9IG51bGwpIHsKICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIG90aGVyIHBsYWNlIHRvIHBlcnNpc3RlbnQgZGF0YUl0ZW0ubmFtZSwKICAgICAgICAgIC8vIHNvIHNhdmUgaXQgdG8gbmFtZUxpc3QuCiAgICAgICAgICBuYW1lTGlzdFtpZHhdID0gbmFtZSA9IGRhdGFJdGVtLm5hbWU7CiAgICAgICAgfSBlbHNlIGlmIChuYW1lRGltSWR4ICE9IG51bGwpIHsKICAgICAgICAgIHZhciBuYW1lRGltID0gZGltZW5zaW9uc1tuYW1lRGltSWR4XTsKICAgICAgICAgIHZhciBuYW1lRGltQ2h1bmsgPSBzdG9yYWdlW25hbWVEaW1dW2NodW5rSW5kZXhdOwoKICAgICAgICAgIGlmIChuYW1lRGltQ2h1bmspIHsKICAgICAgICAgICAgbmFtZSA9IG5hbWVEaW1DaHVua1tjaHVua09mZnNldF07CiAgICAgICAgICAgIHZhciBvcmRpbmFsTWV0YSA9IGRpbWVuc2lvbkluZm9NYXBbbmFtZURpbV0ub3JkaW5hbE1ldGE7CgogICAgICAgICAgICBpZiAob3JkaW5hbE1ldGEgJiYgb3JkaW5hbE1ldGEuY2F0ZWdvcmllcy5sZW5ndGgpIHsKICAgICAgICAgICAgICBuYW1lID0gb3JkaW5hbE1ldGEuY2F0ZWdvcmllc1tuYW1lXTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSAvLyBUcnkgdXNpbmcgdGhlIGlkIGluIG9wdGlvbgogICAgICAvLyBpZCBvciBuYW1lIGlzIHVzZWQgb24gZHluYW1pY2FsIGRhdGEsIG1hcHBpbmcgb2xkIGFuZCBuZXcgaXRlbXMuCgoKICAgICAgdmFyIGlkID0gZGF0YUl0ZW0gPT0gbnVsbCA/IG51bGwgOiBkYXRhSXRlbS5pZDsKCiAgICAgIGlmIChpZCA9PSBudWxsICYmIG5hbWUgIT0gbnVsbCkgewogICAgICAgIC8vIFVzZSBuYW1lIGFzIGlkIGFuZCBhZGQgY291bnRlciB0byBhdm9pZCBzYW1lIG5hbWUKICAgICAgICBuYW1lUmVwZWF0Q291bnRbbmFtZV0gPSBuYW1lUmVwZWF0Q291bnRbbmFtZV0gfHwgMDsKICAgICAgICBpZCA9IG5hbWU7CgogICAgICAgIGlmIChuYW1lUmVwZWF0Q291bnRbbmFtZV0gPiAwKSB7CiAgICAgICAgICBpZCArPSAnX19lY19fJyArIG5hbWVSZXBlYXRDb3VudFtuYW1lXTsKICAgICAgICB9CgogICAgICAgIG5hbWVSZXBlYXRDb3VudFtuYW1lXSsrOwogICAgICB9CgogICAgICBpZCAhPSBudWxsICYmIChpZExpc3RbaWR4XSA9IGlkKTsKICAgIH0KICB9CgogIGlmICghcmF3RGF0YS5wZXJzaXN0ZW50ICYmIHJhd0RhdGEuY2xlYW4pIHsKICAgIC8vIENsZWFuIHVudXNlZCBkYXRhIGlmIGRhdGEgc291cmNlIGlzIHR5cGVkIGFycmF5LgogICAgcmF3RGF0YS5jbGVhbigpOwogIH0KCiAgdGhpcy5fcmF3Q291bnQgPSB0aGlzLl9jb3VudCA9IGVuZDsgLy8gUmVzZXQgZGF0YSBleHRlbnQKCiAgdGhpcy5fZXh0ZW50ID0ge307CiAgcHJlcGFyZUludmVydGVkSW5kZXgodGhpcyk7Cn07CgpmdW5jdGlvbiBwcmVwYXJlQ2h1bmtzKHN0b3JhZ2UsIGRpbUluZm8sIGNodW5rU2l6ZSwgY2h1bmtDb3VudCwgZW5kKSB7CiAgdmFyIERhdGFDdG9yID0gZGF0YUN0b3JzW2RpbUluZm8udHlwZV07CiAgdmFyIGxhc3RDaHVua0luZGV4ID0gY2h1bmtDb3VudCAtIDE7CiAgdmFyIGRpbSA9IGRpbUluZm8ubmFtZTsKICB2YXIgcmVzaXplQ2h1bmtBcnJheSA9IHN0b3JhZ2VbZGltXVtsYXN0Q2h1bmtJbmRleF07CgogIGlmIChyZXNpemVDaHVua0FycmF5ICYmIHJlc2l6ZUNodW5rQXJyYXkubGVuZ3RoIDwgY2h1bmtTaXplKSB7CiAgICB2YXIgbmV3U3RvcmUgPSBuZXcgRGF0YUN0b3IoTWF0aC5taW4oZW5kIC0gbGFzdENodW5rSW5kZXggKiBjaHVua1NpemUsIGNodW5rU2l6ZSkpOyAvLyBUaGUgY29zdCBvZiB0aGUgY29weSBpcyBwcm9iYWJseSBpbmNvbnNpZGVyYWJsZQogICAgLy8gd2l0aGluIHRoZSBpbml0aWFsIGNodW5rU2l6ZS4KCiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlc2l6ZUNodW5rQXJyYXkubGVuZ3RoOyBqKyspIHsKICAgICAgbmV3U3RvcmVbal0gPSByZXNpemVDaHVua0FycmF5W2pdOwogICAgfQoKICAgIHN0b3JhZ2VbZGltXVtsYXN0Q2h1bmtJbmRleF0gPSBuZXdTdG9yZTsKICB9IC8vIENyZWF0ZSBuZXcgY2h1bmtzLgoKCiAgZm9yICh2YXIgayA9IGNodW5rQ291bnQgKiBjaHVua1NpemU7IGsgPCBlbmQ7IGsgKz0gY2h1bmtTaXplKSB7CiAgICBzdG9yYWdlW2RpbV0ucHVzaChuZXcgRGF0YUN0b3IoTWF0aC5taW4oZW5kIC0gaywgY2h1bmtTaXplKSkpOwogIH0KfQoKZnVuY3Rpb24gcHJlcGFyZUludmVydGVkSW5kZXgobGlzdCkgewogIHZhciBpbnZlcnRlZEluZGljZXNNYXAgPSBsaXN0Ll9pbnZlcnRlZEluZGljZXNNYXA7CiAgenJVdGlsLmVhY2goaW52ZXJ0ZWRJbmRpY2VzTWFwLCBmdW5jdGlvbiAoaW52ZXJ0ZWRJbmRpY2VzLCBkaW0pIHsKICAgIHZhciBkaW1JbmZvID0gbGlzdC5fZGltZW5zaW9uSW5mb3NbZGltXTsgLy8gQ3VycmVudGx5LCBvbmx5IGRpbWVuc2lvbnMgdGhhdCBoYXMgb3JkaW5hbE1ldGEgY2FuIGNyZWF0ZSBpbnZlcnRlZCBpbmRpY2VzLgoKICAgIHZhciBvcmRpbmFsTWV0YSA9IGRpbUluZm8ub3JkaW5hbE1ldGE7CgogICAgaWYgKG9yZGluYWxNZXRhKSB7CiAgICAgIGludmVydGVkSW5kaWNlcyA9IGludmVydGVkSW5kaWNlc01hcFtkaW1dID0gbmV3IEN0b3JJbnQzMkFycmF5KG9yZGluYWxNZXRhLmNhdGVnb3JpZXMubGVuZ3RoKTsgLy8gVGhlIGRlZmF1bHQgdmFsdWUgb2YgVHlwZWRBcnJheSBpcyAwLiBUbyBhdm9pZCBtaXNzCiAgICAgIC8vIG1hcHBpbmcgdG8gMCwgd2Ugc2hvdWxkIHNldCBpdCBhcyBJTkRFWF9OT1RfRk9VTkQuCgogICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGludmVydGVkSW5kaWNlcy5sZW5ndGg7IGkrKykgewogICAgICAgIGludmVydGVkSW5kaWNlc1tpXSA9IElOREVYX05PVF9GT1VORDsKICAgICAgfQoKICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Ll9jb3VudDsgaSsrKSB7CiAgICAgICAgLy8gT25seSBzdXBwb3J0IHRoZSBjYXNlIHRoYXQgYWxsIHZhbHVlcyBhcmUgZGlzdGluY3QuCiAgICAgICAgaW52ZXJ0ZWRJbmRpY2VzW2xpc3QuZ2V0KGRpbSwgaSldID0gaTsKICAgICAgfQogICAgfQogIH0pOwp9CgpmdW5jdGlvbiBnZXRSYXdWYWx1ZUZyb21TdG9yZShsaXN0LCBkaW1JbmRleCwgcmF3SW5kZXgpIHsKICB2YXIgdmFsOwoKICBpZiAoZGltSW5kZXggIT0gbnVsbCkgewogICAgdmFyIGNodW5rU2l6ZSA9IGxpc3QuX2NodW5rU2l6ZTsKICAgIHZhciBjaHVua0luZGV4ID0gTWF0aC5mbG9vcihyYXdJbmRleCAvIGNodW5rU2l6ZSk7CiAgICB2YXIgY2h1bmtPZmZzZXQgPSByYXdJbmRleCAlIGNodW5rU2l6ZTsKICAgIHZhciBkaW0gPSBsaXN0LmRpbWVuc2lvbnNbZGltSW5kZXhdOwogICAgdmFyIGNodW5rID0gbGlzdC5fc3RvcmFnZVtkaW1dW2NodW5rSW5kZXhdOwoKICAgIGlmIChjaHVuaykgewogICAgICB2YWwgPSBjaHVua1tjaHVua09mZnNldF07CiAgICAgIHZhciBvcmRpbmFsTWV0YSA9IGxpc3QuX2RpbWVuc2lvbkluZm9zW2RpbV0ub3JkaW5hbE1ldGE7CgogICAgICBpZiAob3JkaW5hbE1ldGEgJiYgb3JkaW5hbE1ldGEuY2F0ZWdvcmllcy5sZW5ndGgpIHsKICAgICAgICB2YWwgPSBvcmRpbmFsTWV0YS5jYXRlZ29yaWVzW3ZhbF07CiAgICAgIH0KICAgIH0KICB9CgogIHJldHVybiB2YWw7Cn0KLyoqCiAqIEByZXR1cm4ge251bWJlcn0KICovCgoKbGlzdFByb3RvLmNvdW50ID0gZnVuY3Rpb24gKCkgewogIHJldHVybiB0aGlzLl9jb3VudDsKfTsKCmxpc3RQcm90by5nZXRJbmRpY2VzID0gZnVuY3Rpb24gKCkgewogIHZhciBuZXdJbmRpY2VzOwogIHZhciBpbmRpY2VzID0gdGhpcy5faW5kaWNlczsKCiAgaWYgKGluZGljZXMpIHsKICAgIHZhciBDdG9yID0gaW5kaWNlcy5jb25zdHJ1Y3RvcjsKICAgIHZhciB0aGlzQ291bnQgPSB0aGlzLl9jb3VudDsgLy8gYG5ldyBBcnJheShhLCBiLCBjKWAgaXMgZGlmZmVyZW50IGZyb20gYG5ldyBVaW50MzJBcnJheShhLCBiLCBjKWAuCgogICAgaWYgKEN0b3IgPT09IEFycmF5KSB7CiAgICAgIG5ld0luZGljZXMgPSBuZXcgQ3Rvcih0aGlzQ291bnQpOwoKICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzQ291bnQ7IGkrKykgewogICAgICAgIG5ld0luZGljZXNbaV0gPSBpbmRpY2VzW2ldOwogICAgICB9CiAgICB9IGVsc2UgewogICAgICBuZXdJbmRpY2VzID0gbmV3IEN0b3IoaW5kaWNlcy5idWZmZXIsIDAsIHRoaXNDb3VudCk7CiAgICB9CiAgfSBlbHNlIHsKICAgIHZhciBDdG9yID0gZ2V0SW5kaWNlc0N0b3IodGhpcyk7CiAgICB2YXIgbmV3SW5kaWNlcyA9IG5ldyBDdG9yKHRoaXMuY291bnQoKSk7CgogICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdJbmRpY2VzLmxlbmd0aDsgaSsrKSB7CiAgICAgIG5ld0luZGljZXNbaV0gPSBpOwogICAgfQogIH0KCiAgcmV0dXJuIG5ld0luZGljZXM7Cn07Ci8qKgogKiBHZXQgdmFsdWUuIFJldHVybiBOYU4gaWYgaWR4IGlzIG91dCBvZiByYW5nZS4KICogQHBhcmFtIHtzdHJpbmd9IGRpbSBEaW0gbXVzdCBiZSBjb25jcmV0ZSBuYW1lLgogKiBAcGFyYW0ge251bWJlcn0gaWR4CiAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhY2sKICogQHJldHVybiB7bnVtYmVyfQogKi8KCgpsaXN0UHJvdG8uZ2V0ID0gZnVuY3Rpb24gKGRpbSwgaWR4Ci8qLCBzdGFjayAqLwopIHsKICBpZiAoIShpZHggPj0gMCAmJiBpZHggPCB0aGlzLl9jb3VudCkpIHsKICAgIHJldHVybiBOYU47CiAgfQoKICB2YXIgc3RvcmFnZSA9IHRoaXMuX3N0b3JhZ2U7CgogIGlmICghc3RvcmFnZVtkaW1dKSB7CiAgICAvLyBUT0RPIFdhcm4gPwogICAgcmV0dXJuIE5hTjsKICB9CgogIGlkeCA9IHRoaXMuZ2V0UmF3SW5kZXgoaWR4KTsKICB2YXIgY2h1bmtJbmRleCA9IE1hdGguZmxvb3IoaWR4IC8gdGhpcy5fY2h1bmtTaXplKTsKICB2YXIgY2h1bmtPZmZzZXQgPSBpZHggJSB0aGlzLl9jaHVua1NpemU7CiAgdmFyIGNodW5rU3RvcmUgPSBzdG9yYWdlW2RpbV1bY2h1bmtJbmRleF07CiAgdmFyIHZhbHVlID0gY2h1bmtTdG9yZVtjaHVua09mZnNldF07IC8vIEZJWE1FIG9yZGluYWwgZGF0YSB0eXBlIGlzIG5vdCBzdGFja2FibGUKICAvLyBpZiAoc3RhY2spIHsKICAvLyAgICAgdmFyIGRpbWVuc2lvbkluZm8gPSB0aGlzLl9kaW1lbnNpb25JbmZvc1tkaW1dOwogIC8vICAgICBpZiAoZGltZW5zaW9uSW5mbyAmJiBkaW1lbnNpb25JbmZvLnN0YWNrYWJsZSkgewogIC8vICAgICAgICAgdmFyIHN0YWNrZWRPbiA9IHRoaXMuc3RhY2tlZE9uOwogIC8vICAgICAgICAgd2hpbGUgKHN0YWNrZWRPbikgewogIC8vICAgICAgICAgICAgIC8vIEdldCBubyBzdGFja2VkIGRhdGEgb2Ygc3RhY2tlZCBvbgogIC8vICAgICAgICAgICAgIHZhciBzdGFja2VkVmFsdWUgPSBzdGFja2VkT24uZ2V0KGRpbSwgaWR4KTsKICAvLyAgICAgICAgICAgICAvLyBDb25zaWRlcmluZyBwb3NpdGl2ZSBzdGFjaywgbmVnYXRpdmUgc3RhY2sgYW5kIGVtcHR5IGRhdGEKICAvLyAgICAgICAgICAgICBpZiAoKHZhbHVlID49IDAgJiYgc3RhY2tlZFZhbHVlID4gMCkgIC8vIFBvc2l0aXZlIHN0YWNrCiAgLy8gICAgICAgICAgICAgICAgIHx8ICh2YWx1ZSA8PSAwICYmIHN0YWNrZWRWYWx1ZSA8IDApIC8vIE5lZ2F0aXZlIHN0YWNrCiAgLy8gICAgICAgICAgICAgKSB7CiAgLy8gICAgICAgICAgICAgICAgIHZhbHVlICs9IHN0YWNrZWRWYWx1ZTsKICAvLyAgICAgICAgICAgICB9CiAgLy8gICAgICAgICAgICAgc3RhY2tlZE9uID0gc3RhY2tlZE9uLnN0YWNrZWRPbjsKICAvLyAgICAgICAgIH0KICAvLyAgICAgfQogIC8vIH0KCiAgcmV0dXJuIHZhbHVlOwp9OwovKioKICogQHBhcmFtIHtzdHJpbmd9IGRpbSBjb25jcmV0ZSBkaW0KICogQHBhcmFtIHtudW1iZXJ9IHJhd0luZGV4CiAqIEByZXR1cm4ge251bWJlcnxzdHJpbmd9CiAqLwoKCmxpc3RQcm90by5nZXRCeVJhd0luZGV4ID0gZnVuY3Rpb24gKGRpbSwgcmF3SWR4KSB7CiAgaWYgKCEocmF3SWR4ID49IDAgJiYgcmF3SWR4IDwgdGhpcy5fcmF3Q291bnQpKSB7CiAgICByZXR1cm4gTmFOOwogIH0KCiAgdmFyIGRpbVN0b3JlID0gdGhpcy5fc3RvcmFnZVtkaW1dOwoKICBpZiAoIWRpbVN0b3JlKSB7CiAgICAvLyBUT0RPIFdhcm4gPwogICAgcmV0dXJuIE5hTjsKICB9CgogIHZhciBjaHVua0luZGV4ID0gTWF0aC5mbG9vcihyYXdJZHggLyB0aGlzLl9jaHVua1NpemUpOwogIHZhciBjaHVua09mZnNldCA9IHJhd0lkeCAlIHRoaXMuX2NodW5rU2l6ZTsKICB2YXIgY2h1bmtTdG9yZSA9IGRpbVN0b3JlW2NodW5rSW5kZXhdOwogIHJldHVybiBjaHVua1N0b3JlW2NodW5rT2Zmc2V0XTsKfTsKLyoqCiAqIEZJWE1FIFVzZSBgZ2V0YCBvbiBjaHJvbWUgbWF5YmUgc2xvdyhpbiBmaWx0ZXJTZWxmIGFuZCBzZWxlY3RSYW5nZSkuCiAqIEhhY2sgYSBtdWNoIHNpbXBsZXIgX2dldEZhc3QKICogQHByaXZhdGUKICovCgoKbGlzdFByb3RvLl9nZXRGYXN0ID0gZnVuY3Rpb24gKGRpbSwgcmF3SWR4KSB7CiAgdmFyIGNodW5rSW5kZXggPSBNYXRoLmZsb29yKHJhd0lkeCAvIHRoaXMuX2NodW5rU2l6ZSk7CiAgdmFyIGNodW5rT2Zmc2V0ID0gcmF3SWR4ICUgdGhpcy5fY2h1bmtTaXplOwogIHZhciBjaHVua1N0b3JlID0gdGhpcy5fc3RvcmFnZVtkaW1dW2NodW5rSW5kZXhdOwogIHJldHVybiBjaHVua1N0b3JlW2NodW5rT2Zmc2V0XTsKfTsKLyoqCiAqIEdldCB2YWx1ZSBmb3IgbXVsdGkgZGltZW5zaW9ucy4KICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gW2RpbWVuc2lvbnNdIElmIGlnbm9yZWQsIHVzaW5nIGFsbCBkaW1lbnNpb25zLgogKiBAcGFyYW0ge251bWJlcn0gaWR4CiAqIEByZXR1cm4ge251bWJlcn0KICovCgoKbGlzdFByb3RvLmdldFZhbHVlcyA9IGZ1bmN0aW9uIChkaW1lbnNpb25zLCBpZHgKLyosIHN0YWNrICovCikgewogIHZhciB2YWx1ZXMgPSBbXTsKCiAgaWYgKCF6clV0aWwuaXNBcnJheShkaW1lbnNpb25zKSkgewogICAgLy8gc3RhY2sgPSBpZHg7CiAgICBpZHggPSBkaW1lbnNpb25zOwogICAgZGltZW5zaW9ucyA9IHRoaXMuZGltZW5zaW9uczsKICB9CgogIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkaW1lbnNpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7CiAgICB2YWx1ZXMucHVzaCh0aGlzLmdldChkaW1lbnNpb25zW2ldLCBpZHgKICAgIC8qLCBzdGFjayAqLwogICAgKSk7CiAgfQoKICByZXR1cm4gdmFsdWVzOwp9OwovKioKICogSWYgdmFsdWUgaXMgTmFOLiBJbmxjdWRpbmcgJy0nCiAqIE9ubHkgY2hlY2sgdGhlIGNvb3JkIGRpbWVuc2lvbnMuCiAqIEBwYXJhbSB7c3RyaW5nfSBkaW0KICogQHBhcmFtIHtudW1iZXJ9IGlkeAogKiBAcmV0dXJuIHtudW1iZXJ9CiAqLwoKCmxpc3RQcm90by5oYXNWYWx1ZSA9IGZ1bmN0aW9uIChpZHgpIHsKICB2YXIgZGF0YURpbXNPbkNvb3JkID0gdGhpcy5fZGltZW5zaW9uc1N1bW1hcnkuZGF0YURpbXNPbkNvb3JkOwoKICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YURpbXNPbkNvb3JkLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7CiAgICAvLyBPcmRpbmFsIHR5cGUgb3JpZ2luYWxseSBjYW4gYmUgc3RyaW5nIG9yIG51bWJlci4KICAgIC8vIEJ1dCB3aGVuIGFuIG9yZGluYWwgdHlwZSBpcyB1c2VkIG9uIGNvb3JkLCBpdCBjYW4KICAgIC8vIG5vdCBiZSBzdHJpbmcgYnV0IG9ubHkgbnVtYmVyLiBTbyB3ZSBjYW4gYWxzbyB1c2UgaXNOYU4uCiAgICBpZiAoaXNOYU4odGhpcy5nZXQoZGF0YURpbXNPbkNvb3JkW2ldLCBpZHgpKSkgewogICAgICByZXR1cm4gZmFsc2U7CiAgICB9CiAgfQoKICByZXR1cm4gdHJ1ZTsKfTsKLyoqCiAqIEdldCBleHRlbnQgb2YgZGF0YSBpbiBvbmUgZGltZW5zaW9uCiAqIEBwYXJhbSB7c3RyaW5nfSBkaW0KICogQHBhcmFtIHtib29sZWFufSBzdGFjawogKi8KCgpsaXN0UHJvdG8uZ2V0RGF0YUV4dGVudCA9IGZ1bmN0aW9uIChkaW0KLyosIHN0YWNrICovCikgewogIC8vIE1ha2Ugc3VyZSB1c2UgY29uY3JldGUgZGltIGFzIGNhY2hlIG5hbWUuCiAgZGltID0gdGhpcy5nZXREaW1lbnNpb24oZGltKTsKICB2YXIgZGltRGF0YSA9IHRoaXMuX3N0b3JhZ2VbZGltXTsKICB2YXIgaW5pdGlhbEV4dGVudCA9IGdldEluaXRpYWxFeHRlbnQoKTsgLy8gc3RhY2sgPSAhISgoc3RhY2sgfHwgZmFsc2UpICYmIHRoaXMuZ2V0Q2FsY3VsYXRpb25JbmZvKGRpbSkpOwoKICBpZiAoIWRpbURhdGEpIHsKICAgIHJldHVybiBpbml0aWFsRXh0ZW50OwogIH0gLy8gTWFrZSBtb3JlIHN0cmljdCBjaGVja2luZ3MgdG8gZW5zdXJlIGhpdHRpbmcgY2FjaGUuCgoKICB2YXIgY3VyckVuZCA9IHRoaXMuY291bnQoKTsgLy8gdmFyIGNhY2hlTmFtZSA9IFtkaW0sICEhc3RhY2tdLmpvaW4oJ18nKTsKICAvLyB2YXIgY2FjaGVOYW1lID0gZGltOwogIC8vIENvbnNpZGVyIHRoZSBtb3N0IGNhc2VzIHdoZW4gdXNpbmcgZGF0YSB6b29tLCBgZ2V0RGF0YUV4dGVudGAKICAvLyBoYXBwZW5lZCBiZWZvcmUgZmlsdGVyaW5nLiBXZSBjYWNoZSByYXcgZXh0ZW50LCB3aGljaCBpcyBub3QKICAvLyBuZWNlc3NhcnkgdG8gYmUgY2xlYXJlZCBhbmQgcmVjYWxjdWxhdGVkIHdoZW4gcmVzdG9yZSBkYXRhLgoKICB2YXIgdXNlUmF3ID0gIXRoaXMuX2luZGljZXM7IC8vICYmICFzdGFjazsKCiAgdmFyIGRpbUV4dGVudDsKCiAgaWYgKHVzZVJhdykgewogICAgcmV0dXJuIHRoaXMuX3Jhd0V4dGVudFtkaW1dLnNsaWNlKCk7CiAgfQoKICBkaW1FeHRlbnQgPSB0aGlzLl9leHRlbnRbZGltXTsKCiAgaWYgKGRpbUV4dGVudCkgewogICAgcmV0dXJuIGRpbUV4dGVudC5zbGljZSgpOwogIH0KCiAgZGltRXh0ZW50ID0gaW5pdGlhbEV4dGVudDsKICB2YXIgbWluID0gZGltRXh0ZW50WzBdOwogIHZhciBtYXggPSBkaW1FeHRlbnRbMV07CgogIGZvciAodmFyIGkgPSAwOyBpIDwgY3VyckVuZDsgaSsrKSB7CiAgICAvLyB2YXIgdmFsdWUgPSBzdGFjayA/IHRoaXMuZ2V0KGRpbSwgaSwgdHJ1ZSkgOiB0aGlzLl9nZXRGYXN0KGRpbSwgdGhpcy5nZXRSYXdJbmRleChpKSk7CiAgICB2YXIgdmFsdWUgPSB0aGlzLl9nZXRGYXN0KGRpbSwgdGhpcy5nZXRSYXdJbmRleChpKSk7CgogICAgdmFsdWUgPCBtaW4gJiYgKG1pbiA9IHZhbHVlKTsKICAgIHZhbHVlID4gbWF4ICYmIChtYXggPSB2YWx1ZSk7CiAgfQoKICBkaW1FeHRlbnQgPSBbbWluLCBtYXhdOwogIHRoaXMuX2V4dGVudFtkaW1dID0gZGltRXh0ZW50OwogIHJldHVybiBkaW1FeHRlbnQ7Cn07Ci8qKgogKiBPcHRpbWl6ZSBmb3IgdGhlIHNjZW5hcmlvIHRoYXQgZGF0YSBpcyBmaWx0ZXJlZCBieSBhIGdpdmVuIGV4dGVudC4KICogQ29uc2lkZXIgdGhhdCBpZiBkYXRhIGFtb3VudCBpcyBtb3JlIHRoYW4gaHVuZHJlZHMgb2YgdGhvdXNhbmQsCiAqIGV4dGVudCBjYWxjdWxhdGlvbiB3aWxsIGNvc3QgbW9yZSB0aGFuIDEwbXMgYW5kIHRoZSBjYWNoZSB3aWxsCiAqIGJlIGVyYXNlZCBiZWNhdXNlIG9mIHRoZSBmaWx0ZXJpbmcuCiAqLwoKCmxpc3RQcm90by5nZXRBcHByb3hpbWF0ZUV4dGVudCA9IGZ1bmN0aW9uIChkaW0KLyosIHN0YWNrICovCikgewogIGRpbSA9IHRoaXMuZ2V0RGltZW5zaW9uKGRpbSk7CiAgcmV0dXJuIHRoaXMuX2FwcHJveGltYXRlRXh0ZW50W2RpbV0gfHwgdGhpcy5nZXREYXRhRXh0ZW50KGRpbQogIC8qLCBzdGFjayAqLwogICk7Cn07CgpsaXN0UHJvdG8uc2V0QXBwcm94aW1hdGVFeHRlbnQgPSBmdW5jdGlvbiAoZXh0ZW50LCBkaW0KLyosIHN0YWNrICovCikgewogIGRpbSA9IHRoaXMuZ2V0RGltZW5zaW9uKGRpbSk7CiAgdGhpcy5fYXBwcm94aW1hdGVFeHRlbnRbZGltXSA9IGV4dGVudC5zbGljZSgpOwp9OwovKioKICogQHBhcmFtIHtzdHJpbmd9IGtleQogKiBAcmV0dXJuIHsqfQogKi8KCgpsaXN0UHJvdG8uZ2V0Q2FsY3VsYXRpb25JbmZvID0gZnVuY3Rpb24gKGtleSkgewogIHJldHVybiB0aGlzLl9jYWxjdWxhdGlvbkluZm9ba2V5XTsKfTsKLyoqCiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0ga2V5IG9yIGstdiBvYmplY3QKICogQHBhcmFtIHsqfSBbdmFsdWVdCiAqLwoKCmxpc3RQcm90by5zZXRDYWxjdWxhdGlvbkluZm8gPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkgewogIGlzT2JqZWN0KGtleSkgPyB6clV0aWwuZXh0ZW5kKHRoaXMuX2NhbGN1bGF0aW9uSW5mbywga2V5KSA6IHRoaXMuX2NhbGN1bGF0aW9uSW5mb1trZXldID0gdmFsdWU7Cn07Ci8qKgogKiBHZXQgc3VtIG9mIGRhdGEgaW4gb25lIGRpbWVuc2lvbgogKiBAcGFyYW0ge3N0cmluZ30gZGltCiAqLwoKCmxpc3RQcm90by5nZXRTdW0gPSBmdW5jdGlvbiAoZGltCi8qLCBzdGFjayAqLwopIHsKICB2YXIgZGltRGF0YSA9IHRoaXMuX3N0b3JhZ2VbZGltXTsKICB2YXIgc3VtID0gMDsKCiAgaWYgKGRpbURhdGEpIHsKICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNvdW50KCk7IGkgPCBsZW47IGkrKykgewogICAgICB2YXIgdmFsdWUgPSB0aGlzLmdldChkaW0sIGkKICAgICAgLyosIHN0YWNrICovCiAgICAgICk7CgogICAgICBpZiAoIWlzTmFOKHZhbHVlKSkgewogICAgICAgIHN1bSArPSB2YWx1ZTsKICAgICAgfQogICAgfQogIH0KCiAgcmV0dXJuIHN1bTsKfTsKLyoqCiAqIEdldCBtZWRpYW4gb2YgZGF0YSBpbiBvbmUgZGltZW5zaW9uCiAqIEBwYXJhbSB7c3RyaW5nfSBkaW0KICovCgoKbGlzdFByb3RvLmdldE1lZGlhbiA9IGZ1bmN0aW9uIChkaW0KLyosIHN0YWNrICovCikgewogIHZhciBkaW1EYXRhQXJyYXkgPSBbXTsgLy8gbWFwIGFsbCBkYXRhIG9mIG9uZSBkaW1lbnNpb24KCiAgdGhpcy5lYWNoKGRpbSwgZnVuY3Rpb24gKHZhbCwgaWR4KSB7CiAgICBpZiAoIWlzTmFOKHZhbCkpIHsKICAgICAgZGltRGF0YUFycmF5LnB1c2godmFsKTsKICAgIH0KICB9KTsgLy8gVE9ETwogIC8vIFVzZSBxdWljayBzZWxlY3Q/CiAgLy8gaW1tdXRhYmlsaXR5ICYgc29ydAoKICB2YXIgc29ydGVkRGltRGF0YUFycmF5ID0gW10uY29uY2F0KGRpbURhdGFBcnJheSkuc29ydChmdW5jdGlvbiAoYSwgYikgewogICAgcmV0dXJuIGEgLSBiOwogIH0pOwogIHZhciBsZW4gPSB0aGlzLmNvdW50KCk7IC8vIGNhbGN1bGF0ZSBtZWRpYW4KCiAgcmV0dXJuIGxlbiA9PT0gMCA/IDAgOiBsZW4gJSAyID09PSAxID8gc29ydGVkRGltRGF0YUFycmF5WyhsZW4gLSAxKSAvIDJdIDogKHNvcnRlZERpbURhdGFBcnJheVtsZW4gLyAyXSArIHNvcnRlZERpbURhdGFBcnJheVtsZW4gLyAyIC0gMV0pIC8gMjsKfTsgLy8gLyoqCi8vICAqIFJldHJlaXZlIHRoZSBpbmRleCB3aXRoIGdpdmVuIHZhbHVlCi8vICAqIEBwYXJhbSB7c3RyaW5nfSBkaW0gQ29uY3JldGUgZGltZW5zaW9uLgovLyAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUKLy8gICogQHJldHVybiB7bnVtYmVyfQovLyAgKi8KLy8gQ3VycmVudGx5IGluY29ycmVjdDogc2hvdWxkIHJldHVybiBkYXRhSW5kZXggYnV0IG5vdCByYXdJbmRleC4KLy8gRG8gbm90IGZpeCBpdCB1bnRpbCB0aGlzIG1ldGhvZCBpcyB0byBiZSB1c2VkIHNvbWV3aGVyZS4KLy8gRklYTUUgUHJlY2lzaW9uIG9mIGZsb2F0IHZhbHVlCi8vIGxpc3RQcm90by5pbmRleE9mID0gZnVuY3Rpb24gKGRpbSwgdmFsdWUpIHsKLy8gICAgIHZhciBzdG9yYWdlID0gdGhpcy5fc3RvcmFnZTsKLy8gICAgIHZhciBkaW1EYXRhID0gc3RvcmFnZVtkaW1dOwovLyAgICAgdmFyIGNodW5rU2l6ZSA9IHRoaXMuX2NodW5rU2l6ZTsKLy8gICAgIGlmIChkaW1EYXRhKSB7Ci8vICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY291bnQoKTsgaSA8IGxlbjsgaSsrKSB7Ci8vICAgICAgICAgICAgIHZhciBjaHVua0luZGV4ID0gTWF0aC5mbG9vcihpIC8gY2h1bmtTaXplKTsKLy8gICAgICAgICAgICAgdmFyIGNodW5rT2Zmc2V0ID0gaSAlIGNodW5rU2l6ZTsKLy8gICAgICAgICAgICAgaWYgKGRpbURhdGFbY2h1bmtJbmRleF1bY2h1bmtPZmZzZXRdID09PSB2YWx1ZSkgewovLyAgICAgICAgICAgICAgICAgcmV0dXJuIGk7Ci8vICAgICAgICAgICAgIH0KLy8gICAgICAgICB9Ci8vICAgICB9Ci8vICAgICByZXR1cm4gLTE7Ci8vIH07CgovKioKICogT25seSBzdXBwb3J0IHRoZSBkaW1lbnNpb24gd2hpY2ggaW52ZXJ0ZWQgaW5kZXggY3JlYXRlZC4KICogRG8gbm90IHN1cHBvcnQgb3RoZXIgY2FzZXMgdW50aWwgcmVxdWlyZWQuCiAqIEBwYXJhbSB7c3RyaW5nfSBjb25jcmV0ZSBkaW0KICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSB2YWx1ZQogKiBAcmV0dXJuIHtudW1iZXJ9IHJhd0luZGV4CiAqLwoKCmxpc3RQcm90by5yYXdJbmRleE9mID0gZnVuY3Rpb24gKGRpbSwgdmFsdWUpIHsKICB2YXIgaW52ZXJ0ZWRJbmRpY2VzID0gZGltICYmIHRoaXMuX2ludmVydGVkSW5kaWNlc01hcFtkaW1dOwogIHZhciByYXdJbmRleCA9IGludmVydGVkSW5kaWNlc1t2YWx1ZV07CgogIGlmIChyYXdJbmRleCA9PSBudWxsIHx8IGlzTmFOKHJhd0luZGV4KSkgewogICAgcmV0dXJuIElOREVYX05PVF9GT1VORDsKICB9CgogIHJldHVybiByYXdJbmRleDsKfTsKLyoqCiAqIFJldHJlaXZlIHRoZSBpbmRleCB3aXRoIGdpdmVuIG5hbWUKICogQHBhcmFtIHtudW1iZXJ9IGlkeAogKiBAcGFyYW0ge251bWJlcn0gbmFtZQogKiBAcmV0dXJuIHtudW1iZXJ9CiAqLwoKCmxpc3RQcm90by5pbmRleE9mTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7CiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY291bnQoKTsgaSA8IGxlbjsgaSsrKSB7CiAgICBpZiAodGhpcy5nZXROYW1lKGkpID09PSBuYW1lKSB7CiAgICAgIHJldHVybiBpOwogICAgfQogIH0KCiAgcmV0dXJuIC0xOwp9OwovKioKICogUmV0cmVpdmUgdGhlIGluZGV4IHdpdGggZ2l2ZW4gcmF3IGRhdGEgaW5kZXgKICogQHBhcmFtIHtudW1iZXJ9IGlkeAogKiBAcGFyYW0ge251bWJlcn0gbmFtZQogKiBAcmV0dXJuIHtudW1iZXJ9CiAqLwoKCmxpc3RQcm90by5pbmRleE9mUmF3SW5kZXggPSBmdW5jdGlvbiAocmF3SW5kZXgpIHsKICBpZiAocmF3SW5kZXggPj0gdGhpcy5fcmF3Q291bnQgfHwgcmF3SW5kZXggPCAwKSB7CiAgICByZXR1cm4gLTE7CiAgfQoKICBpZiAoIXRoaXMuX2luZGljZXMpIHsKICAgIHJldHVybiByYXdJbmRleDsKICB9IC8vIEluZGljZXMgYXJlIGFzY2VuZGluZwoKCiAgdmFyIGluZGljZXMgPSB0aGlzLl9pbmRpY2VzOyAvLyBJZiByYXdJbmRleCA9PT0gZGF0YUluZGV4CgogIHZhciByYXdEYXRhSW5kZXggPSBpbmRpY2VzW3Jhd0luZGV4XTsKCiAgaWYgKHJhd0RhdGFJbmRleCAhPSBudWxsICYmIHJhd0RhdGFJbmRleCA8IHRoaXMuX2NvdW50ICYmIHJhd0RhdGFJbmRleCA9PT0gcmF3SW5kZXgpIHsKICAgIHJldHVybiByYXdJbmRleDsKICB9CgogIHZhciBsZWZ0ID0gMDsKICB2YXIgcmlnaHQgPSB0aGlzLl9jb3VudCAtIDE7CgogIHdoaWxlIChsZWZ0IDw9IHJpZ2h0KSB7CiAgICB2YXIgbWlkID0gKGxlZnQgKyByaWdodCkgLyAyIHwgMDsKCiAgICBpZiAoaW5kaWNlc1ttaWRdIDwgcmF3SW5kZXgpIHsKICAgICAgbGVmdCA9IG1pZCArIDE7CiAgICB9IGVsc2UgaWYgKGluZGljZXNbbWlkXSA+IHJhd0luZGV4KSB7CiAgICAgIHJpZ2h0ID0gbWlkIC0gMTsKICAgIH0gZWxzZSB7CiAgICAgIHJldHVybiBtaWQ7CiAgICB9CiAgfQoKICByZXR1cm4gLTE7Cn07Ci8qKgogKiBSZXRyZWl2ZSB0aGUgaW5kZXggb2YgbmVhcmVzdCB2YWx1ZQogKiBAcGFyYW0ge3N0cmluZ30gZGltCiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZQogKiBAcGFyYW0ge251bWJlcn0gW21heERpc3RhbmNlPUluZmluaXR5XQogKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gSWYgYW5kIG9ubHkgaWYgbXVsdGlwbGUgaW5kaWNlcyBoYXMKICogICAgICAgIHRoZSBzYW1lIHZhbHVlLCB0aGV5IGFyZSBwdXQgdG8gdGhlIHJlc3VsdC4KICovCgoKbGlzdFByb3RvLmluZGljZXNPZk5lYXJlc3QgPSBmdW5jdGlvbiAoZGltLCB2YWx1ZSwgbWF4RGlzdGFuY2UpIHsKICB2YXIgc3RvcmFnZSA9IHRoaXMuX3N0b3JhZ2U7CiAgdmFyIGRpbURhdGEgPSBzdG9yYWdlW2RpbV07CiAgdmFyIG5lYXJlc3RJbmRpY2VzID0gW107CgogIGlmICghZGltRGF0YSkgewogICAgcmV0dXJuIG5lYXJlc3RJbmRpY2VzOwogIH0KCiAgaWYgKG1heERpc3RhbmNlID09IG51bGwpIHsKICAgIG1heERpc3RhbmNlID0gSW5maW5pdHk7CiAgfQoKICB2YXIgbWluRGlzdCA9IEluZmluaXR5OwogIHZhciBtaW5EaWZmID0gLTE7CiAgdmFyIG5lYXJlc3RJbmRpY2VzTGVuID0gMDsgLy8gQ2hlY2sgdGhlIHRlc3QgY2FzZSBvZiBgdGVzdC91dC9zcGVjL2RhdGEvTGlzdC5qc2AuCgogIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNvdW50KCk7IGkgPCBsZW47IGkrKykgewogICAgdmFyIGRpZmYgPSB2YWx1ZSAtIHRoaXMuZ2V0KGRpbSwgaSk7CiAgICB2YXIgZGlzdCA9IE1hdGguYWJzKGRpZmYpOwoKICAgIGlmIChkaXN0IDw9IG1heERpc3RhbmNlKSB7CiAgICAgIC8vIFdoZW4gdGhlIGB2YWx1ZWAgaXMgYXQgdGhlIG1pZGRsZSBvZiBgdGhpcy5nZXQoZGltLCBpKWAgYW5kIGB0aGlzLmdldChkaW0sIGkrMSlgLAogICAgICAvLyB3ZSdkIGJldHRlciBub3QgcHVzaCBib3RoIG9mIHRoZW0gdG8gYG5lYXJlc3RJbmRpY2VzYCwgb3RoZXJ3aXNlIGl0IGlzIGVhc3kgdG8KICAgICAgLy8gZ2V0IG1vcmUgdGhhbiBvbmUgaXRlbSBpbiBgbmVhcmVzdEluZGljZXNgIChtb3JlIHNwZWNpZmljYWxseSwgaW4gYHRvb2x0aXBgKS4KICAgICAgLy8gU28gd2UgY2hvc2UgdGhlIG9uZSB0aGF0IGBkaWZmID49IDBgIGluIHRoaXMgY3NhZS4KICAgICAgLy8gQnV0IGlmIGB0aGlzLmdldChkaW0sIGkpYCBhbmQgYHRoaXMuZ2V0KGRpbSwgailgIGdldCB0aGUgc2FtZSB2YWx1ZSwgYm90aCBvZiB0aGVtCiAgICAgIC8vIHNob3VsZCBiZSBwdXNoIHRvIGBuZWFyZXN0SW5kaWNlc2AuCiAgICAgIGlmIChkaXN0IDwgbWluRGlzdCB8fCBkaXN0ID09PSBtaW5EaXN0ICYmIGRpZmYgPj0gMCAmJiBtaW5EaWZmIDwgMCkgewogICAgICAgIG1pbkRpc3QgPSBkaXN0OwogICAgICAgIG1pbkRpZmYgPSBkaWZmOwogICAgICAgIG5lYXJlc3RJbmRpY2VzTGVuID0gMDsKICAgICAgfQoKICAgICAgaWYgKGRpZmYgPT09IG1pbkRpZmYpIHsKICAgICAgICBuZWFyZXN0SW5kaWNlc1tuZWFyZXN0SW5kaWNlc0xlbisrXSA9IGk7CiAgICAgIH0KICAgIH0KICB9CgogIG5lYXJlc3RJbmRpY2VzLmxlbmd0aCA9IG5lYXJlc3RJbmRpY2VzTGVuOwogIHJldHVybiBuZWFyZXN0SW5kaWNlczsKfTsKLyoqCiAqIEdldCByYXcgZGF0YSBpbmRleAogKiBAcGFyYW0ge251bWJlcn0gaWR4CiAqIEByZXR1cm4ge251bWJlcn0KICovCgoKbGlzdFByb3RvLmdldFJhd0luZGV4ID0gZ2V0UmF3SW5kZXhXaXRob3V0SW5kaWNlczsKCmZ1bmN0aW9uIGdldFJhd0luZGV4V2l0aG91dEluZGljZXMoaWR4KSB7CiAgcmV0dXJuIGlkeDsKfQoKZnVuY3Rpb24gZ2V0UmF3SW5kZXhXaXRoSW5kaWNlcyhpZHgpIHsKICBpZiAoaWR4IDwgdGhpcy5fY291bnQgJiYgaWR4ID49IDApIHsKICAgIHJldHVybiB0aGlzLl9pbmRpY2VzW2lkeF07CiAgfQoKICByZXR1cm4gLTE7Cn0KLyoqCiAqIEdldCByYXcgZGF0YSBpdGVtCiAqIEBwYXJhbSB7bnVtYmVyfSBpZHgKICogQHJldHVybiB7bnVtYmVyfQogKi8KCgpsaXN0UHJvdG8uZ2V0UmF3RGF0YUl0ZW0gPSBmdW5jdGlvbiAoaWR4KSB7CiAgaWYgKCF0aGlzLl9yYXdEYXRhLnBlcnNpc3RlbnQpIHsKICAgIHZhciB2YWwgPSBbXTsKCiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGltZW5zaW9ucy5sZW5ndGg7IGkrKykgewogICAgICB2YXIgZGltID0gdGhpcy5kaW1lbnNpb25zW2ldOwogICAgICB2YWwucHVzaCh0aGlzLmdldChkaW0sIGlkeCkpOwogICAgfQoKICAgIHJldHVybiB2YWw7CiAgfSBlbHNlIHsKICAgIHJldHVybiB0aGlzLl9yYXdEYXRhLmdldEl0ZW0odGhpcy5nZXRSYXdJbmRleChpZHgpKTsKICB9Cn07Ci8qKgogKiBAcGFyYW0ge251bWJlcn0gaWR4CiAqIEBwYXJhbSB7Ym9vbGVhbn0gW25vdERlZmF1bHRJZHg9ZmFsc2VdCiAqIEByZXR1cm4ge3N0cmluZ30KICovCgoKbGlzdFByb3RvLmdldE5hbWUgPSBmdW5jdGlvbiAoaWR4KSB7CiAgdmFyIHJhd0luZGV4ID0gdGhpcy5nZXRSYXdJbmRleChpZHgpOwogIHJldHVybiB0aGlzLl9uYW1lTGlzdFtyYXdJbmRleF0gfHwgZ2V0UmF3VmFsdWVGcm9tU3RvcmUodGhpcywgdGhpcy5fbmFtZURpbUlkeCwgcmF3SW5kZXgpIHx8ICcnOwp9OwovKioKICogQHBhcmFtIHtudW1iZXJ9IGlkeAogKiBAcGFyYW0ge2Jvb2xlYW59IFtub3REZWZhdWx0SWR4PWZhbHNlXQogKiBAcmV0dXJuIHtzdHJpbmd9CiAqLwoKCmxpc3RQcm90by5nZXRJZCA9IGZ1bmN0aW9uIChpZHgpIHsKICByZXR1cm4gZ2V0SWQodGhpcywgdGhpcy5nZXRSYXdJbmRleChpZHgpKTsKfTsKCmZ1bmN0aW9uIGdldElkKGxpc3QsIHJhd0luZGV4KSB7CiAgdmFyIGlkID0gbGlzdC5faWRMaXN0W3Jhd0luZGV4XTsKCiAgaWYgKGlkID09IG51bGwpIHsKICAgIGlkID0gZ2V0UmF3VmFsdWVGcm9tU3RvcmUobGlzdCwgbGlzdC5faWREaW1JZHgsIHJhd0luZGV4KTsKICB9CgogIGlmIChpZCA9PSBudWxsKSB7CiAgICAvLyBGSVhNRSBDaGVjayB0aGUgdXNhZ2UgaW4gZ3JhcGgsIHNob3VsZCBub3QgdXNlIHByZWZpeC4KICAgIGlkID0gSURfUFJFRklYICsgcmF3SW5kZXg7CiAgfQoKICByZXR1cm4gaWQ7Cn0KCmZ1bmN0aW9uIG5vcm1hbGl6ZURpbWVuc2lvbnMoZGltZW5zaW9ucykgewogIGlmICghenJVdGlsLmlzQXJyYXkoZGltZW5zaW9ucykpIHsKICAgIGRpbWVuc2lvbnMgPSBbZGltZW5zaW9uc107CiAgfQoKICByZXR1cm4gZGltZW5zaW9uczsKfQoKZnVuY3Rpb24gdmFsaWRhdGVEaW1lbnNpb25zKGxpc3QsIGRpbXMpIHsKICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbXMubGVuZ3RoOyBpKyspIHsKICAgIC8vIHN0cm9hZ2UgbWF5IGJlIGVtcHR5IHdoZW4gbm8gZGF0YSwgc28gdXNlCiAgICAvLyBkaW1lbnNpb25JbmZvcyB0byBjaGVjay4KICAgIGlmICghbGlzdC5fZGltZW5zaW9uSW5mb3NbZGltc1tpXV0pIHsKICAgICAgY29uc29sZS5lcnJvcignVW5rb3duIGRpbWVuc2lvbiAnICsgZGltc1tpXSk7CiAgICB9CiAgfQp9Ci8qKgogKiBEYXRhIGl0ZXJhdGlvbgogKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48c3RyaW5nPn0KICogQHBhcmFtIHtGdW5jdGlvbn0gY2IKICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXQogKgogKiBAZXhhbXBsZQogKiAgbGlzdC5lYWNoKCd4JywgZnVuY3Rpb24gKHgsIGlkeCkge30pOwogKiAgbGlzdC5lYWNoKFsneCcsICd5J10sIGZ1bmN0aW9uICh4LCB5LCBpZHgpIHt9KTsKICogIGxpc3QuZWFjaChmdW5jdGlvbiAoaWR4KSB7fSkKICovCgoKbGlzdFByb3RvLmVhY2ggPSBmdW5jdGlvbiAoZGltcywgY2IsIGNvbnRleHQsIGNvbnRleHRDb21wYXQpIHsKICAndXNlIHN0cmljdCc7CgogIGlmICghdGhpcy5fY291bnQpIHsKICAgIHJldHVybjsKICB9CgogIGlmICh0eXBlb2YgZGltcyA9PT0gJ2Z1bmN0aW9uJykgewogICAgY29udGV4dENvbXBhdCA9IGNvbnRleHQ7CiAgICBjb250ZXh0ID0gY2I7CiAgICBjYiA9IGRpbXM7CiAgICBkaW1zID0gW107CiAgfSAvLyBjb250ZXh0Q29tcGF0IGp1c3QgZm9yIGNvbXBhdCBlY2hhcnRzMwoKCiAgY29udGV4dCA9IGNvbnRleHQgfHwgY29udGV4dENvbXBhdCB8fCB0aGlzOwogIGRpbXMgPSB6clV0aWwubWFwKG5vcm1hbGl6ZURpbWVuc2lvbnMoZGltcyksIHRoaXMuZ2V0RGltZW5zaW9uLCB0aGlzKTsKICB2YXIgZGltU2l6ZSA9IGRpbXMubGVuZ3RoOwoKICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY291bnQoKTsgaSsrKSB7CiAgICAvLyBTaW1wbGUgb3B0aW1pemF0aW9uCiAgICBzd2l0Y2ggKGRpbVNpemUpIHsKICAgICAgY2FzZSAwOgogICAgICAgIGNiLmNhbGwoY29udGV4dCwgaSk7CiAgICAgICAgYnJlYWs7CgogICAgICBjYXNlIDE6CiAgICAgICAgY2IuY2FsbChjb250ZXh0LCB0aGlzLmdldChkaW1zWzBdLCBpKSwgaSk7CiAgICAgICAgYnJlYWs7CgogICAgICBjYXNlIDI6CiAgICAgICAgY2IuY2FsbChjb250ZXh0LCB0aGlzLmdldChkaW1zWzBdLCBpKSwgdGhpcy5nZXQoZGltc1sxXSwgaSksIGkpOwogICAgICAgIGJyZWFrOwoKICAgICAgZGVmYXVsdDoKICAgICAgICB2YXIgayA9IDA7CiAgICAgICAgdmFyIHZhbHVlID0gW107CgogICAgICAgIGZvciAoOyBrIDwgZGltU2l6ZTsgaysrKSB7CiAgICAgICAgICB2YWx1ZVtrXSA9IHRoaXMuZ2V0KGRpbXNba10sIGkpOwogICAgICAgIH0gLy8gSW5kZXgKCgogICAgICAgIHZhbHVlW2tdID0gaTsKICAgICAgICBjYi5hcHBseShjb250ZXh0LCB2YWx1ZSk7CiAgICB9CiAgfQp9OwovKioKICogRGF0YSBmaWx0ZXIKICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPHN0cmluZz59CiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiCiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10KICovCgoKbGlzdFByb3RvLmZpbHRlclNlbGYgPSBmdW5jdGlvbiAoZGltZW5zaW9ucywgY2IsIGNvbnRleHQsIGNvbnRleHRDb21wYXQpIHsKICAndXNlIHN0cmljdCc7CgogIGlmICghdGhpcy5fY291bnQpIHsKICAgIHJldHVybjsKICB9CgogIGlmICh0eXBlb2YgZGltZW5zaW9ucyA9PT0gJ2Z1bmN0aW9uJykgewogICAgY29udGV4dENvbXBhdCA9IGNvbnRleHQ7CiAgICBjb250ZXh0ID0gY2I7CiAgICBjYiA9IGRpbWVuc2lvbnM7CiAgICBkaW1lbnNpb25zID0gW107CiAgfSAvLyBjb250ZXh0Q29tcGF0IGp1c3QgZm9yIGNvbXBhdCBlY2hhcnRzMwoKCiAgY29udGV4dCA9IGNvbnRleHQgfHwgY29udGV4dENvbXBhdCB8fCB0aGlzOwogIGRpbWVuc2lvbnMgPSB6clV0aWwubWFwKG5vcm1hbGl6ZURpbWVuc2lvbnMoZGltZW5zaW9ucyksIHRoaXMuZ2V0RGltZW5zaW9uLCB0aGlzKTsKICB2YXIgY291bnQgPSB0aGlzLmNvdW50KCk7CiAgdmFyIEN0b3IgPSBnZXRJbmRpY2VzQ3Rvcih0aGlzKTsKICB2YXIgbmV3SW5kaWNlcyA9IG5ldyBDdG9yKGNvdW50KTsKICB2YXIgdmFsdWUgPSBbXTsKICB2YXIgZGltU2l6ZSA9IGRpbWVuc2lvbnMubGVuZ3RoOwogIHZhciBvZmZzZXQgPSAwOwogIHZhciBkaW0wID0gZGltZW5zaW9uc1swXTsKCiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7CiAgICB2YXIga2VlcDsKICAgIHZhciByYXdJZHggPSB0aGlzLmdldFJhd0luZGV4KGkpOyAvLyBTaW1wbGUgb3B0aW1pemF0aW9uCgogICAgaWYgKGRpbVNpemUgPT09IDApIHsKICAgICAga2VlcCA9IGNiLmNhbGwoY29udGV4dCwgaSk7CiAgICB9IGVsc2UgaWYgKGRpbVNpemUgPT09IDEpIHsKICAgICAgdmFyIHZhbCA9IHRoaXMuX2dldEZhc3QoZGltMCwgcmF3SWR4KTsKCiAgICAgIGtlZXAgPSBjYi5jYWxsKGNvbnRleHQsIHZhbCwgaSk7CiAgICB9IGVsc2UgewogICAgICBmb3IgKHZhciBrID0gMDsgayA8IGRpbVNpemU7IGsrKykgewogICAgICAgIHZhbHVlW2tdID0gdGhpcy5fZ2V0RmFzdChkaW0wLCByYXdJZHgpOwogICAgICB9CgogICAgICB2YWx1ZVtrXSA9IGk7CiAgICAgIGtlZXAgPSBjYi5hcHBseShjb250ZXh0LCB2YWx1ZSk7CiAgICB9CgogICAgaWYgKGtlZXApIHsKICAgICAgbmV3SW5kaWNlc1tvZmZzZXQrK10gPSByYXdJZHg7CiAgICB9CiAgfSAvLyBTZXQgaW5kaWNlcyBhZnRlciBmaWx0ZXJlZC4KCgogIGlmIChvZmZzZXQgPCBjb3VudCkgewogICAgdGhpcy5faW5kaWNlcyA9IG5ld0luZGljZXM7CiAgfQoKICB0aGlzLl9jb3VudCA9IG9mZnNldDsgLy8gUmVzZXQgZGF0YSBleHRlbnQKCiAgdGhpcy5fZXh0ZW50ID0ge307CiAgdGhpcy5nZXRSYXdJbmRleCA9IHRoaXMuX2luZGljZXMgPyBnZXRSYXdJbmRleFdpdGhJbmRpY2VzIDogZ2V0UmF3SW5kZXhXaXRob3V0SW5kaWNlczsKICByZXR1cm4gdGhpczsKfTsKLyoqCiAqIFNlbGVjdCBkYXRhIGluIHJhbmdlLiAoRm9yIG9wdGltaXphdGlvbiBvZiBmaWx0ZXIpCiAqIChNYW51YWxseSBpbmxpbmUgY29kZSwgc3VwcG9ydCA1IG1pbGxpb24gZGF0YSBmaWx0ZXJpbmcgaW4gZGF0YSB6b29tLikKICovCgoKbGlzdFByb3RvLnNlbGVjdFJhbmdlID0gZnVuY3Rpb24gKHJhbmdlKSB7CiAgJ3VzZSBzdHJpY3QnOwoKICBpZiAoIXRoaXMuX2NvdW50KSB7CiAgICByZXR1cm47CiAgfQoKICB2YXIgZGltZW5zaW9ucyA9IFtdOwoKICBmb3IgKHZhciBkaW0gaW4gcmFuZ2UpIHsKICAgIGlmIChyYW5nZS5oYXNPd25Qcm9wZXJ0eShkaW0pKSB7CiAgICAgIGRpbWVuc2lvbnMucHVzaChkaW0pOwogICAgfQogIH0KCiAgdmFyIGRpbVNpemUgPSBkaW1lbnNpb25zLmxlbmd0aDsKCiAgaWYgKCFkaW1TaXplKSB7CiAgICByZXR1cm47CiAgfQoKICB2YXIgb3JpZ2luYWxDb3VudCA9IHRoaXMuY291bnQoKTsKICB2YXIgQ3RvciA9IGdldEluZGljZXNDdG9yKHRoaXMpOwogIHZhciBuZXdJbmRpY2VzID0gbmV3IEN0b3Iob3JpZ2luYWxDb3VudCk7CiAgdmFyIG9mZnNldCA9IDA7CiAgdmFyIGRpbTAgPSBkaW1lbnNpb25zWzBdOwogIHZhciBtaW4gPSByYW5nZVtkaW0wXVswXTsKICB2YXIgbWF4ID0gcmFuZ2VbZGltMF1bMV07CiAgdmFyIHF1aWNrRmluaXNoZWQgPSBmYWxzZTsKCiAgaWYgKCF0aGlzLl9pbmRpY2VzKSB7CiAgICAvLyBFeHRyZW1lIG9wdGltaXphdGlvbiBmb3IgY29tbW9uIGNhc2UuIEFib3V0IDJ4IGZhc3RlciBpbiBjaHJvbWUuCiAgICB2YXIgaWR4ID0gMDsKCiAgICBpZiAoZGltU2l6ZSA9PT0gMSkgewogICAgICB2YXIgZGltU3RvcmFnZSA9IHRoaXMuX3N0b3JhZ2VbZGltZW5zaW9uc1swXV07CgogICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMuX2NodW5rQ291bnQ7IGsrKykgewogICAgICAgIHZhciBjaHVua1N0b3JhZ2UgPSBkaW1TdG9yYWdlW2tdOwogICAgICAgIHZhciBsZW4gPSBNYXRoLm1pbih0aGlzLl9jb3VudCAtIGsgKiB0aGlzLl9jaHVua1NpemUsIHRoaXMuX2NodW5rU2l6ZSk7CgogICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsKICAgICAgICAgIHZhciB2YWwgPSBjaHVua1N0b3JhZ2VbaV07IC8vIE5hTiB3aWxsIG5vdCBiZSBmaWx0ZXJlZC4gQ29uc2lkZXIgdGhlIGNhc2UsIGluIGxpbmUgY2hhcnQsIGVtcHR5CiAgICAgICAgICAvLyB2YWx1ZSBpbmRpY2F0ZXMgdGhlIGxpbmUgc2hvdWxkIGJlIGJyb2tlbi4gQnV0IGZvciB0aGUgY2FzZSBsaWtlCiAgICAgICAgICAvLyBzY2F0dGVyIHBsb3QsIGEgZGF0YSBpdGVtIHdpdGggZW1wdHkgdmFsdWUgd2lsbCBub3QgYmUgcmVuZGVyZWQsCiAgICAgICAgICAvLyBidXQgdGhlIGF4aXMgZXh0ZW50IG1heSBiZSBlZmZlY3RlZCBpZiBzb21lIG90aGVyIGRpbSBvZiB0aGUgZGF0YQogICAgICAgICAgLy8gaXRlbSBoYXMgdmFsdWUuIEZvcnR1bmF0ZWx5IGl0IGlzIG5vdCBhIHNpZ25pZmljYW50IG5lZ2F0aXZlIGVmZmVjdC4KCiAgICAgICAgICBpZiAodmFsID49IG1pbiAmJiB2YWwgPD0gbWF4IHx8IGlzTmFOKHZhbCkpIHsKICAgICAgICAgICAgbmV3SW5kaWNlc1tvZmZzZXQrK10gPSBpZHg7CiAgICAgICAgICB9CgogICAgICAgICAgaWR4Kys7CiAgICAgICAgfQogICAgICB9CgogICAgICBxdWlja0ZpbmlzaGVkID0gdHJ1ZTsKICAgIH0gZWxzZSBpZiAoZGltU2l6ZSA9PT0gMikgewogICAgICB2YXIgZGltU3RvcmFnZSA9IHRoaXMuX3N0b3JhZ2VbZGltMF07CiAgICAgIHZhciBkaW1TdG9yYWdlMiA9IHRoaXMuX3N0b3JhZ2VbZGltZW5zaW9uc1sxXV07CiAgICAgIHZhciBtaW4yID0gcmFuZ2VbZGltZW5zaW9uc1sxXV1bMF07CiAgICAgIHZhciBtYXgyID0gcmFuZ2VbZGltZW5zaW9uc1sxXV1bMV07CgogICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMuX2NodW5rQ291bnQ7IGsrKykgewogICAgICAgIHZhciBjaHVua1N0b3JhZ2UgPSBkaW1TdG9yYWdlW2tdOwogICAgICAgIHZhciBjaHVua1N0b3JhZ2UyID0gZGltU3RvcmFnZTJba107CiAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluKHRoaXMuX2NvdW50IC0gayAqIHRoaXMuX2NodW5rU2l6ZSwgdGhpcy5fY2h1bmtTaXplKTsKCiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgewogICAgICAgICAgdmFyIHZhbCA9IGNodW5rU3RvcmFnZVtpXTsKICAgICAgICAgIHZhciB2YWwyID0gY2h1bmtTdG9yYWdlMltpXTsgLy8gRG8gbm90IGZpbHRlciBOYU4sIHNlZSBjb21tZW50IGFib3ZlLgoKICAgICAgICAgIGlmICgodmFsID49IG1pbiAmJiB2YWwgPD0gbWF4IHx8IGlzTmFOKHZhbCkpICYmICh2YWwyID49IG1pbjIgJiYgdmFsMiA8PSBtYXgyIHx8IGlzTmFOKHZhbDIpKSkgewogICAgICAgICAgICBuZXdJbmRpY2VzW29mZnNldCsrXSA9IGlkeDsKICAgICAgICAgIH0KCiAgICAgICAgICBpZHgrKzsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIHF1aWNrRmluaXNoZWQgPSB0cnVlOwogICAgfQogIH0KCiAgaWYgKCFxdWlja0ZpbmlzaGVkKSB7CiAgICBpZiAoZGltU2l6ZSA9PT0gMSkgewogICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yaWdpbmFsQ291bnQ7IGkrKykgewogICAgICAgIHZhciByYXdJbmRleCA9IHRoaXMuZ2V0UmF3SW5kZXgoaSk7CgogICAgICAgIHZhciB2YWwgPSB0aGlzLl9nZXRGYXN0KGRpbTAsIHJhd0luZGV4KTsgLy8gRG8gbm90IGZpbHRlciBOYU4sIHNlZSBjb21tZW50IGFib3ZlLgoKCiAgICAgICAgaWYgKHZhbCA+PSBtaW4gJiYgdmFsIDw9IG1heCB8fCBpc05hTih2YWwpKSB7CiAgICAgICAgICBuZXdJbmRpY2VzW29mZnNldCsrXSA9IHJhd0luZGV4OwogICAgICAgIH0KICAgICAgfQogICAgfSBlbHNlIHsKICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmlnaW5hbENvdW50OyBpKyspIHsKICAgICAgICB2YXIga2VlcCA9IHRydWU7CiAgICAgICAgdmFyIHJhd0luZGV4ID0gdGhpcy5nZXRSYXdJbmRleChpKTsKCiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBkaW1TaXplOyBrKyspIHsKICAgICAgICAgIHZhciBkaW1rID0gZGltZW5zaW9uc1trXTsKCiAgICAgICAgICB2YXIgdmFsID0gdGhpcy5fZ2V0RmFzdChkaW0sIHJhd0luZGV4KTsgLy8gRG8gbm90IGZpbHRlciBOYU4sIHNlZSBjb21tZW50IGFib3ZlLgoKCiAgICAgICAgICBpZiAodmFsIDwgcmFuZ2VbZGlta11bMF0gfHwgdmFsID4gcmFuZ2VbZGlta11bMV0pIHsKICAgICAgICAgICAga2VlcCA9IGZhbHNlOwogICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgaWYgKGtlZXApIHsKICAgICAgICAgIG5ld0luZGljZXNbb2Zmc2V0KytdID0gdGhpcy5nZXRSYXdJbmRleChpKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICB9IC8vIFNldCBpbmRpY2VzIGFmdGVyIGZpbHRlcmVkLgoKCiAgaWYgKG9mZnNldCA8IG9yaWdpbmFsQ291bnQpIHsKICAgIHRoaXMuX2luZGljZXMgPSBuZXdJbmRpY2VzOwogIH0KCiAgdGhpcy5fY291bnQgPSBvZmZzZXQ7IC8vIFJlc2V0IGRhdGEgZXh0ZW50CgogIHRoaXMuX2V4dGVudCA9IHt9OwogIHRoaXMuZ2V0UmF3SW5kZXggPSB0aGlzLl9pbmRpY2VzID8gZ2V0UmF3SW5kZXhXaXRoSW5kaWNlcyA6IGdldFJhd0luZGV4V2l0aG91dEluZGljZXM7CiAgcmV0dXJuIHRoaXM7Cn07Ci8qKgogKiBEYXRhIG1hcHBpbmcgdG8gYSBwbGFpbiBhcnJheQogKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48c3RyaW5nPn0gW2RpbWVuc2lvbnNdCiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiCiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10KICogQHJldHVybiB7QXJyYXl9CiAqLwoKCmxpc3RQcm90by5tYXBBcnJheSA9IGZ1bmN0aW9uIChkaW1lbnNpb25zLCBjYiwgY29udGV4dCwgY29udGV4dENvbXBhdCkgewogICd1c2Ugc3RyaWN0JzsKCiAgaWYgKHR5cGVvZiBkaW1lbnNpb25zID09PSAnZnVuY3Rpb24nKSB7CiAgICBjb250ZXh0Q29tcGF0ID0gY29udGV4dDsKICAgIGNvbnRleHQgPSBjYjsKICAgIGNiID0gZGltZW5zaW9uczsKICAgIGRpbWVuc2lvbnMgPSBbXTsKICB9IC8vIGNvbnRleHRDb21wYXQganVzdCBmb3IgY29tcGF0IGVjaGFydHMzCgoKICBjb250ZXh0ID0gY29udGV4dCB8fCBjb250ZXh0Q29tcGF0IHx8IHRoaXM7CiAgdmFyIHJlc3VsdCA9IFtdOwogIHRoaXMuZWFjaChkaW1lbnNpb25zLCBmdW5jdGlvbiAoKSB7CiAgICByZXN1bHQucHVzaChjYiAmJiBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTsKICB9LCBjb250ZXh0KTsKICByZXR1cm4gcmVzdWx0Owp9OyAvLyBEYXRhIGluIGV4Y2x1ZGVEaW1lbnNpb25zIGlzIGNvcGllZCwgb3RoZXJ3aXNlIHRyYW5zZmVyZWQuCgoKZnVuY3Rpb24gY2xvbmVMaXN0Rm9yTWFwQW5kU2FtcGxlKG9yaWdpbmFsLCBleGNsdWRlRGltZW5zaW9ucykgewogIHZhciBhbGxEaW1lbnNpb25zID0gb3JpZ2luYWwuZGltZW5zaW9uczsKICB2YXIgbGlzdCA9IG5ldyBMaXN0KHpyVXRpbC5tYXAoYWxsRGltZW5zaW9ucywgb3JpZ2luYWwuZ2V0RGltZW5zaW9uSW5mbywgb3JpZ2luYWwpLCBvcmlnaW5hbC5ob3N0TW9kZWwpOyAvLyBGSVhNRSBJZiBuZWVkcyBzdGFja2VkT24sIHZhbHVlIG1heSBhbHJlYWR5IGJlZW4gc3RhY2tlZAoKICB0cmFuc2ZlclByb3BlcnRpZXMobGlzdCwgb3JpZ2luYWwpOwogIHZhciBzdG9yYWdlID0gbGlzdC5fc3RvcmFnZSA9IHt9OwogIHZhciBvcmlnaW5hbFN0b3JhZ2UgPSBvcmlnaW5hbC5fc3RvcmFnZTsgLy8gSW5pdCBzdG9yYWdlCgogIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsRGltZW5zaW9ucy5sZW5ndGg7IGkrKykgewogICAgdmFyIGRpbSA9IGFsbERpbWVuc2lvbnNbaV07CgogICAgaWYgKG9yaWdpbmFsU3RvcmFnZVtkaW1dKSB7CiAgICAgIC8vIE5vdGljZSB0aGF0IHdlIGRvIG5vdCByZXNldCBpbnZlcnRlZEluZGljZXNNYXAgaGVyZSwgYmVjdWFzZQogICAgICAvLyB0aGVyZSBpcyBubyBzY2VuYXJpbyBvZiBtYXBwaW5nIG9yIHNhbXBsaW5nIG9yZGluYWwgZGltZW5zaW9uLgogICAgICBpZiAoenJVdGlsLmluZGV4T2YoZXhjbHVkZURpbWVuc2lvbnMsIGRpbSkgPj0gMCkgewogICAgICAgIHN0b3JhZ2VbZGltXSA9IGNsb25lRGltU3RvcmUob3JpZ2luYWxTdG9yYWdlW2RpbV0pOwogICAgICAgIGxpc3QuX3Jhd0V4dGVudFtkaW1dID0gZ2V0SW5pdGlhbEV4dGVudCgpOwogICAgICAgIGxpc3QuX2V4dGVudFtkaW1dID0gbnVsbDsKICAgICAgfSBlbHNlIHsKICAgICAgICAvLyBEaXJlY3QgcmVmZXJlbmNlIGZvciBvdGhlciBkaW1lbnNpb25zCiAgICAgICAgc3RvcmFnZVtkaW1dID0gb3JpZ2luYWxTdG9yYWdlW2RpbV07CiAgICAgIH0KICAgIH0KICB9CgogIHJldHVybiBsaXN0Owp9CgpmdW5jdGlvbiBjbG9uZURpbVN0b3JlKG9yaWdpbmFsRGltU3RvcmUpIHsKICB2YXIgbmV3RGltU3RvcmUgPSBuZXcgQXJyYXkob3JpZ2luYWxEaW1TdG9yZS5sZW5ndGgpOwoKICBmb3IgKHZhciBqID0gMDsgaiA8IG9yaWdpbmFsRGltU3RvcmUubGVuZ3RoOyBqKyspIHsKICAgIG5ld0RpbVN0b3JlW2pdID0gY2xvbmVDaHVuayhvcmlnaW5hbERpbVN0b3JlW2pdKTsKICB9CgogIHJldHVybiBuZXdEaW1TdG9yZTsKfQoKZnVuY3Rpb24gZ2V0SW5pdGlhbEV4dGVudCgpIHsKICByZXR1cm4gW0luZmluaXR5LCAtSW5maW5pdHldOwp9Ci8qKgogKiBEYXRhIG1hcHBpbmcgdG8gYSBuZXcgTGlzdCB3aXRoIGdpdmVuIGRpbWVuc2lvbnMKICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPHN0cmluZz59IGRpbWVuc2lvbnMKICogQHBhcmFtIHtGdW5jdGlvbn0gY2IKICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXQogKiBAcmV0dXJuIHtBcnJheX0KICovCgoKbGlzdFByb3RvLm1hcCA9IGZ1bmN0aW9uIChkaW1lbnNpb25zLCBjYiwgY29udGV4dCwgY29udGV4dENvbXBhdCkgewogICd1c2Ugc3RyaWN0JzsgLy8gY29udGV4dENvbXBhdCBqdXN0IGZvciBjb21wYXQgZWNoYXJ0czMKCiAgY29udGV4dCA9IGNvbnRleHQgfHwgY29udGV4dENvbXBhdCB8fCB0aGlzOwogIGRpbWVuc2lvbnMgPSB6clV0aWwubWFwKG5vcm1hbGl6ZURpbWVuc2lvbnMoZGltZW5zaW9ucyksIHRoaXMuZ2V0RGltZW5zaW9uLCB0aGlzKTsKICB2YXIgbGlzdCA9IGNsb25lTGlzdEZvck1hcEFuZFNhbXBsZSh0aGlzLCBkaW1lbnNpb25zKTsgLy8gRm9sbG93aW5nIHByb3BlcnRpZXMgYXJlIGFsbCBpbW11dGFibGUuCiAgLy8gU28gd2UgY2FuIHJlZmVyZW5jZSB0byB0aGUgc2FtZSB2YWx1ZQoKICBsaXN0Ll9pbmRpY2VzID0gdGhpcy5faW5kaWNlczsKICBsaXN0LmdldFJhd0luZGV4ID0gbGlzdC5faW5kaWNlcyA/IGdldFJhd0luZGV4V2l0aEluZGljZXMgOiBnZXRSYXdJbmRleFdpdGhvdXRJbmRpY2VzOwogIHZhciBzdG9yYWdlID0gbGlzdC5fc3RvcmFnZTsKICB2YXIgdG1wUmV0VmFsdWUgPSBbXTsKICB2YXIgY2h1bmtTaXplID0gdGhpcy5fY2h1bmtTaXplOwogIHZhciBkaW1TaXplID0gZGltZW5zaW9ucy5sZW5ndGg7CiAgdmFyIGRhdGFDb3VudCA9IHRoaXMuY291bnQoKTsKICB2YXIgdmFsdWVzID0gW107CiAgdmFyIHJhd0V4dGVudCA9IGxpc3QuX3Jhd0V4dGVudDsKCiAgZm9yICh2YXIgZGF0YUluZGV4ID0gMDsgZGF0YUluZGV4IDwgZGF0YUNvdW50OyBkYXRhSW5kZXgrKykgewogICAgZm9yICh2YXIgZGltSW5kZXggPSAwOyBkaW1JbmRleCA8IGRpbVNpemU7IGRpbUluZGV4KyspIHsKICAgICAgdmFsdWVzW2RpbUluZGV4XSA9IHRoaXMuZ2V0KGRpbWVuc2lvbnNbZGltSW5kZXhdLCBkYXRhSW5kZXgKICAgICAgLyosIHN0YWNrICovCiAgICAgICk7CiAgICB9CgogICAgdmFsdWVzW2RpbVNpemVdID0gZGF0YUluZGV4OwogICAgdmFyIHJldFZhbHVlID0gY2IgJiYgY2IuYXBwbHkoY29udGV4dCwgdmFsdWVzKTsKCiAgICBpZiAocmV0VmFsdWUgIT0gbnVsbCkgewogICAgICAvLyBhIG51bWJlciBvciBzdHJpbmcgKGluIG9yaWRpbmFsIGRpbWVuc2lvbik/CiAgICAgIGlmIChfdHlwZW9mKHJldFZhbHVlKSAhPT0gJ29iamVjdCcpIHsKICAgICAgICB0bXBSZXRWYWx1ZVswXSA9IHJldFZhbHVlOwogICAgICAgIHJldFZhbHVlID0gdG1wUmV0VmFsdWU7CiAgICAgIH0KCiAgICAgIHZhciByYXdJbmRleCA9IHRoaXMuZ2V0UmF3SW5kZXgoZGF0YUluZGV4KTsKICAgICAgdmFyIGNodW5rSW5kZXggPSBNYXRoLmZsb29yKHJhd0luZGV4IC8gY2h1bmtTaXplKTsKICAgICAgdmFyIGNodW5rT2Zmc2V0ID0gcmF3SW5kZXggJSBjaHVua1NpemU7CgogICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJldFZhbHVlLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgdmFyIGRpbSA9IGRpbWVuc2lvbnNbaV07CiAgICAgICAgdmFyIHZhbCA9IHJldFZhbHVlW2ldOwogICAgICAgIHZhciByYXdFeHRlbnRPbkRpbSA9IHJhd0V4dGVudFtkaW1dOwogICAgICAgIHZhciBkaW1TdG9yZSA9IHN0b3JhZ2VbZGltXTsKCiAgICAgICAgaWYgKGRpbVN0b3JlKSB7CiAgICAgICAgICBkaW1TdG9yZVtjaHVua0luZGV4XVtjaHVua09mZnNldF0gPSB2YWw7CiAgICAgICAgfQoKICAgICAgICBpZiAodmFsIDwgcmF3RXh0ZW50T25EaW1bMF0pIHsKICAgICAgICAgIHJhd0V4dGVudE9uRGltWzBdID0gdmFsOwogICAgICAgIH0KCiAgICAgICAgaWYgKHZhbCA+IHJhd0V4dGVudE9uRGltWzFdKSB7CiAgICAgICAgICByYXdFeHRlbnRPbkRpbVsxXSA9IHZhbDsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICB9CgogIHJldHVybiBsaXN0Owp9OwovKioKICogTGFyZ2UgZGF0YSBkb3duIHNhbXBsaW5nIG9uIGdpdmVuIGRpbWVuc2lvbgogKiBAcGFyYW0ge3N0cmluZ30gZGltZW5zaW9uCiAqIEBwYXJhbSB7bnVtYmVyfSByYXRlCiAqIEBwYXJhbSB7RnVuY3Rpb259IHNhbXBsZVZhbHVlCiAqIEBwYXJhbSB7RnVuY3Rpb259IHNhbXBsZUluZGV4IFNhbXBsZSBpbmRleCBmb3IgbmFtZSBhbmQgaWQKICovCgoKbGlzdFByb3RvLmRvd25TYW1wbGUgPSBmdW5jdGlvbiAoZGltZW5zaW9uLCByYXRlLCBzYW1wbGVWYWx1ZSwgc2FtcGxlSW5kZXgpIHsKICB2YXIgbGlzdCA9IGNsb25lTGlzdEZvck1hcEFuZFNhbXBsZSh0aGlzLCBbZGltZW5zaW9uXSk7CiAgdmFyIHRhcmdldFN0b3JhZ2UgPSBsaXN0Ll9zdG9yYWdlOwogIHZhciBmcmFtZVZhbHVlcyA9IFtdOwogIHZhciBmcmFtZVNpemUgPSBNYXRoLmZsb29yKDEgLyByYXRlKTsKICB2YXIgZGltU3RvcmUgPSB0YXJnZXRTdG9yYWdlW2RpbWVuc2lvbl07CiAgdmFyIGxlbiA9IHRoaXMuY291bnQoKTsKICB2YXIgY2h1bmtTaXplID0gdGhpcy5fY2h1bmtTaXplOwogIHZhciByYXdFeHRlbnRPbkRpbSA9IGxpc3QuX3Jhd0V4dGVudFtkaW1lbnNpb25dOwogIHZhciBuZXdJbmRpY2VzID0gbmV3IChnZXRJbmRpY2VzQ3Rvcih0aGlzKSkobGVuKTsKICB2YXIgb2Zmc2V0ID0gMDsKCiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gZnJhbWVTaXplKSB7CiAgICAvLyBMYXN0IGZyYW1lCiAgICBpZiAoZnJhbWVTaXplID4gbGVuIC0gaSkgewogICAgICBmcmFtZVNpemUgPSBsZW4gLSBpOwogICAgICBmcmFtZVZhbHVlcy5sZW5ndGggPSBmcmFtZVNpemU7CiAgICB9CgogICAgZm9yICh2YXIgayA9IDA7IGsgPCBmcmFtZVNpemU7IGsrKykgewogICAgICB2YXIgZGF0YUlkeCA9IHRoaXMuZ2V0UmF3SW5kZXgoaSArIGspOwogICAgICB2YXIgb3JpZ2luYWxDaHVua0luZGV4ID0gTWF0aC5mbG9vcihkYXRhSWR4IC8gY2h1bmtTaXplKTsKICAgICAgdmFyIG9yaWdpbmFsQ2h1bmtPZmZzZXQgPSBkYXRhSWR4ICUgY2h1bmtTaXplOwogICAgICBmcmFtZVZhbHVlc1trXSA9IGRpbVN0b3JlW29yaWdpbmFsQ2h1bmtJbmRleF1bb3JpZ2luYWxDaHVua09mZnNldF07CiAgICB9CgogICAgdmFyIHZhbHVlID0gc2FtcGxlVmFsdWUoZnJhbWVWYWx1ZXMpOwogICAgdmFyIHNhbXBsZUZyYW1lSWR4ID0gdGhpcy5nZXRSYXdJbmRleChNYXRoLm1pbihpICsgc2FtcGxlSW5kZXgoZnJhbWVWYWx1ZXMsIHZhbHVlKSB8fCAwLCBsZW4gLSAxKSk7CiAgICB2YXIgc2FtcGxlQ2h1bmtJbmRleCA9IE1hdGguZmxvb3Ioc2FtcGxlRnJhbWVJZHggLyBjaHVua1NpemUpOwogICAgdmFyIHNhbXBsZUNodW5rT2Zmc2V0ID0gc2FtcGxlRnJhbWVJZHggJSBjaHVua1NpemU7IC8vIE9ubHkgd3JpdGUgdmFsdWUgb24gdGhlIGZpbHRlcmVkIGRhdGEKCiAgICBkaW1TdG9yZVtzYW1wbGVDaHVua0luZGV4XVtzYW1wbGVDaHVua09mZnNldF0gPSB2YWx1ZTsKCiAgICBpZiAodmFsdWUgPCByYXdFeHRlbnRPbkRpbVswXSkgewogICAgICByYXdFeHRlbnRPbkRpbVswXSA9IHZhbHVlOwogICAgfQoKICAgIGlmICh2YWx1ZSA+IHJhd0V4dGVudE9uRGltWzFdKSB7CiAgICAgIHJhd0V4dGVudE9uRGltWzFdID0gdmFsdWU7CiAgICB9CgogICAgbmV3SW5kaWNlc1tvZmZzZXQrK10gPSBzYW1wbGVGcmFtZUlkeDsKICB9CgogIGxpc3QuX2NvdW50ID0gb2Zmc2V0OwogIGxpc3QuX2luZGljZXMgPSBuZXdJbmRpY2VzOwogIGxpc3QuZ2V0UmF3SW5kZXggPSBnZXRSYXdJbmRleFdpdGhJbmRpY2VzOwogIHJldHVybiBsaXN0Owp9OwovKioKICogR2V0IG1vZGVsIG9mIG9uZSBkYXRhIGl0ZW0uCiAqCiAqIEBwYXJhbSB7bnVtYmVyfSBpZHgKICovCi8vIEZJWE1FIE1vZGVsIHByb3h5ID8KCgpsaXN0UHJvdG8uZ2V0SXRlbU1vZGVsID0gZnVuY3Rpb24gKGlkeCkgewogIHZhciBob3N0TW9kZWwgPSB0aGlzLmhvc3RNb2RlbDsKICByZXR1cm4gbmV3IE1vZGVsKHRoaXMuZ2V0UmF3RGF0YUl0ZW0oaWR4KSwgaG9zdE1vZGVsLCBob3N0TW9kZWwgJiYgaG9zdE1vZGVsLmVjTW9kZWwpOwp9OwovKioKICogQ3JlYXRlIGEgZGF0YSBkaWZmZXIKICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9IG90aGVyTGlzdAogKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0RhdGFEaWZmZXJ9CiAqLwoKCmxpc3RQcm90by5kaWZmID0gZnVuY3Rpb24gKG90aGVyTGlzdCkgewogIHZhciB0aGlzTGlzdCA9IHRoaXM7CiAgcmV0dXJuIG5ldyBEYXRhRGlmZmVyKG90aGVyTGlzdCA/IG90aGVyTGlzdC5nZXRJbmRpY2VzKCkgOiBbXSwgdGhpcy5nZXRJbmRpY2VzKCksIGZ1bmN0aW9uIChpZHgpIHsKICAgIHJldHVybiBnZXRJZChvdGhlckxpc3QsIGlkeCk7CiAgfSwgZnVuY3Rpb24gKGlkeCkgewogICAgcmV0dXJuIGdldElkKHRoaXNMaXN0LCBpZHgpOwogIH0pOwp9OwovKioKICogR2V0IHZpc3VhbCBwcm9wZXJ0eS4KICogQHBhcmFtIHtzdHJpbmd9IGtleQogKi8KCgpsaXN0UHJvdG8uZ2V0VmlzdWFsID0gZnVuY3Rpb24gKGtleSkgewogIHZhciB2aXN1YWwgPSB0aGlzLl92aXN1YWw7CiAgcmV0dXJuIHZpc3VhbCAmJiB2aXN1YWxba2V5XTsKfTsKLyoqCiAqIFNldCB2aXN1YWwgcHJvcGVydHkKICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBrZXkKICogQHBhcmFtIHsqfSBbdmFsdWVdCiAqCiAqIEBleGFtcGxlCiAqICBzZXRWaXN1YWwoJ2NvbG9yJywgY29sb3IpOwogKiAgc2V0VmlzdWFsKHsKICogICAgICAnY29sb3InOiBjb2xvcgogKiAgfSk7CiAqLwoKCmxpc3RQcm90by5zZXRWaXN1YWwgPSBmdW5jdGlvbiAoa2V5LCB2YWwpIHsKICBpZiAoaXNPYmplY3Qoa2V5KSkgewogICAgZm9yICh2YXIgbmFtZSBpbiBrZXkpIHsKICAgICAgaWYgKGtleS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkgewogICAgICAgIHRoaXMuc2V0VmlzdWFsKG5hbWUsIGtleVtuYW1lXSk7CiAgICAgIH0KICAgIH0KCiAgICByZXR1cm47CiAgfQoKICB0aGlzLl92aXN1YWwgPSB0aGlzLl92aXN1YWwgfHwge307CiAgdGhpcy5fdmlzdWFsW2tleV0gPSB2YWw7Cn07Ci8qKgogKiBTZXQgbGF5b3V0IHByb3BlcnR5LgogKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGtleQogKiBAcGFyYW0geyp9IFt2YWxdCiAqLwoKCmxpc3RQcm90by5zZXRMYXlvdXQgPSBmdW5jdGlvbiAoa2V5LCB2YWwpIHsKICBpZiAoaXNPYmplY3Qoa2V5KSkgewogICAgZm9yICh2YXIgbmFtZSBpbiBrZXkpIHsKICAgICAgaWYgKGtleS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkgewogICAgICAgIHRoaXMuc2V0TGF5b3V0KG5hbWUsIGtleVtuYW1lXSk7CiAgICAgIH0KICAgIH0KCiAgICByZXR1cm47CiAgfQoKICB0aGlzLl9sYXlvdXRba2V5XSA9IHZhbDsKfTsKLyoqCiAqIEdldCBsYXlvdXQgcHJvcGVydHkuCiAqIEBwYXJhbSAge3N0cmluZ30ga2V5LgogKiBAcmV0dXJuIHsqfQogKi8KCgpsaXN0UHJvdG8uZ2V0TGF5b3V0ID0gZnVuY3Rpb24gKGtleSkgewogIHJldHVybiB0aGlzLl9sYXlvdXRba2V5XTsKfTsKLyoqCiAqIEdldCBsYXlvdXQgb2Ygc2luZ2xlIGRhdGEgaXRlbQogKiBAcGFyYW0ge251bWJlcn0gaWR4CiAqLwoKCmxpc3RQcm90by5nZXRJdGVtTGF5b3V0ID0gZnVuY3Rpb24gKGlkeCkgewogIHJldHVybiB0aGlzLl9pdGVtTGF5b3V0c1tpZHhdOwp9OwovKioKICogU2V0IGxheW91dCBvZiBzaW5nbGUgZGF0YSBpdGVtCiAqIEBwYXJhbSB7bnVtYmVyfSBpZHgKICogQHBhcmFtIHtPYmplY3R9IGxheW91dAogKiBAcGFyYW0ge2Jvb2xlYW49fSBbbWVyZ2U9ZmFsc2VdCiAqLwoKCmxpc3RQcm90by5zZXRJdGVtTGF5b3V0ID0gZnVuY3Rpb24gKGlkeCwgbGF5b3V0LCBtZXJnZSkgewogIHRoaXMuX2l0ZW1MYXlvdXRzW2lkeF0gPSBtZXJnZSA/IHpyVXRpbC5leHRlbmQodGhpcy5faXRlbUxheW91dHNbaWR4XSB8fCB7fSwgbGF5b3V0KSA6IGxheW91dDsKfTsKLyoqCiAqIENsZWFyIGFsbCBsYXlvdXQgb2Ygc2luZ2xlIGRhdGEgaXRlbQogKi8KCgpsaXN0UHJvdG8uY2xlYXJJdGVtTGF5b3V0cyA9IGZ1bmN0aW9uICgpIHsKICB0aGlzLl9pdGVtTGF5b3V0cy5sZW5ndGggPSAwOwp9OwovKioKICogR2V0IHZpc3VhbCBwcm9wZXJ0eSBvZiBzaW5nbGUgZGF0YSBpdGVtCiAqIEBwYXJhbSB7bnVtYmVyfSBpZHgKICogQHBhcmFtIHtzdHJpbmd9IGtleQogKiBAcGFyYW0ge2Jvb2xlYW59IFtpZ25vcmVQYXJlbnQ9ZmFsc2VdCiAqLwoKCmxpc3RQcm90by5nZXRJdGVtVmlzdWFsID0gZnVuY3Rpb24gKGlkeCwga2V5LCBpZ25vcmVQYXJlbnQpIHsKICB2YXIgaXRlbVZpc3VhbCA9IHRoaXMuX2l0ZW1WaXN1YWxzW2lkeF07CiAgdmFyIHZhbCA9IGl0ZW1WaXN1YWwgJiYgaXRlbVZpc3VhbFtrZXldOwoKICBpZiAodmFsID09IG51bGwgJiYgIWlnbm9yZVBhcmVudCkgewogICAgLy8gVXNlIGdsb2JhbCB2aXN1YWwgcHJvcGVydHkKICAgIHJldHVybiB0aGlzLmdldFZpc3VhbChrZXkpOwogIH0KCiAgcmV0dXJuIHZhbDsKfTsKLyoqCiAqIFNldCB2aXN1YWwgcHJvcGVydHkgb2Ygc2luZ2xlIGRhdGEgaXRlbQogKgogKiBAcGFyYW0ge251bWJlcn0gaWR4CiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0ga2V5CiAqIEBwYXJhbSB7Kn0gW3ZhbHVlXQogKgogKiBAZXhhbXBsZQogKiAgc2V0SXRlbVZpc3VhbCgwLCAnY29sb3InLCBjb2xvcik7CiAqICBzZXRJdGVtVmlzdWFsKDAsIHsKICogICAgICAnY29sb3InOiBjb2xvcgogKiAgfSk7CiAqLwoKCmxpc3RQcm90by5zZXRJdGVtVmlzdWFsID0gZnVuY3Rpb24gKGlkeCwga2V5LCB2YWx1ZSkgewogIHZhciBpdGVtVmlzdWFsID0gdGhpcy5faXRlbVZpc3VhbHNbaWR4XSB8fCB7fTsKICB2YXIgaGFzSXRlbVZpc3VhbCA9IHRoaXMuaGFzSXRlbVZpc3VhbDsKICB0aGlzLl9pdGVtVmlzdWFsc1tpZHhdID0gaXRlbVZpc3VhbDsKCiAgaWYgKGlzT2JqZWN0KGtleSkpIHsKICAgIGZvciAodmFyIG5hbWUgaW4ga2V5KSB7CiAgICAgIGlmIChrZXkuaGFzT3duUHJvcGVydHkobmFtZSkpIHsKICAgICAgICBpdGVtVmlzdWFsW25hbWVdID0ga2V5W25hbWVdOwogICAgICAgIGhhc0l0ZW1WaXN1YWxbbmFtZV0gPSB0cnVlOwogICAgICB9CiAgICB9CgogICAgcmV0dXJuOwogIH0KCiAgaXRlbVZpc3VhbFtrZXldID0gdmFsdWU7CiAgaGFzSXRlbVZpc3VhbFtrZXldID0gdHJ1ZTsKfTsKLyoqCiAqIENsZWFyIGl0ZW1WaXN1YWxzIGFuZCBsaXN0IHZpc3VhbC4KICovCgoKbGlzdFByb3RvLmNsZWFyQWxsVmlzdWFsID0gZnVuY3Rpb24gKCkgewogIHRoaXMuX3Zpc3VhbCA9IHt9OwogIHRoaXMuX2l0ZW1WaXN1YWxzID0gW107CiAgdGhpcy5oYXNJdGVtVmlzdWFsID0ge307Cn07Cgp2YXIgc2V0SXRlbURhdGFBbmRTZXJpZXNJbmRleCA9IGZ1bmN0aW9uIHNldEl0ZW1EYXRhQW5kU2VyaWVzSW5kZXgoY2hpbGQpIHsKICBjaGlsZC5zZXJpZXNJbmRleCA9IHRoaXMuc2VyaWVzSW5kZXg7CiAgY2hpbGQuZGF0YUluZGV4ID0gdGhpcy5kYXRhSW5kZXg7CiAgY2hpbGQuZGF0YVR5cGUgPSB0aGlzLmRhdGFUeXBlOwp9OwovKioKICogU2V0IGdyYXBoaWMgZWxlbWVudCByZWxhdGl2ZSB0byBkYXRhLiBJdCBjYW4gYmUgc2V0IGFzIG51bGwKICogQHBhcmFtIHtudW1iZXJ9IGlkeAogKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IFtlbF0KICovCgoKbGlzdFByb3RvLnNldEl0ZW1HcmFwaGljRWwgPSBmdW5jdGlvbiAoaWR4LCBlbCkgewogIHZhciBob3N0TW9kZWwgPSB0aGlzLmhvc3RNb2RlbDsKCiAgaWYgKGVsKSB7CiAgICAvLyBBZGQgZGF0YSBpbmRleCBhbmQgc2VyaWVzIGluZGV4IGZvciBpbmRleGluZyB0aGUgZGF0YSBieSBlbGVtZW50CiAgICAvLyBVc2VmdWwgaW4gdG9vbHRpcAogICAgZWwuZGF0YUluZGV4ID0gaWR4OwogICAgZWwuZGF0YVR5cGUgPSB0aGlzLmRhdGFUeXBlOwogICAgZWwuc2VyaWVzSW5kZXggPSBob3N0TW9kZWwgJiYgaG9zdE1vZGVsLnNlcmllc0luZGV4OwoKICAgIGlmIChlbC50eXBlID09PSAnZ3JvdXAnKSB7CiAgICAgIGVsLnRyYXZlcnNlKHNldEl0ZW1EYXRhQW5kU2VyaWVzSW5kZXgsIGVsKTsKICAgIH0KICB9CgogIHRoaXMuX2dyYXBoaWNFbHNbaWR4XSA9IGVsOwp9OwovKioKICogQHBhcmFtIHtudW1iZXJ9IGlkeAogKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9FbGVtZW50fQogKi8KCgpsaXN0UHJvdG8uZ2V0SXRlbUdyYXBoaWNFbCA9IGZ1bmN0aW9uIChpZHgpIHsKICByZXR1cm4gdGhpcy5fZ3JhcGhpY0Vsc1tpZHhdOwp9OwovKioKICogQHBhcmFtIHtGdW5jdGlvbn0gY2IKICogQHBhcmFtIHsqfSBjb250ZXh0CiAqLwoKCmxpc3RQcm90by5lYWNoSXRlbUdyYXBoaWNFbCA9IGZ1bmN0aW9uIChjYiwgY29udGV4dCkgewogIHpyVXRpbC5lYWNoKHRoaXMuX2dyYXBoaWNFbHMsIGZ1bmN0aW9uIChlbCwgaWR4KSB7CiAgICBpZiAoZWwpIHsKICAgICAgY2IgJiYgY2IuY2FsbChjb250ZXh0LCBlbCwgaWR4KTsKICAgIH0KICB9KTsKfTsKLyoqCiAqIFNoYWxsb3cgY2xvbmUgYSBuZXcgbGlzdCBleGNlcHQgdmlzdWFsIGFuZCBsYXlvdXQgcHJvcGVydGllcywgYW5kIGdyYXBoIGVsZW1lbnRzLgogKiBOZXcgbGlzdCBvbmx5IGNoYW5nZSB0aGUgaW5kaWNlcy4KICovCgoKbGlzdFByb3RvLmNsb25lU2hhbGxvdyA9IGZ1bmN0aW9uIChsaXN0KSB7CiAgaWYgKCFsaXN0KSB7CiAgICB2YXIgZGltZW5zaW9uSW5mb0xpc3QgPSB6clV0aWwubWFwKHRoaXMuZGltZW5zaW9ucywgdGhpcy5nZXREaW1lbnNpb25JbmZvLCB0aGlzKTsKICAgIGxpc3QgPSBuZXcgTGlzdChkaW1lbnNpb25JbmZvTGlzdCwgdGhpcy5ob3N0TW9kZWwpOwogIH0gLy8gRklYTUUKCgogIGxpc3QuX3N0b3JhZ2UgPSB0aGlzLl9zdG9yYWdlOwogIHRyYW5zZmVyUHJvcGVydGllcyhsaXN0LCB0aGlzKTsgLy8gQ2xvbmUgd2lsbCBub3QgY2hhbmdlIHRoZSBkYXRhIGV4dGVudCBhbmQgaW5kaWNlcwoKICBpZiAodGhpcy5faW5kaWNlcykgewogICAgdmFyIEN0b3IgPSB0aGlzLl9pbmRpY2VzLmNvbnN0cnVjdG9yOwogICAgbGlzdC5faW5kaWNlcyA9IG5ldyBDdG9yKHRoaXMuX2luZGljZXMpOwogIH0gZWxzZSB7CiAgICBsaXN0Ll9pbmRpY2VzID0gbnVsbDsKICB9CgogIGxpc3QuZ2V0UmF3SW5kZXggPSBsaXN0Ll9pbmRpY2VzID8gZ2V0UmF3SW5kZXhXaXRoSW5kaWNlcyA6IGdldFJhd0luZGV4V2l0aG91dEluZGljZXM7CiAgcmV0dXJuIGxpc3Q7Cn07Ci8qKgogKiBXcmFwIHNvbWUgbWV0aG9kIHRvIGFkZCBtb3JlIGZlYXR1cmUKICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUKICogQHBhcmFtIHtGdW5jdGlvbn0gaW5qZWN0RnVuY3Rpb24KICovCgoKbGlzdFByb3RvLndyYXBNZXRob2QgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgaW5qZWN0RnVuY3Rpb24pIHsKICB2YXIgb3JpZ2luYWxNZXRob2QgPSB0aGlzW21ldGhvZE5hbWVdOwoKICBpZiAodHlwZW9mIG9yaWdpbmFsTWV0aG9kICE9PSAnZnVuY3Rpb24nKSB7CiAgICByZXR1cm47CiAgfQoKICB0aGlzLl9fd3JhcHBlZE1ldGhvZHMgPSB0aGlzLl9fd3JhcHBlZE1ldGhvZHMgfHwgW107CgogIHRoaXMuX193cmFwcGVkTWV0aG9kcy5wdXNoKG1ldGhvZE5hbWUpOwoKICB0aGlzW21ldGhvZE5hbWVdID0gZnVuY3Rpb24gKCkgewogICAgdmFyIHJlcyA9IG9yaWdpbmFsTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICByZXR1cm4gaW5qZWN0RnVuY3Rpb24uYXBwbHkodGhpcywgW3Jlc10uY29uY2F0KHpyVXRpbC5zbGljZShhcmd1bWVudHMpKSk7CiAgfTsKfTsgLy8gTWV0aG9kcyB0aGF0IGNyZWF0ZSBhIG5ldyBsaXN0IGJhc2VkIG9uIHRoaXMgbGlzdCBzaG91bGQgYmUgbGlzdGVkIGhlcmUuCi8vIE5vdGljZSB0aGF0IHRob3NlIG1ldGhvZCBzaG91bGQgYFJFVFVSTmAgdGhlIG5ldyBsaXN0LgoKCmxpc3RQcm90by5UUkFOU0ZFUkFCTEVfTUVUSE9EUyA9IFsnY2xvbmVTaGFsbG93JywgJ2Rvd25TYW1wbGUnLCAnbWFwJ107IC8vIE1ldGhvZHMgdGhhdCBjaGFuZ2UgaW5kaWNlcyBvZiB0aGlzIGxpc3Qgc2hvdWxkIGJlIGxpc3RlZCBoZXJlLgoKbGlzdFByb3RvLkNIQU5HQUJMRV9NRVRIT0RTID0gWydmaWx0ZXJTZWxmJywgJ3NlbGVjdFJhbmdlJ107CnZhciBfZGVmYXVsdCA9IExpc3Q7Cm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7"},{"version":3,"sources":["/Users/id-repair/Documents/SEOL/4c-dashboard/node_modules/echarts/lib/data/List.js"],"names":["_config","require","__DEV__","zrUtil","Model","DataDiffer","Source","_dataProvider","defaultDimValueGetters","DefaultDataProvider","_dimensionHelper","summarizeDimensions","DataDimensionInfo","isObject","UNDEFINED","INDEX_NOT_FOUND","ID_PREFIX","dataCtors","Float64Array","Array","Int32Array","CtorUint32Array","Uint32Array","CtorInt32Array","CtorUint16Array","Uint16Array","getIndicesCtor","list","_rawCount","cloneChunk","originalChunk","Ctor","constructor","slice","TRANSFERABLE_PROPERTIES","CLONE_PROPERTIES","transferProperties","target","source","each","concat","__wrappedMethods","propName","hasOwnProperty","clone","_calculationInfo","extend","List","dimensions","hostModel","dimensionInfos","dimensionNames","invertedIndicesMap","i","length","dimensionInfo","isString","name","dimensionName","type","coordDim","coordDimIndex","otherDims","push","index","createInvertedIndices","_dimensionInfos","dataType","_indices","_count","_storage","_nameList","_idList","_optionModels","_visual","_layout","_itemVisuals","hasItemVisual","_itemLayouts","_graphicEls","_chunkSize","_chunkCount","_rawData","_rawExtent","_extent","_approximateExtent","_dimensionsSummary","_invertedIndicesMap","userOutput","listProto","prototype","hasItemOption","getDimension","dim","isNaN","getDimensionInfo","getDimensionsOnCoord","dataDimsOnCoord","mapDimension","idx","dimensionsSummary","encodeFirstDimNotExtra","dims","encode","initData","data","nameList","dimValueGetter","notProvider","isInstance","isArrayLike","_nameRepeatCount","defaultDimValueGetter","getSource","sourceFormat","_dimValueGetter","_dimValueGetterArrayRows","arrayRows","_initDataFromProvider","count","pure","getProvider","appendData","rawData","start","end","persistent","appendValues","values","names","chunkSize","storage","dimLen","rawExtent","Math","max","originalChunkCount","getInitialExtent","prepareChunks","emptyDataItem","sourceIdx","chunkIndex","floor","chunkOffset","k","val","dimRawExtent","prepareInvertedIndex","dimensionInfoMap","idList","nameRepeatCount","nameDimIdx","dimInfo","itemName","_nameDimIdx","itemId","_idDimIdx","dataItem","getItem","dimStorage","nameDim","nameDimChunk","ordinalMeta","categories","id","clean","chunkCount","DataCtor","lastChunkIndex","resizeChunkArray","newStore","min","j","invertedIndices","get","getRawValueFromStore","dimIndex","rawIndex","chunk","getIndices","newIndices","indices","thisCount","buffer","NaN","getRawIndex","chunkStore","value","getByRawIndex","rawIdx","dimStore","_getFast","getValues","isArray","len","hasValue","getDataExtent","dimData","initialExtent","currEnd","useRaw","dimExtent","getApproximateExtent","setApproximateExtent","extent","getCalculationInfo","key","setCalculationInfo","getSum","sum","getMedian","dimDataArray","sortedDimDataArray","sort","a","b","rawIndexOf","indexOfName","getName","indexOfRawIndex","rawDataIndex","left","right","mid","indicesOfNearest","maxDistance","nearestIndices","Infinity","minDist","minDiff","nearestIndicesLen","diff","dist","abs","getRawIndexWithoutIndices","getRawIndexWithIndices","getRawDataItem","getId","normalizeDimensions","validateDimensions","console","error","cb","context","contextCompat","map","dimSize","call","apply","filterSelf","offset","dim0","keep","selectRange","range","originalCount","quickFinished","chunkStorage","dimStorage2","min2","max2","chunkStorage2","val2","dimk","mapArray","result","arguments","cloneListForMapAndSample","original","excludeDimensions","allDimensions","originalStorage","indexOf","cloneDimStore","originalDimStore","newDimStore","tmpRetValue","dataCount","dataIndex","retValue","rawExtentOnDim","downSample","dimension","rate","sampleValue","sampleIndex","targetStorage","frameValues","frameSize","dataIdx","originalChunkIndex","originalChunkOffset","sampleFrameIdx","sampleChunkIndex","sampleChunkOffset","getItemModel","ecModel","otherList","thisList","getVisual","visual","setVisual","setLayout","getLayout","getItemLayout","setItemLayout","layout","merge","clearItemLayouts","getItemVisual","ignoreParent","itemVisual","setItemVisual","clearAllVisual","setItemDataAndSeriesIndex","child","seriesIndex","setItemGraphicEl","el","traverse","getItemGraphicEl","eachItemGraphicEl","cloneShallow","dimensionInfoList","wrapMethod","methodName","injectFunction","originalMethod","res","TRANSFERABLE_METHODS","CHANGABLE_METHODS","_default","module","exports"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar _config = require(\"../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar Model = require(\"../model/Model\");\n\nvar DataDiffer = require(\"./DataDiffer\");\n\nvar Source = require(\"./Source\");\n\nvar _dataProvider = require(\"./helper/dataProvider\");\n\nvar defaultDimValueGetters = _dataProvider.defaultDimValueGetters;\nvar DefaultDataProvider = _dataProvider.DefaultDataProvider;\n\nvar _dimensionHelper = require(\"./helper/dimensionHelper\");\n\nvar summarizeDimensions = _dimensionHelper.summarizeDimensions;\n\nvar DataDimensionInfo = require(\"./DataDimensionInfo\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/* global Float64Array, Int32Array, Uint32Array, Uint16Array */\n\n/**\n * List for data storage\n * @module echarts/data/List\n */\nvar isObject = zrUtil.isObject;\nvar UNDEFINED = 'undefined';\nvar INDEX_NOT_FOUND = -1; // Use prefix to avoid index to be the same as otherIdList[idx],\n// which will cause weird udpate animation.\n\nvar ID_PREFIX = 'e\\0\\0';\nvar dataCtors = {\n  'float': typeof Float64Array === UNDEFINED ? Array : Float64Array,\n  'int': typeof Int32Array === UNDEFINED ? Array : Int32Array,\n  // Ordinal data type can be string or int\n  'ordinal': Array,\n  'number': Array,\n  'time': Array\n}; // Caution: MUST not use `new CtorUint32Array(arr, 0, len)`, because the Ctor of array is\n// different from the Ctor of typed array.\n\nvar CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;\nvar CtorInt32Array = typeof Int32Array === UNDEFINED ? Array : Int32Array;\nvar CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;\n\nfunction getIndicesCtor(list) {\n  // The possible max value in this._indicies is always this._rawCount despite of filtering.\n  return list._rawCount > 65535 ? CtorUint32Array : CtorUint16Array;\n}\n\nfunction cloneChunk(originalChunk) {\n  var Ctor = originalChunk.constructor; // Only shallow clone is enough when Array.\n\n  return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);\n}\n\nvar TRANSFERABLE_PROPERTIES = ['hasItemOption', '_nameList', '_idList', '_invertedIndicesMap', '_rawData', '_chunkSize', '_chunkCount', '_dimValueGetter', '_count', '_rawCount', '_nameDimIdx', '_idDimIdx'];\nvar CLONE_PROPERTIES = ['_extent', '_approximateExtent', '_rawExtent'];\n\nfunction transferProperties(target, source) {\n  zrUtil.each(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function (propName) {\n    if (source.hasOwnProperty(propName)) {\n      target[propName] = source[propName];\n    }\n  });\n  target.__wrappedMethods = source.__wrappedMethods;\n  zrUtil.each(CLONE_PROPERTIES, function (propName) {\n    target[propName] = zrUtil.clone(source[propName]);\n  });\n  target._calculationInfo = zrUtil.extend(source._calculationInfo);\n}\n/**\n * @constructor\n * @alias module:echarts/data/List\n *\n * @param {Array.<string|Object|module:data/DataDimensionInfo>} dimensions\n *      For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].\n *      Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n * @param {module:echarts/model/Model} hostModel\n */\n\n\nvar List = function (dimensions, hostModel) {\n  dimensions = dimensions || ['x', 'y'];\n  var dimensionInfos = {};\n  var dimensionNames = [];\n  var invertedIndicesMap = {};\n\n  for (var i = 0; i < dimensions.length; i++) {\n    // Use the original dimensions[i], where other flag props may exists.\n    var dimensionInfo = dimensions[i];\n\n    if (zrUtil.isString(dimensionInfo)) {\n      dimensionInfo = new DataDimensionInfo({\n        name: dimensionInfo\n      });\n    } else if (!(dimensionInfo instanceof DataDimensionInfo)) {\n      dimensionInfo = new DataDimensionInfo(dimensionInfo);\n    }\n\n    var dimensionName = dimensionInfo.name;\n    dimensionInfo.type = dimensionInfo.type || 'float';\n\n    if (!dimensionInfo.coordDim) {\n      dimensionInfo.coordDim = dimensionName;\n      dimensionInfo.coordDimIndex = 0;\n    }\n\n    dimensionInfo.otherDims = dimensionInfo.otherDims || {};\n    dimensionNames.push(dimensionName);\n    dimensionInfos[dimensionName] = dimensionInfo;\n    dimensionInfo.index = i;\n\n    if (dimensionInfo.createInvertedIndices) {\n      invertedIndicesMap[dimensionName] = [];\n    }\n  }\n  /**\n   * @readOnly\n   * @type {Array.<string>}\n   */\n\n\n  this.dimensions = dimensionNames;\n  /**\n   * Infomation of each data dimension, like data type.\n   * @type {Object}\n   */\n\n  this._dimensionInfos = dimensionInfos;\n  /**\n   * @type {module:echarts/model/Model}\n   */\n\n  this.hostModel = hostModel;\n  /**\n   * @type {module:echarts/model/Model}\n   */\n\n  this.dataType;\n  /**\n   * Indices stores the indices of data subset after filtered.\n   * This data subset will be used in chart.\n   * @type {Array.<number>}\n   * @readOnly\n   */\n\n  this._indices = null;\n  this._count = 0;\n  this._rawCount = 0;\n  /**\n   * Data storage\n   * @type {Object.<key, Array.<TypedArray|Array>>}\n   * @private\n   */\n\n  this._storage = {};\n  /**\n   * @type {Array.<string>}\n   */\n\n  this._nameList = [];\n  /**\n   * @type {Array.<string>}\n   */\n\n  this._idList = [];\n  /**\n   * Models of data option is stored sparse for optimizing memory cost\n   * @type {Array.<module:echarts/model/Model>}\n   * @private\n   */\n\n  this._optionModels = [];\n  /**\n   * Global visual properties after visual coding\n   * @type {Object}\n   * @private\n   */\n\n  this._visual = {};\n  /**\n   * Globel layout properties.\n   * @type {Object}\n   * @private\n   */\n\n  this._layout = {};\n  /**\n   * Item visual properties after visual coding\n   * @type {Array.<Object>}\n   * @private\n   */\n\n  this._itemVisuals = [];\n  /**\n   * Key: visual type, Value: boolean\n   * @type {Object}\n   * @readOnly\n   */\n\n  this.hasItemVisual = {};\n  /**\n   * Item layout properties after layout\n   * @type {Array.<Object>}\n   * @private\n   */\n\n  this._itemLayouts = [];\n  /**\n   * Graphic elemnents\n   * @type {Array.<module:zrender/Element>}\n   * @private\n   */\n\n  this._graphicEls = [];\n  /**\n   * Max size of each chunk.\n   * @type {number}\n   * @private\n   */\n\n  this._chunkSize = 1e5;\n  /**\n   * @type {number}\n   * @private\n   */\n\n  this._chunkCount = 0;\n  /**\n   * @type {Array.<Array|Object>}\n   * @private\n   */\n\n  this._rawData;\n  /**\n   * Raw extent will not be cloned, but only transfered.\n   * It will not be calculated util needed.\n   * key: dim,\n   * value: {end: number, extent: Array.<number>}\n   * @type {Object}\n   * @private\n   */\n\n  this._rawExtent = {};\n  /**\n   * @type {Object}\n   * @private\n   */\n\n  this._extent = {};\n  /**\n   * key: dim\n   * value: extent\n   * @type {Object}\n   * @private\n   */\n\n  this._approximateExtent = {};\n  /**\n   * Cache summary info for fast visit. See \"dimensionHelper\".\n   * @type {Object}\n   * @private\n   */\n\n  this._dimensionsSummary = summarizeDimensions(this);\n  /**\n   * @type {Object.<Array|TypedArray>}\n   * @private\n   */\n\n  this._invertedIndicesMap = invertedIndicesMap;\n  /**\n   * @type {Object}\n   * @private\n   */\n\n  this._calculationInfo = {};\n  /**\n   * User output info of this data.\n   * DO NOT use it in other places!\n   *\n   * When preparing user params for user callbacks, we have\n   * to clone these inner data structures to prevent users\n   * from modifying them to effect built-in logic. And for\n   * performance consideration we make this `userOutput` to\n   * avoid clone them too many times.\n   *\n   * @type {Object}\n   * @readOnly\n   */\n\n  this.userOutput = this._dimensionsSummary.userOutput;\n};\n\nvar listProto = List.prototype;\nlistProto.type = 'list';\n/**\n * If each data item has it's own option\n * @type {boolean}\n */\n\nlistProto.hasItemOption = true;\n/**\n * The meanings of the input parameter `dim`:\n *\n * + If dim is a number (e.g., `1`), it means the index of the dimension.\n *   For example, `getDimension(0)` will return 'x' or 'lng' or 'radius'.\n * + If dim is a number-like string (e.g., `\"1\"`):\n *     + If there is the same concrete dim name defined in `this.dimensions`, it means that concrete name.\n *     + If not, it will be converted to a number, which means the index of the dimension.\n *        (why? because of the backward compatbility. We have been tolerating number-like string in\n *        dimension setting, although now it seems that it is not a good idea.)\n *     For example, `visualMap[i].dimension: \"1\"` is the same meaning as `visualMap[i].dimension: 1`,\n *     if no dimension name is defined as `\"1\"`.\n * + If dim is a not-number-like string, it means the concrete dim name.\n *   For example, it can be be default name `\"x\"`, `\"y\"`, `\"z\"`, `\"lng\"`, `\"lat\"`, `\"angle\"`, `\"radius\"`,\n *   or customized in `dimensions` property of option like `\"age\"`.\n *\n * Get dimension name\n * @param {string|number} dim See above.\n * @return {string} Concrete dim name.\n */\n\nlistProto.getDimension = function (dim) {\n  if (typeof dim === 'number' // If being a number-like string but not being defined a dimension name.\n  || !isNaN(dim) && !this._dimensionInfos.hasOwnProperty(dim)) {\n    dim = this.dimensions[dim];\n  }\n\n  return dim;\n};\n/**\n * Get type and calculation info of particular dimension\n * @param {string|number} dim\n *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n */\n\n\nlistProto.getDimensionInfo = function (dim) {\n  // Do not clone, because there may be categories in dimInfo.\n  return this._dimensionInfos[this.getDimension(dim)];\n};\n/**\n * @return {Array.<string>} concrete dimension name list on coord.\n */\n\n\nlistProto.getDimensionsOnCoord = function () {\n  return this._dimensionsSummary.dataDimsOnCoord.slice();\n};\n/**\n * @param {string} coordDim\n * @param {number} [idx] A coordDim may map to more than one data dim.\n *        If idx is `true`, return a array of all mapped dims.\n *        If idx is not specified, return the first dim not extra.\n * @return {string|Array.<string>} concrete data dim.\n *        If idx is number, and not found, return null/undefined.\n *        If idx is `true`, and not found, return empty array (always return array).\n */\n\n\nlistProto.mapDimension = function (coordDim, idx) {\n  var dimensionsSummary = this._dimensionsSummary;\n\n  if (idx == null) {\n    return dimensionsSummary.encodeFirstDimNotExtra[coordDim];\n  }\n\n  var dims = dimensionsSummary.encode[coordDim];\n  return idx === true // always return array if idx is `true`\n  ? (dims || []).slice() : dims && dims[idx];\n};\n/**\n * Initialize from data\n * @param {Array.<Object|number|Array>} data source or data or data provider.\n * @param {Array.<string>} [nameLIst] The name of a datum is used on data diff and\n *        default label/tooltip.\n *        A name can be specified in encode.itemName,\n *        or dataItem.name (only for series option data),\n *        or provided in nameList from outside.\n * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number\n */\n\n\nlistProto.initData = function (data, nameList, dimValueGetter) {\n  var notProvider = Source.isInstance(data) || zrUtil.isArrayLike(data);\n\n  if (notProvider) {\n    data = new DefaultDataProvider(data, this.dimensions.length);\n  }\n\n  this._rawData = data; // Clear\n\n  this._storage = {};\n  this._indices = null;\n  this._nameList = nameList || [];\n  this._idList = [];\n  this._nameRepeatCount = {};\n\n  if (!dimValueGetter) {\n    this.hasItemOption = false;\n  }\n  /**\n   * @readOnly\n   */\n\n\n  this.defaultDimValueGetter = defaultDimValueGetters[this._rawData.getSource().sourceFormat]; // Default dim value getter\n\n  this._dimValueGetter = dimValueGetter = dimValueGetter || this.defaultDimValueGetter;\n  this._dimValueGetterArrayRows = defaultDimValueGetters.arrayRows; // Reset raw extent.\n\n  this._rawExtent = {};\n\n  this._initDataFromProvider(0, data.count()); // If data has no item option.\n\n\n  if (data.pure) {\n    this.hasItemOption = false;\n  }\n};\n\nlistProto.getProvider = function () {\n  return this._rawData;\n};\n/**\n * Caution: Can be only called on raw data (before `this._indices` created).\n */\n\n\nlistProto.appendData = function (data) {\n  var rawData = this._rawData;\n  var start = this.count();\n  rawData.appendData(data);\n  var end = rawData.count();\n\n  if (!rawData.persistent) {\n    end += start;\n  }\n\n  this._initDataFromProvider(start, end);\n};\n/**\n * Caution: Can be only called on raw data (before `this._indices` created).\n * This method does not modify `rawData` (`dataProvider`), but only\n * add values to storage.\n *\n * The final count will be increased by `Math.max(values.length, names.length)`.\n *\n * @param {Array.<Array.<*>>} values That is the SourceType: 'arrayRows', like\n *        [\n *            [12, 33, 44],\n *            [NaN, 43, 1],\n *            ['-', 'asdf', 0]\n *        ]\n *        Each item is exaclty cooresponding to a dimension.\n * @param {Array.<string>} [names]\n */\n\n\nlistProto.appendValues = function (values, names) {\n  var chunkSize = this._chunkSize;\n  var storage = this._storage;\n  var dimensions = this.dimensions;\n  var dimLen = dimensions.length;\n  var rawExtent = this._rawExtent;\n  var start = this.count();\n  var end = start + Math.max(values.length, names ? names.length : 0);\n  var originalChunkCount = this._chunkCount;\n\n  for (var i = 0; i < dimLen; i++) {\n    var dim = dimensions[i];\n\n    if (!rawExtent[dim]) {\n      rawExtent[dim] = getInitialExtent();\n    }\n\n    if (!storage[dim]) {\n      storage[dim] = [];\n    }\n\n    prepareChunks(storage, this._dimensionInfos[dim], chunkSize, originalChunkCount, end);\n    this._chunkCount = storage[dim].length;\n  }\n\n  var emptyDataItem = new Array(dimLen);\n\n  for (var idx = start; idx < end; idx++) {\n    var sourceIdx = idx - start;\n    var chunkIndex = Math.floor(idx / chunkSize);\n    var chunkOffset = idx % chunkSize; // Store the data by dimensions\n\n    for (var k = 0; k < dimLen; k++) {\n      var dim = dimensions[k];\n\n      var val = this._dimValueGetterArrayRows(values[sourceIdx] || emptyDataItem, dim, sourceIdx, k);\n\n      storage[dim][chunkIndex][chunkOffset] = val;\n      var dimRawExtent = rawExtent[dim];\n      val < dimRawExtent[0] && (dimRawExtent[0] = val);\n      val > dimRawExtent[1] && (dimRawExtent[1] = val);\n    }\n\n    if (names) {\n      this._nameList[idx] = names[sourceIdx];\n    }\n  }\n\n  this._rawCount = this._count = end; // Reset data extent\n\n  this._extent = {};\n  prepareInvertedIndex(this);\n};\n\nlistProto._initDataFromProvider = function (start, end) {\n  // Optimize.\n  if (start >= end) {\n    return;\n  }\n\n  var chunkSize = this._chunkSize;\n  var rawData = this._rawData;\n  var storage = this._storage;\n  var dimensions = this.dimensions;\n  var dimLen = dimensions.length;\n  var dimensionInfoMap = this._dimensionInfos;\n  var nameList = this._nameList;\n  var idList = this._idList;\n  var rawExtent = this._rawExtent;\n  var nameRepeatCount = this._nameRepeatCount = {};\n  var nameDimIdx;\n  var originalChunkCount = this._chunkCount;\n\n  for (var i = 0; i < dimLen; i++) {\n    var dim = dimensions[i];\n\n    if (!rawExtent[dim]) {\n      rawExtent[dim] = getInitialExtent();\n    }\n\n    var dimInfo = dimensionInfoMap[dim];\n\n    if (dimInfo.otherDims.itemName === 0) {\n      nameDimIdx = this._nameDimIdx = i;\n    }\n\n    if (dimInfo.otherDims.itemId === 0) {\n      this._idDimIdx = i;\n    }\n\n    if (!storage[dim]) {\n      storage[dim] = [];\n    }\n\n    prepareChunks(storage, dimInfo, chunkSize, originalChunkCount, end);\n    this._chunkCount = storage[dim].length;\n  }\n\n  var dataItem = new Array(dimLen);\n\n  for (var idx = start; idx < end; idx++) {\n    // NOTICE: Try not to write things into dataItem\n    dataItem = rawData.getItem(idx, dataItem); // Each data item is value\n    // [1, 2]\n    // 2\n    // Bar chart, line chart which uses category axis\n    // only gives the 'y' value. 'x' value is the indices of category\n    // Use a tempValue to normalize the value to be a (x, y) value\n\n    var chunkIndex = Math.floor(idx / chunkSize);\n    var chunkOffset = idx % chunkSize; // Store the data by dimensions\n\n    for (var k = 0; k < dimLen; k++) {\n      var dim = dimensions[k];\n      var dimStorage = storage[dim][chunkIndex]; // PENDING NULL is empty or zero\n\n      var val = this._dimValueGetter(dataItem, dim, idx, k);\n\n      dimStorage[chunkOffset] = val;\n      var dimRawExtent = rawExtent[dim];\n      val < dimRawExtent[0] && (dimRawExtent[0] = val);\n      val > dimRawExtent[1] && (dimRawExtent[1] = val);\n    } // ??? FIXME not check by pure but sourceFormat?\n    // TODO refactor these logic.\n\n\n    if (!rawData.pure) {\n      var name = nameList[idx];\n\n      if (dataItem && name == null) {\n        // If dataItem is {name: ...}, it has highest priority.\n        // That is appropriate for many common cases.\n        if (dataItem.name != null) {\n          // There is no other place to persistent dataItem.name,\n          // so save it to nameList.\n          nameList[idx] = name = dataItem.name;\n        } else if (nameDimIdx != null) {\n          var nameDim = dimensions[nameDimIdx];\n          var nameDimChunk = storage[nameDim][chunkIndex];\n\n          if (nameDimChunk) {\n            name = nameDimChunk[chunkOffset];\n            var ordinalMeta = dimensionInfoMap[nameDim].ordinalMeta;\n\n            if (ordinalMeta && ordinalMeta.categories.length) {\n              name = ordinalMeta.categories[name];\n            }\n          }\n        }\n      } // Try using the id in option\n      // id or name is used on dynamical data, mapping old and new items.\n\n\n      var id = dataItem == null ? null : dataItem.id;\n\n      if (id == null && name != null) {\n        // Use name as id and add counter to avoid same name\n        nameRepeatCount[name] = nameRepeatCount[name] || 0;\n        id = name;\n\n        if (nameRepeatCount[name] > 0) {\n          id += '__ec__' + nameRepeatCount[name];\n        }\n\n        nameRepeatCount[name]++;\n      }\n\n      id != null && (idList[idx] = id);\n    }\n  }\n\n  if (!rawData.persistent && rawData.clean) {\n    // Clean unused data if data source is typed array.\n    rawData.clean();\n  }\n\n  this._rawCount = this._count = end; // Reset data extent\n\n  this._extent = {};\n  prepareInvertedIndex(this);\n};\n\nfunction prepareChunks(storage, dimInfo, chunkSize, chunkCount, end) {\n  var DataCtor = dataCtors[dimInfo.type];\n  var lastChunkIndex = chunkCount - 1;\n  var dim = dimInfo.name;\n  var resizeChunkArray = storage[dim][lastChunkIndex];\n\n  if (resizeChunkArray && resizeChunkArray.length < chunkSize) {\n    var newStore = new DataCtor(Math.min(end - lastChunkIndex * chunkSize, chunkSize)); // The cost of the copy is probably inconsiderable\n    // within the initial chunkSize.\n\n    for (var j = 0; j < resizeChunkArray.length; j++) {\n      newStore[j] = resizeChunkArray[j];\n    }\n\n    storage[dim][lastChunkIndex] = newStore;\n  } // Create new chunks.\n\n\n  for (var k = chunkCount * chunkSize; k < end; k += chunkSize) {\n    storage[dim].push(new DataCtor(Math.min(end - k, chunkSize)));\n  }\n}\n\nfunction prepareInvertedIndex(list) {\n  var invertedIndicesMap = list._invertedIndicesMap;\n  zrUtil.each(invertedIndicesMap, function (invertedIndices, dim) {\n    var dimInfo = list._dimensionInfos[dim]; // Currently, only dimensions that has ordinalMeta can create inverted indices.\n\n    var ordinalMeta = dimInfo.ordinalMeta;\n\n    if (ordinalMeta) {\n      invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array(ordinalMeta.categories.length); // The default value of TypedArray is 0. To avoid miss\n      // mapping to 0, we should set it as INDEX_NOT_FOUND.\n\n      for (var i = 0; i < invertedIndices.length; i++) {\n        invertedIndices[i] = INDEX_NOT_FOUND;\n      }\n\n      for (var i = 0; i < list._count; i++) {\n        // Only support the case that all values are distinct.\n        invertedIndices[list.get(dim, i)] = i;\n      }\n    }\n  });\n}\n\nfunction getRawValueFromStore(list, dimIndex, rawIndex) {\n  var val;\n\n  if (dimIndex != null) {\n    var chunkSize = list._chunkSize;\n    var chunkIndex = Math.floor(rawIndex / chunkSize);\n    var chunkOffset = rawIndex % chunkSize;\n    var dim = list.dimensions[dimIndex];\n    var chunk = list._storage[dim][chunkIndex];\n\n    if (chunk) {\n      val = chunk[chunkOffset];\n      var ordinalMeta = list._dimensionInfos[dim].ordinalMeta;\n\n      if (ordinalMeta && ordinalMeta.categories.length) {\n        val = ordinalMeta.categories[val];\n      }\n    }\n  }\n\n  return val;\n}\n/**\n * @return {number}\n */\n\n\nlistProto.count = function () {\n  return this._count;\n};\n\nlistProto.getIndices = function () {\n  var newIndices;\n  var indices = this._indices;\n\n  if (indices) {\n    var Ctor = indices.constructor;\n    var thisCount = this._count; // `new Array(a, b, c)` is different from `new Uint32Array(a, b, c)`.\n\n    if (Ctor === Array) {\n      newIndices = new Ctor(thisCount);\n\n      for (var i = 0; i < thisCount; i++) {\n        newIndices[i] = indices[i];\n      }\n    } else {\n      newIndices = new Ctor(indices.buffer, 0, thisCount);\n    }\n  } else {\n    var Ctor = getIndicesCtor(this);\n    var newIndices = new Ctor(this.count());\n\n    for (var i = 0; i < newIndices.length; i++) {\n      newIndices[i] = i;\n    }\n  }\n\n  return newIndices;\n};\n/**\n * Get value. Return NaN if idx is out of range.\n * @param {string} dim Dim must be concrete name.\n * @param {number} idx\n * @param {boolean} stack\n * @return {number}\n */\n\n\nlistProto.get = function (dim, idx\n/*, stack */\n) {\n  if (!(idx >= 0 && idx < this._count)) {\n    return NaN;\n  }\n\n  var storage = this._storage;\n\n  if (!storage[dim]) {\n    // TODO Warn ?\n    return NaN;\n  }\n\n  idx = this.getRawIndex(idx);\n  var chunkIndex = Math.floor(idx / this._chunkSize);\n  var chunkOffset = idx % this._chunkSize;\n  var chunkStore = storage[dim][chunkIndex];\n  var value = chunkStore[chunkOffset]; // FIXME ordinal data type is not stackable\n  // if (stack) {\n  //     var dimensionInfo = this._dimensionInfos[dim];\n  //     if (dimensionInfo && dimensionInfo.stackable) {\n  //         var stackedOn = this.stackedOn;\n  //         while (stackedOn) {\n  //             // Get no stacked data of stacked on\n  //             var stackedValue = stackedOn.get(dim, idx);\n  //             // Considering positive stack, negative stack and empty data\n  //             if ((value >= 0 && stackedValue > 0)  // Positive stack\n  //                 || (value <= 0 && stackedValue < 0) // Negative stack\n  //             ) {\n  //                 value += stackedValue;\n  //             }\n  //             stackedOn = stackedOn.stackedOn;\n  //         }\n  //     }\n  // }\n\n  return value;\n};\n/**\n * @param {string} dim concrete dim\n * @param {number} rawIndex\n * @return {number|string}\n */\n\n\nlistProto.getByRawIndex = function (dim, rawIdx) {\n  if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {\n    return NaN;\n  }\n\n  var dimStore = this._storage[dim];\n\n  if (!dimStore) {\n    // TODO Warn ?\n    return NaN;\n  }\n\n  var chunkIndex = Math.floor(rawIdx / this._chunkSize);\n  var chunkOffset = rawIdx % this._chunkSize;\n  var chunkStore = dimStore[chunkIndex];\n  return chunkStore[chunkOffset];\n};\n/**\n * FIXME Use `get` on chrome maybe slow(in filterSelf and selectRange).\n * Hack a much simpler _getFast\n * @private\n */\n\n\nlistProto._getFast = function (dim, rawIdx) {\n  var chunkIndex = Math.floor(rawIdx / this._chunkSize);\n  var chunkOffset = rawIdx % this._chunkSize;\n  var chunkStore = this._storage[dim][chunkIndex];\n  return chunkStore[chunkOffset];\n};\n/**\n * Get value for multi dimensions.\n * @param {Array.<string>} [dimensions] If ignored, using all dimensions.\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.getValues = function (dimensions, idx\n/*, stack */\n) {\n  var values = [];\n\n  if (!zrUtil.isArray(dimensions)) {\n    // stack = idx;\n    idx = dimensions;\n    dimensions = this.dimensions;\n  }\n\n  for (var i = 0, len = dimensions.length; i < len; i++) {\n    values.push(this.get(dimensions[i], idx\n    /*, stack */\n    ));\n  }\n\n  return values;\n};\n/**\n * If value is NaN. Inlcuding '-'\n * Only check the coord dimensions.\n * @param {string} dim\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.hasValue = function (idx) {\n  var dataDimsOnCoord = this._dimensionsSummary.dataDimsOnCoord;\n\n  for (var i = 0, len = dataDimsOnCoord.length; i < len; i++) {\n    // Ordinal type originally can be string or number.\n    // But when an ordinal type is used on coord, it can\n    // not be string but only number. So we can also use isNaN.\n    if (isNaN(this.get(dataDimsOnCoord[i], idx))) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Get extent of data in one dimension\n * @param {string} dim\n * @param {boolean} stack\n */\n\n\nlistProto.getDataExtent = function (dim\n/*, stack */\n) {\n  // Make sure use concrete dim as cache name.\n  dim = this.getDimension(dim);\n  var dimData = this._storage[dim];\n  var initialExtent = getInitialExtent(); // stack = !!((stack || false) && this.getCalculationInfo(dim));\n\n  if (!dimData) {\n    return initialExtent;\n  } // Make more strict checkings to ensure hitting cache.\n\n\n  var currEnd = this.count(); // var cacheName = [dim, !!stack].join('_');\n  // var cacheName = dim;\n  // Consider the most cases when using data zoom, `getDataExtent`\n  // happened before filtering. We cache raw extent, which is not\n  // necessary to be cleared and recalculated when restore data.\n\n  var useRaw = !this._indices; // && !stack;\n\n  var dimExtent;\n\n  if (useRaw) {\n    return this._rawExtent[dim].slice();\n  }\n\n  dimExtent = this._extent[dim];\n\n  if (dimExtent) {\n    return dimExtent.slice();\n  }\n\n  dimExtent = initialExtent;\n  var min = dimExtent[0];\n  var max = dimExtent[1];\n\n  for (var i = 0; i < currEnd; i++) {\n    // var value = stack ? this.get(dim, i, true) : this._getFast(dim, this.getRawIndex(i));\n    var value = this._getFast(dim, this.getRawIndex(i));\n\n    value < min && (min = value);\n    value > max && (max = value);\n  }\n\n  dimExtent = [min, max];\n  this._extent[dim] = dimExtent;\n  return dimExtent;\n};\n/**\n * Optimize for the scenario that data is filtered by a given extent.\n * Consider that if data amount is more than hundreds of thousand,\n * extent calculation will cost more than 10ms and the cache will\n * be erased because of the filtering.\n */\n\n\nlistProto.getApproximateExtent = function (dim\n/*, stack */\n) {\n  dim = this.getDimension(dim);\n  return this._approximateExtent[dim] || this.getDataExtent(dim\n  /*, stack */\n  );\n};\n\nlistProto.setApproximateExtent = function (extent, dim\n/*, stack */\n) {\n  dim = this.getDimension(dim);\n  this._approximateExtent[dim] = extent.slice();\n};\n/**\n * @param {string} key\n * @return {*}\n */\n\n\nlistProto.getCalculationInfo = function (key) {\n  return this._calculationInfo[key];\n};\n/**\n * @param {string|Object} key or k-v object\n * @param {*} [value]\n */\n\n\nlistProto.setCalculationInfo = function (key, value) {\n  isObject(key) ? zrUtil.extend(this._calculationInfo, key) : this._calculationInfo[key] = value;\n};\n/**\n * Get sum of data in one dimension\n * @param {string} dim\n */\n\n\nlistProto.getSum = function (dim\n/*, stack */\n) {\n  var dimData = this._storage[dim];\n  var sum = 0;\n\n  if (dimData) {\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var value = this.get(dim, i\n      /*, stack */\n      );\n\n      if (!isNaN(value)) {\n        sum += value;\n      }\n    }\n  }\n\n  return sum;\n};\n/**\n * Get median of data in one dimension\n * @param {string} dim\n */\n\n\nlistProto.getMedian = function (dim\n/*, stack */\n) {\n  var dimDataArray = []; // map all data of one dimension\n\n  this.each(dim, function (val, idx) {\n    if (!isNaN(val)) {\n      dimDataArray.push(val);\n    }\n  }); // TODO\n  // Use quick select?\n  // immutability & sort\n\n  var sortedDimDataArray = [].concat(dimDataArray).sort(function (a, b) {\n    return a - b;\n  });\n  var len = this.count(); // calculate median\n\n  return len === 0 ? 0 : len % 2 === 1 ? sortedDimDataArray[(len - 1) / 2] : (sortedDimDataArray[len / 2] + sortedDimDataArray[len / 2 - 1]) / 2;\n}; // /**\n//  * Retreive the index with given value\n//  * @param {string} dim Concrete dimension.\n//  * @param {number} value\n//  * @return {number}\n//  */\n// Currently incorrect: should return dataIndex but not rawIndex.\n// Do not fix it until this method is to be used somewhere.\n// FIXME Precision of float value\n// listProto.indexOf = function (dim, value) {\n//     var storage = this._storage;\n//     var dimData = storage[dim];\n//     var chunkSize = this._chunkSize;\n//     if (dimData) {\n//         for (var i = 0, len = this.count(); i < len; i++) {\n//             var chunkIndex = Math.floor(i / chunkSize);\n//             var chunkOffset = i % chunkSize;\n//             if (dimData[chunkIndex][chunkOffset] === value) {\n//                 return i;\n//             }\n//         }\n//     }\n//     return -1;\n// };\n\n/**\n * Only support the dimension which inverted index created.\n * Do not support other cases until required.\n * @param {string} concrete dim\n * @param {number|string} value\n * @return {number} rawIndex\n */\n\n\nlistProto.rawIndexOf = function (dim, value) {\n  var invertedIndices = dim && this._invertedIndicesMap[dim];\n  var rawIndex = invertedIndices[value];\n\n  if (rawIndex == null || isNaN(rawIndex)) {\n    return INDEX_NOT_FOUND;\n  }\n\n  return rawIndex;\n};\n/**\n * Retreive the index with given name\n * @param {number} idx\n * @param {number} name\n * @return {number}\n */\n\n\nlistProto.indexOfName = function (name) {\n  for (var i = 0, len = this.count(); i < len; i++) {\n    if (this.getName(i) === name) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n/**\n * Retreive the index with given raw data index\n * @param {number} idx\n * @param {number} name\n * @return {number}\n */\n\n\nlistProto.indexOfRawIndex = function (rawIndex) {\n  if (rawIndex >= this._rawCount || rawIndex < 0) {\n    return -1;\n  }\n\n  if (!this._indices) {\n    return rawIndex;\n  } // Indices are ascending\n\n\n  var indices = this._indices; // If rawIndex === dataIndex\n\n  var rawDataIndex = indices[rawIndex];\n\n  if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {\n    return rawIndex;\n  }\n\n  var left = 0;\n  var right = this._count - 1;\n\n  while (left <= right) {\n    var mid = (left + right) / 2 | 0;\n\n    if (indices[mid] < rawIndex) {\n      left = mid + 1;\n    } else if (indices[mid] > rawIndex) {\n      right = mid - 1;\n    } else {\n      return mid;\n    }\n  }\n\n  return -1;\n};\n/**\n * Retreive the index of nearest value\n * @param {string} dim\n * @param {number} value\n * @param {number} [maxDistance=Infinity]\n * @return {Array.<number>} If and only if multiple indices has\n *        the same value, they are put to the result.\n */\n\n\nlistProto.indicesOfNearest = function (dim, value, maxDistance) {\n  var storage = this._storage;\n  var dimData = storage[dim];\n  var nearestIndices = [];\n\n  if (!dimData) {\n    return nearestIndices;\n  }\n\n  if (maxDistance == null) {\n    maxDistance = Infinity;\n  }\n\n  var minDist = Infinity;\n  var minDiff = -1;\n  var nearestIndicesLen = 0; // Check the test case of `test/ut/spec/data/List.js`.\n\n  for (var i = 0, len = this.count(); i < len; i++) {\n    var diff = value - this.get(dim, i);\n    var dist = Math.abs(diff);\n\n    if (dist <= maxDistance) {\n      // When the `value` is at the middle of `this.get(dim, i)` and `this.get(dim, i+1)`,\n      // we'd better not push both of them to `nearestIndices`, otherwise it is easy to\n      // get more than one item in `nearestIndices` (more specifically, in `tooltip`).\n      // So we chose the one that `diff >= 0` in this csae.\n      // But if `this.get(dim, i)` and `this.get(dim, j)` get the same value, both of them\n      // should be push to `nearestIndices`.\n      if (dist < minDist || dist === minDist && diff >= 0 && minDiff < 0) {\n        minDist = dist;\n        minDiff = diff;\n        nearestIndicesLen = 0;\n      }\n\n      if (diff === minDiff) {\n        nearestIndices[nearestIndicesLen++] = i;\n      }\n    }\n  }\n\n  nearestIndices.length = nearestIndicesLen;\n  return nearestIndices;\n};\n/**\n * Get raw data index\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.getRawIndex = getRawIndexWithoutIndices;\n\nfunction getRawIndexWithoutIndices(idx) {\n  return idx;\n}\n\nfunction getRawIndexWithIndices(idx) {\n  if (idx < this._count && idx >= 0) {\n    return this._indices[idx];\n  }\n\n  return -1;\n}\n/**\n * Get raw data item\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.getRawDataItem = function (idx) {\n  if (!this._rawData.persistent) {\n    var val = [];\n\n    for (var i = 0; i < this.dimensions.length; i++) {\n      var dim = this.dimensions[i];\n      val.push(this.get(dim, idx));\n    }\n\n    return val;\n  } else {\n    return this._rawData.getItem(this.getRawIndex(idx));\n  }\n};\n/**\n * @param {number} idx\n * @param {boolean} [notDefaultIdx=false]\n * @return {string}\n */\n\n\nlistProto.getName = function (idx) {\n  var rawIndex = this.getRawIndex(idx);\n  return this._nameList[rawIndex] || getRawValueFromStore(this, this._nameDimIdx, rawIndex) || '';\n};\n/**\n * @param {number} idx\n * @param {boolean} [notDefaultIdx=false]\n * @return {string}\n */\n\n\nlistProto.getId = function (idx) {\n  return getId(this, this.getRawIndex(idx));\n};\n\nfunction getId(list, rawIndex) {\n  var id = list._idList[rawIndex];\n\n  if (id == null) {\n    id = getRawValueFromStore(list, list._idDimIdx, rawIndex);\n  }\n\n  if (id == null) {\n    // FIXME Check the usage in graph, should not use prefix.\n    id = ID_PREFIX + rawIndex;\n  }\n\n  return id;\n}\n\nfunction normalizeDimensions(dimensions) {\n  if (!zrUtil.isArray(dimensions)) {\n    dimensions = [dimensions];\n  }\n\n  return dimensions;\n}\n\nfunction validateDimensions(list, dims) {\n  for (var i = 0; i < dims.length; i++) {\n    // stroage may be empty when no data, so use\n    // dimensionInfos to check.\n    if (!list._dimensionInfos[dims[i]]) {\n      console.error('Unkown dimension ' + dims[i]);\n    }\n  }\n}\n/**\n * Data iteration\n * @param {string|Array.<string>}\n * @param {Function} cb\n * @param {*} [context=this]\n *\n * @example\n *  list.each('x', function (x, idx) {});\n *  list.each(['x', 'y'], function (x, y, idx) {});\n *  list.each(function (idx) {})\n */\n\n\nlistProto.each = function (dims, cb, context, contextCompat) {\n  'use strict';\n\n  if (!this._count) {\n    return;\n  }\n\n  if (typeof dims === 'function') {\n    contextCompat = context;\n    context = cb;\n    cb = dims;\n    dims = [];\n  } // contextCompat just for compat echarts3\n\n\n  context = context || contextCompat || this;\n  dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);\n  var dimSize = dims.length;\n\n  for (var i = 0; i < this.count(); i++) {\n    // Simple optimization\n    switch (dimSize) {\n      case 0:\n        cb.call(context, i);\n        break;\n\n      case 1:\n        cb.call(context, this.get(dims[0], i), i);\n        break;\n\n      case 2:\n        cb.call(context, this.get(dims[0], i), this.get(dims[1], i), i);\n        break;\n\n      default:\n        var k = 0;\n        var value = [];\n\n        for (; k < dimSize; k++) {\n          value[k] = this.get(dims[k], i);\n        } // Index\n\n\n        value[k] = i;\n        cb.apply(context, value);\n    }\n  }\n};\n/**\n * Data filter\n * @param {string|Array.<string>}\n * @param {Function} cb\n * @param {*} [context=this]\n */\n\n\nlistProto.filterSelf = function (dimensions, cb, context, contextCompat) {\n  'use strict';\n\n  if (!this._count) {\n    return;\n  }\n\n  if (typeof dimensions === 'function') {\n    contextCompat = context;\n    context = cb;\n    cb = dimensions;\n    dimensions = [];\n  } // contextCompat just for compat echarts3\n\n\n  context = context || contextCompat || this;\n  dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n  var count = this.count();\n  var Ctor = getIndicesCtor(this);\n  var newIndices = new Ctor(count);\n  var value = [];\n  var dimSize = dimensions.length;\n  var offset = 0;\n  var dim0 = dimensions[0];\n\n  for (var i = 0; i < count; i++) {\n    var keep;\n    var rawIdx = this.getRawIndex(i); // Simple optimization\n\n    if (dimSize === 0) {\n      keep = cb.call(context, i);\n    } else if (dimSize === 1) {\n      var val = this._getFast(dim0, rawIdx);\n\n      keep = cb.call(context, val, i);\n    } else {\n      for (var k = 0; k < dimSize; k++) {\n        value[k] = this._getFast(dim0, rawIdx);\n      }\n\n      value[k] = i;\n      keep = cb.apply(context, value);\n    }\n\n    if (keep) {\n      newIndices[offset++] = rawIdx;\n    }\n  } // Set indices after filtered.\n\n\n  if (offset < count) {\n    this._indices = newIndices;\n  }\n\n  this._count = offset; // Reset data extent\n\n  this._extent = {};\n  this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n  return this;\n};\n/**\n * Select data in range. (For optimization of filter)\n * (Manually inline code, support 5 million data filtering in data zoom.)\n */\n\n\nlistProto.selectRange = function (range) {\n  'use strict';\n\n  if (!this._count) {\n    return;\n  }\n\n  var dimensions = [];\n\n  for (var dim in range) {\n    if (range.hasOwnProperty(dim)) {\n      dimensions.push(dim);\n    }\n  }\n\n  var dimSize = dimensions.length;\n\n  if (!dimSize) {\n    return;\n  }\n\n  var originalCount = this.count();\n  var Ctor = getIndicesCtor(this);\n  var newIndices = new Ctor(originalCount);\n  var offset = 0;\n  var dim0 = dimensions[0];\n  var min = range[dim0][0];\n  var max = range[dim0][1];\n  var quickFinished = false;\n\n  if (!this._indices) {\n    // Extreme optimization for common case. About 2x faster in chrome.\n    var idx = 0;\n\n    if (dimSize === 1) {\n      var dimStorage = this._storage[dimensions[0]];\n\n      for (var k = 0; k < this._chunkCount; k++) {\n        var chunkStorage = dimStorage[k];\n        var len = Math.min(this._count - k * this._chunkSize, this._chunkSize);\n\n        for (var i = 0; i < len; i++) {\n          var val = chunkStorage[i]; // NaN will not be filtered. Consider the case, in line chart, empty\n          // value indicates the line should be broken. But for the case like\n          // scatter plot, a data item with empty value will not be rendered,\n          // but the axis extent may be effected if some other dim of the data\n          // item has value. Fortunately it is not a significant negative effect.\n\n          if (val >= min && val <= max || isNaN(val)) {\n            newIndices[offset++] = idx;\n          }\n\n          idx++;\n        }\n      }\n\n      quickFinished = true;\n    } else if (dimSize === 2) {\n      var dimStorage = this._storage[dim0];\n      var dimStorage2 = this._storage[dimensions[1]];\n      var min2 = range[dimensions[1]][0];\n      var max2 = range[dimensions[1]][1];\n\n      for (var k = 0; k < this._chunkCount; k++) {\n        var chunkStorage = dimStorage[k];\n        var chunkStorage2 = dimStorage2[k];\n        var len = Math.min(this._count - k * this._chunkSize, this._chunkSize);\n\n        for (var i = 0; i < len; i++) {\n          var val = chunkStorage[i];\n          var val2 = chunkStorage2[i]; // Do not filter NaN, see comment above.\n\n          if ((val >= min && val <= max || isNaN(val)) && (val2 >= min2 && val2 <= max2 || isNaN(val2))) {\n            newIndices[offset++] = idx;\n          }\n\n          idx++;\n        }\n      }\n\n      quickFinished = true;\n    }\n  }\n\n  if (!quickFinished) {\n    if (dimSize === 1) {\n      for (var i = 0; i < originalCount; i++) {\n        var rawIndex = this.getRawIndex(i);\n\n        var val = this._getFast(dim0, rawIndex); // Do not filter NaN, see comment above.\n\n\n        if (val >= min && val <= max || isNaN(val)) {\n          newIndices[offset++] = rawIndex;\n        }\n      }\n    } else {\n      for (var i = 0; i < originalCount; i++) {\n        var keep = true;\n        var rawIndex = this.getRawIndex(i);\n\n        for (var k = 0; k < dimSize; k++) {\n          var dimk = dimensions[k];\n\n          var val = this._getFast(dim, rawIndex); // Do not filter NaN, see comment above.\n\n\n          if (val < range[dimk][0] || val > range[dimk][1]) {\n            keep = false;\n          }\n        }\n\n        if (keep) {\n          newIndices[offset++] = this.getRawIndex(i);\n        }\n      }\n    }\n  } // Set indices after filtered.\n\n\n  if (offset < originalCount) {\n    this._indices = newIndices;\n  }\n\n  this._count = offset; // Reset data extent\n\n  this._extent = {};\n  this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n  return this;\n};\n/**\n * Data mapping to a plain array\n * @param {string|Array.<string>} [dimensions]\n * @param {Function} cb\n * @param {*} [context=this]\n * @return {Array}\n */\n\n\nlistProto.mapArray = function (dimensions, cb, context, contextCompat) {\n  'use strict';\n\n  if (typeof dimensions === 'function') {\n    contextCompat = context;\n    context = cb;\n    cb = dimensions;\n    dimensions = [];\n  } // contextCompat just for compat echarts3\n\n\n  context = context || contextCompat || this;\n  var result = [];\n  this.each(dimensions, function () {\n    result.push(cb && cb.apply(this, arguments));\n  }, context);\n  return result;\n}; // Data in excludeDimensions is copied, otherwise transfered.\n\n\nfunction cloneListForMapAndSample(original, excludeDimensions) {\n  var allDimensions = original.dimensions;\n  var list = new List(zrUtil.map(allDimensions, original.getDimensionInfo, original), original.hostModel); // FIXME If needs stackedOn, value may already been stacked\n\n  transferProperties(list, original);\n  var storage = list._storage = {};\n  var originalStorage = original._storage; // Init storage\n\n  for (var i = 0; i < allDimensions.length; i++) {\n    var dim = allDimensions[i];\n\n    if (originalStorage[dim]) {\n      // Notice that we do not reset invertedIndicesMap here, becuase\n      // there is no scenario of mapping or sampling ordinal dimension.\n      if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n        storage[dim] = cloneDimStore(originalStorage[dim]);\n        list._rawExtent[dim] = getInitialExtent();\n        list._extent[dim] = null;\n      } else {\n        // Direct reference for other dimensions\n        storage[dim] = originalStorage[dim];\n      }\n    }\n  }\n\n  return list;\n}\n\nfunction cloneDimStore(originalDimStore) {\n  var newDimStore = new Array(originalDimStore.length);\n\n  for (var j = 0; j < originalDimStore.length; j++) {\n    newDimStore[j] = cloneChunk(originalDimStore[j]);\n  }\n\n  return newDimStore;\n}\n\nfunction getInitialExtent() {\n  return [Infinity, -Infinity];\n}\n/**\n * Data mapping to a new List with given dimensions\n * @param {string|Array.<string>} dimensions\n * @param {Function} cb\n * @param {*} [context=this]\n * @return {Array}\n */\n\n\nlistProto.map = function (dimensions, cb, context, contextCompat) {\n  'use strict'; // contextCompat just for compat echarts3\n\n  context = context || contextCompat || this;\n  dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n  var list = cloneListForMapAndSample(this, dimensions); // Following properties are all immutable.\n  // So we can reference to the same value\n\n  list._indices = this._indices;\n  list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n  var storage = list._storage;\n  var tmpRetValue = [];\n  var chunkSize = this._chunkSize;\n  var dimSize = dimensions.length;\n  var dataCount = this.count();\n  var values = [];\n  var rawExtent = list._rawExtent;\n\n  for (var dataIndex = 0; dataIndex < dataCount; dataIndex++) {\n    for (var dimIndex = 0; dimIndex < dimSize; dimIndex++) {\n      values[dimIndex] = this.get(dimensions[dimIndex], dataIndex\n      /*, stack */\n      );\n    }\n\n    values[dimSize] = dataIndex;\n    var retValue = cb && cb.apply(context, values);\n\n    if (retValue != null) {\n      // a number or string (in oridinal dimension)?\n      if (typeof retValue !== 'object') {\n        tmpRetValue[0] = retValue;\n        retValue = tmpRetValue;\n      }\n\n      var rawIndex = this.getRawIndex(dataIndex);\n      var chunkIndex = Math.floor(rawIndex / chunkSize);\n      var chunkOffset = rawIndex % chunkSize;\n\n      for (var i = 0; i < retValue.length; i++) {\n        var dim = dimensions[i];\n        var val = retValue[i];\n        var rawExtentOnDim = rawExtent[dim];\n        var dimStore = storage[dim];\n\n        if (dimStore) {\n          dimStore[chunkIndex][chunkOffset] = val;\n        }\n\n        if (val < rawExtentOnDim[0]) {\n          rawExtentOnDim[0] = val;\n        }\n\n        if (val > rawExtentOnDim[1]) {\n          rawExtentOnDim[1] = val;\n        }\n      }\n    }\n  }\n\n  return list;\n};\n/**\n * Large data down sampling on given dimension\n * @param {string} dimension\n * @param {number} rate\n * @param {Function} sampleValue\n * @param {Function} sampleIndex Sample index for name and id\n */\n\n\nlistProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n  var list = cloneListForMapAndSample(this, [dimension]);\n  var targetStorage = list._storage;\n  var frameValues = [];\n  var frameSize = Math.floor(1 / rate);\n  var dimStore = targetStorage[dimension];\n  var len = this.count();\n  var chunkSize = this._chunkSize;\n  var rawExtentOnDim = list._rawExtent[dimension];\n  var newIndices = new (getIndicesCtor(this))(len);\n  var offset = 0;\n\n  for (var i = 0; i < len; i += frameSize) {\n    // Last frame\n    if (frameSize > len - i) {\n      frameSize = len - i;\n      frameValues.length = frameSize;\n    }\n\n    for (var k = 0; k < frameSize; k++) {\n      var dataIdx = this.getRawIndex(i + k);\n      var originalChunkIndex = Math.floor(dataIdx / chunkSize);\n      var originalChunkOffset = dataIdx % chunkSize;\n      frameValues[k] = dimStore[originalChunkIndex][originalChunkOffset];\n    }\n\n    var value = sampleValue(frameValues);\n    var sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len - 1));\n    var sampleChunkIndex = Math.floor(sampleFrameIdx / chunkSize);\n    var sampleChunkOffset = sampleFrameIdx % chunkSize; // Only write value on the filtered data\n\n    dimStore[sampleChunkIndex][sampleChunkOffset] = value;\n\n    if (value < rawExtentOnDim[0]) {\n      rawExtentOnDim[0] = value;\n    }\n\n    if (value > rawExtentOnDim[1]) {\n      rawExtentOnDim[1] = value;\n    }\n\n    newIndices[offset++] = sampleFrameIdx;\n  }\n\n  list._count = offset;\n  list._indices = newIndices;\n  list.getRawIndex = getRawIndexWithIndices;\n  return list;\n};\n/**\n * Get model of one data item.\n *\n * @param {number} idx\n */\n// FIXME Model proxy ?\n\n\nlistProto.getItemModel = function (idx) {\n  var hostModel = this.hostModel;\n  return new Model(this.getRawDataItem(idx), hostModel, hostModel && hostModel.ecModel);\n};\n/**\n * Create a data differ\n * @param {module:echarts/data/List} otherList\n * @return {module:echarts/data/DataDiffer}\n */\n\n\nlistProto.diff = function (otherList) {\n  var thisList = this;\n  return new DataDiffer(otherList ? otherList.getIndices() : [], this.getIndices(), function (idx) {\n    return getId(otherList, idx);\n  }, function (idx) {\n    return getId(thisList, idx);\n  });\n};\n/**\n * Get visual property.\n * @param {string} key\n */\n\n\nlistProto.getVisual = function (key) {\n  var visual = this._visual;\n  return visual && visual[key];\n};\n/**\n * Set visual property\n * @param {string|Object} key\n * @param {*} [value]\n *\n * @example\n *  setVisual('color', color);\n *  setVisual({\n *      'color': color\n *  });\n */\n\n\nlistProto.setVisual = function (key, val) {\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        this.setVisual(name, key[name]);\n      }\n    }\n\n    return;\n  }\n\n  this._visual = this._visual || {};\n  this._visual[key] = val;\n};\n/**\n * Set layout property.\n * @param {string|Object} key\n * @param {*} [val]\n */\n\n\nlistProto.setLayout = function (key, val) {\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        this.setLayout(name, key[name]);\n      }\n    }\n\n    return;\n  }\n\n  this._layout[key] = val;\n};\n/**\n * Get layout property.\n * @param  {string} key.\n * @return {*}\n */\n\n\nlistProto.getLayout = function (key) {\n  return this._layout[key];\n};\n/**\n * Get layout of single data item\n * @param {number} idx\n */\n\n\nlistProto.getItemLayout = function (idx) {\n  return this._itemLayouts[idx];\n};\n/**\n * Set layout of single data item\n * @param {number} idx\n * @param {Object} layout\n * @param {boolean=} [merge=false]\n */\n\n\nlistProto.setItemLayout = function (idx, layout, merge) {\n  this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;\n};\n/**\n * Clear all layout of single data item\n */\n\n\nlistProto.clearItemLayouts = function () {\n  this._itemLayouts.length = 0;\n};\n/**\n * Get visual property of single data item\n * @param {number} idx\n * @param {string} key\n * @param {boolean} [ignoreParent=false]\n */\n\n\nlistProto.getItemVisual = function (idx, key, ignoreParent) {\n  var itemVisual = this._itemVisuals[idx];\n  var val = itemVisual && itemVisual[key];\n\n  if (val == null && !ignoreParent) {\n    // Use global visual property\n    return this.getVisual(key);\n  }\n\n  return val;\n};\n/**\n * Set visual property of single data item\n *\n * @param {number} idx\n * @param {string|Object} key\n * @param {*} [value]\n *\n * @example\n *  setItemVisual(0, 'color', color);\n *  setItemVisual(0, {\n *      'color': color\n *  });\n */\n\n\nlistProto.setItemVisual = function (idx, key, value) {\n  var itemVisual = this._itemVisuals[idx] || {};\n  var hasItemVisual = this.hasItemVisual;\n  this._itemVisuals[idx] = itemVisual;\n\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        itemVisual[name] = key[name];\n        hasItemVisual[name] = true;\n      }\n    }\n\n    return;\n  }\n\n  itemVisual[key] = value;\n  hasItemVisual[key] = true;\n};\n/**\n * Clear itemVisuals and list visual.\n */\n\n\nlistProto.clearAllVisual = function () {\n  this._visual = {};\n  this._itemVisuals = [];\n  this.hasItemVisual = {};\n};\n\nvar setItemDataAndSeriesIndex = function (child) {\n  child.seriesIndex = this.seriesIndex;\n  child.dataIndex = this.dataIndex;\n  child.dataType = this.dataType;\n};\n/**\n * Set graphic element relative to data. It can be set as null\n * @param {number} idx\n * @param {module:zrender/Element} [el]\n */\n\n\nlistProto.setItemGraphicEl = function (idx, el) {\n  var hostModel = this.hostModel;\n\n  if (el) {\n    // Add data index and series index for indexing the data by element\n    // Useful in tooltip\n    el.dataIndex = idx;\n    el.dataType = this.dataType;\n    el.seriesIndex = hostModel && hostModel.seriesIndex;\n\n    if (el.type === 'group') {\n      el.traverse(setItemDataAndSeriesIndex, el);\n    }\n  }\n\n  this._graphicEls[idx] = el;\n};\n/**\n * @param {number} idx\n * @return {module:zrender/Element}\n */\n\n\nlistProto.getItemGraphicEl = function (idx) {\n  return this._graphicEls[idx];\n};\n/**\n * @param {Function} cb\n * @param {*} context\n */\n\n\nlistProto.eachItemGraphicEl = function (cb, context) {\n  zrUtil.each(this._graphicEls, function (el, idx) {\n    if (el) {\n      cb && cb.call(context, el, idx);\n    }\n  });\n};\n/**\n * Shallow clone a new list except visual and layout properties, and graph elements.\n * New list only change the indices.\n */\n\n\nlistProto.cloneShallow = function (list) {\n  if (!list) {\n    var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);\n    list = new List(dimensionInfoList, this.hostModel);\n  } // FIXME\n\n\n  list._storage = this._storage;\n  transferProperties(list, this); // Clone will not change the data extent and indices\n\n  if (this._indices) {\n    var Ctor = this._indices.constructor;\n    list._indices = new Ctor(this._indices);\n  } else {\n    list._indices = null;\n  }\n\n  list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n  return list;\n};\n/**\n * Wrap some method to add more feature\n * @param {string} methodName\n * @param {Function} injectFunction\n */\n\n\nlistProto.wrapMethod = function (methodName, injectFunction) {\n  var originalMethod = this[methodName];\n\n  if (typeof originalMethod !== 'function') {\n    return;\n  }\n\n  this.__wrappedMethods = this.__wrappedMethods || [];\n\n  this.__wrappedMethods.push(methodName);\n\n  this[methodName] = function () {\n    var res = originalMethod.apply(this, arguments);\n    return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n  };\n}; // Methods that create a new list based on this list should be listed here.\n// Notice that those method should `RETURN` the new list.\n\n\nlistProto.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map']; // Methods that change indices of this list should be listed here.\n\nlistProto.CHANGABLE_METHODS = ['filterSelf', 'selectRange'];\nvar _default = List;\nmodule.exports = _default;"]}]}