{"remainingRequest":"/Users/id-repair/Documents/SEOL/4c-dashboard/node_modules/babel-loader/lib/index.js!/Users/id-repair/Documents/SEOL/4c-dashboard/node_modules/echarts/lib/component/marker/markerHelper.js","dependencies":[{"path":"/Users/id-repair/Documents/SEOL/4c-dashboard/node_modules/echarts/lib/component/marker/markerHelper.js","mtime":499162500000},{"path":"/Users/id-repair/Documents/SEOL/4c-dashboard/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/id-repair/Documents/SEOL/4c-dashboard/node_modules/babel-loader/lib/index.js","mtime":315532800000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:cmVxdWlyZSgiY29yZS1qcy9tb2R1bGVzL2VzLm51bWJlci50by1maXhlZC5qcyIpOwoKcmVxdWlyZSgiY29yZS1qcy9tb2R1bGVzL2VzLmZ1bmN0aW9uLm5hbWUuanMiKTsKCi8qCiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZQoqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZQoqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uCiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZQoqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUKKiAiTGljZW5zZSIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlCiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdAoqCiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAKKgoqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywKKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbgoqICJBUyBJUyIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWQoqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZQoqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMKKiB1bmRlciB0aGUgTGljZW5zZS4KKi8KdmFyIHpyVXRpbCA9IHJlcXVpcmUoInpyZW5kZXIvbGliL2NvcmUvdXRpbCIpOwoKdmFyIG51bWJlclV0aWwgPSByZXF1aXJlKCIuLi8uLi91dGlsL251bWJlciIpOwoKdmFyIF9kYXRhU3RhY2tIZWxwZXIgPSByZXF1aXJlKCIuLi8uLi9kYXRhL2hlbHBlci9kYXRhU3RhY2tIZWxwZXIiKTsKCnZhciBpc0RpbWVuc2lvblN0YWNrZWQgPSBfZGF0YVN0YWNrSGVscGVyLmlzRGltZW5zaW9uU3RhY2tlZDsKLyoKKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lCiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlCiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24KKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlCiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZQoqICJMaWNlbnNlIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2UKKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0CioKKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMAoqCiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLAoqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuCiogIkFTIElTIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZCiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlCiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucwoqIHVuZGVyIHRoZSBMaWNlbnNlLgoqLwoKdmFyIGluZGV4T2YgPSB6clV0aWwuaW5kZXhPZjsKCmZ1bmN0aW9uIGhhc1hPclkoaXRlbSkgewogIHJldHVybiAhKGlzTmFOKHBhcnNlRmxvYXQoaXRlbS54KSkgJiYgaXNOYU4ocGFyc2VGbG9hdChpdGVtLnkpKSk7Cn0KCmZ1bmN0aW9uIGhhc1hBbmRZKGl0ZW0pIHsKICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQoaXRlbS54KSkgJiYgIWlzTmFOKHBhcnNlRmxvYXQoaXRlbS55KSk7Cn0gLy8gTWFrZSBpdCBzaW1wbGUsIGRvIG5vdCB2aXNpdCBhbGwgc3RhY2tlZCB2YWx1ZSB0byBjb3VudCBwcmVjaXNpb24uCi8vIGZ1bmN0aW9uIGdldFByZWNpc2lvbihkYXRhLCB2YWx1ZUF4aXNEaW0sIGRhdGFJbmRleCkgewovLyAgICAgdmFyIHByZWNpc2lvbiA9IC0xOwovLyAgICAgdmFyIHN0YWNrZWREaW0gPSBkYXRhLm1hcERpbWVuc2lvbih2YWx1ZUF4aXNEaW0pOwovLyAgICAgZG8gewovLyAgICAgICAgIHByZWNpc2lvbiA9IE1hdGgubWF4KAovLyAgICAgICAgICAgICBudW1iZXJVdGlsLmdldFByZWNpc2lvbihkYXRhLmdldChzdGFja2VkRGltLCBkYXRhSW5kZXgpKSwKLy8gICAgICAgICAgICAgcHJlY2lzaW9uCi8vICAgICAgICAgKTsKLy8gICAgICAgICB2YXIgc3RhY2tlZE9uU2VyaWVzID0gZGF0YS5nZXRDYWxjdWxhdGlvbkluZm8oJ3N0YWNrZWRPblNlcmllcycpOwovLyAgICAgICAgIGlmIChzdGFja2VkT25TZXJpZXMpIHsKLy8gICAgICAgICAgICAgdmFyIGJ5VmFsdWUgPSBkYXRhLmdldChkYXRhLmdldENhbGN1bGF0aW9uSW5mbygnc3RhY2tlZEJ5RGltZW5zaW9uJyksIGRhdGFJbmRleCk7Ci8vICAgICAgICAgICAgIGRhdGEgPSBzdGFja2VkT25TZXJpZXMuZ2V0RGF0YSgpOwovLyAgICAgICAgICAgICBkYXRhSW5kZXggPSBkYXRhLmluZGV4T2YoZGF0YS5nZXRDYWxjdWxhdGlvbkluZm8oJ3N0YWNrZWRCeURpbWVuc2lvbicpLCBieVZhbHVlKTsKLy8gICAgICAgICAgICAgc3RhY2tlZERpbSA9IGRhdGEuZ2V0Q2FsY3VsYXRpb25JbmZvKCdzdGFja2VkRGltZW5zaW9uJyk7Ci8vICAgICAgICAgfQovLyAgICAgICAgIGVsc2UgewovLyAgICAgICAgICAgICBkYXRhID0gbnVsbDsKLy8gICAgICAgICB9Ci8vICAgICB9IHdoaWxlIChkYXRhKTsKLy8gICAgIHJldHVybiBwcmVjaXNpb247Ci8vIH0KCgpmdW5jdGlvbiBtYXJrZXJUeXBlQ2FsY3VsYXRvcldpdGhFeHRlbnQobWxUeXBlLCBkYXRhLCBvdGhlckRhdGFEaW0sIHRhcmdldERhdGFEaW0sIG90aGVyQ29vcmRJbmRleCwgdGFyZ2V0Q29vcmRJbmRleCkgewogIHZhciBjb29yZEFyciA9IFtdOwogIHZhciBzdGFja2VkID0gaXNEaW1lbnNpb25TdGFja2VkKGRhdGEsIHRhcmdldERhdGFEaW0KICAvKiwgb3RoZXJEYXRhRGltKi8KICApOwogIHZhciBjYWxjRGF0YURpbSA9IHN0YWNrZWQgPyBkYXRhLmdldENhbGN1bGF0aW9uSW5mbygnc3RhY2tSZXN1bHREaW1lbnNpb24nKSA6IHRhcmdldERhdGFEaW07CiAgdmFyIHZhbHVlID0gbnVtQ2FsY3VsYXRlKGRhdGEsIGNhbGNEYXRhRGltLCBtbFR5cGUpOwogIHZhciBkYXRhSW5kZXggPSBkYXRhLmluZGljZXNPZk5lYXJlc3QoY2FsY0RhdGFEaW0sIHZhbHVlKVswXTsKICBjb29yZEFycltvdGhlckNvb3JkSW5kZXhdID0gZGF0YS5nZXQob3RoZXJEYXRhRGltLCBkYXRhSW5kZXgpOwogIGNvb3JkQXJyW3RhcmdldENvb3JkSW5kZXhdID0gZGF0YS5nZXQoY2FsY0RhdGFEaW0sIGRhdGFJbmRleCk7CiAgdmFyIGNvb3JkQXJyVmFsdWUgPSBkYXRhLmdldCh0YXJnZXREYXRhRGltLCBkYXRhSW5kZXgpOyAvLyBNYWtlIGl0IHNpbXBsZSwgZG8gbm90IHZpc2l0IGFsbCBzdGFja2VkIHZhbHVlIHRvIGNvdW50IHByZWNpc2lvbi4KCiAgdmFyIHByZWNpc2lvbiA9IG51bWJlclV0aWwuZ2V0UHJlY2lzaW9uKGRhdGEuZ2V0KHRhcmdldERhdGFEaW0sIGRhdGFJbmRleCkpOwogIHByZWNpc2lvbiA9IE1hdGgubWluKHByZWNpc2lvbiwgMjApOwoKICBpZiAocHJlY2lzaW9uID49IDApIHsKICAgIGNvb3JkQXJyW3RhcmdldENvb3JkSW5kZXhdID0gK2Nvb3JkQXJyW3RhcmdldENvb3JkSW5kZXhdLnRvRml4ZWQocHJlY2lzaW9uKTsKICB9CgogIHJldHVybiBbY29vcmRBcnIsIGNvb3JkQXJyVmFsdWVdOwp9Cgp2YXIgY3VycnkgPSB6clV0aWwuY3Vycnk7IC8vIFRPRE8gU3BlY2lmaWVkIHBlcmNlbnQKCnZhciBtYXJrZXJUeXBlQ2FsY3VsYXRvciA9IHsKICAvKioKICAgKiBAbWV0aG9kCiAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9IGRhdGEKICAgKiBAcGFyYW0ge3N0cmluZ30gYmFzZUF4aXNEaW0KICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVBeGlzRGltCiAgICovCiAgbWluOiBjdXJyeShtYXJrZXJUeXBlQ2FsY3VsYXRvcldpdGhFeHRlbnQsICdtaW4nKSwKCiAgLyoqCiAgICogQG1ldGhvZAogICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBkYXRhCiAgICogQHBhcmFtIHtzdHJpbmd9IGJhc2VBeGlzRGltCiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlQXhpc0RpbQogICAqLwogIG1heDogY3VycnkobWFya2VyVHlwZUNhbGN1bGF0b3JXaXRoRXh0ZW50LCAnbWF4JyksCgogIC8qKgogICAqIEBtZXRob2QKICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gZGF0YQogICAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlQXhpc0RpbQogICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZUF4aXNEaW0KICAgKi8KICBhdmVyYWdlOiBjdXJyeShtYXJrZXJUeXBlQ2FsY3VsYXRvcldpdGhFeHRlbnQsICdhdmVyYWdlJykKfTsKLyoqCiAqIFRyYW5zZm9ybSBtYXJrUG9pbnQgZGF0YSBpdGVtIHRvIGZvcm1hdCB1c2VkIGluIExpc3QgYnkgZG8gdGhlIGZvbGxvd2luZwogKiAxLiBDYWxjdWxhdGUgc3RhdGlzdGljIGxpa2UgYG1heGAsIGBtaW5gLCBgYXZlcmFnZWAKICogMi4gQ29udmVydCBgaXRlbS54QXhpc2AsIGBpdGVtLnlBeGlzYCB0byBgaXRlbS5jb29yZGAgYXJyYXkKICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzfSBzZXJpZXNNb2RlbAogKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC8qfSBbY29vcmRTeXNdCiAqIEBwYXJhbSAge09iamVjdH0gaXRlbQogKiBAcmV0dXJuIHtPYmplY3R9CiAqLwoKZnVuY3Rpb24gZGF0YVRyYW5zZm9ybShzZXJpZXNNb2RlbCwgaXRlbSkgewogIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpOwogIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07IC8vIDEuIElmIG5vdCBzcGVjaWZ5IHRoZSBwb3NpdGlvbiB3aXRoIHBpeGVsIGRpcmVjdGx5CiAgLy8gMi4gSWYgYGNvb3JkYCBpcyBub3QgYSBkYXRhIGFycmF5LiBXaGljaCB1c2VzIGB4QXhpc2AsCiAgLy8gYHlBeGlzYCB0byBzcGVjaWZ5IHRoZSBjb29yZCBvbiBlYWNoIGRpbWVuc2lvbgogIC8vIHBhcnNlRmxvYXQgZmlyc3QgYmVjYXVzZSBpdGVtLnggYW5kIGl0ZW0ueSBjYW4gYmUgcGVyY2VudCBzdHJpbmcgbGlrZSAnMjAlJwoKICBpZiAoaXRlbSAmJiAhaGFzWEFuZFkoaXRlbSkgJiYgIXpyVXRpbC5pc0FycmF5KGl0ZW0uY29vcmQpICYmIGNvb3JkU3lzKSB7CiAgICB2YXIgZGltcyA9IGNvb3JkU3lzLmRpbWVuc2lvbnM7CiAgICB2YXIgYXhpc0luZm8gPSBnZXRBeGlzSW5mbyhpdGVtLCBkYXRhLCBjb29yZFN5cywgc2VyaWVzTW9kZWwpOyAvLyBDbG9uZSB0aGUgb3B0aW9uCiAgICAvLyBUcmFuc2Zvcm0gdGhlIHByb3BlcnRpZXMgeEF4aXMsIHlBeGlzLCByYWRpdXNBeGlzLCBhbmdsZUF4aXMsIGdlb0Nvb3JkIHRvIHZhbHVlCgogICAgaXRlbSA9IHpyVXRpbC5jbG9uZShpdGVtKTsKCiAgICBpZiAoaXRlbS50eXBlICYmIG1hcmtlclR5cGVDYWxjdWxhdG9yW2l0ZW0udHlwZV0gJiYgYXhpc0luZm8uYmFzZUF4aXMgJiYgYXhpc0luZm8udmFsdWVBeGlzKSB7CiAgICAgIHZhciBvdGhlckNvb3JkSW5kZXggPSBpbmRleE9mKGRpbXMsIGF4aXNJbmZvLmJhc2VBeGlzLmRpbSk7CiAgICAgIHZhciB0YXJnZXRDb29yZEluZGV4ID0gaW5kZXhPZihkaW1zLCBheGlzSW5mby52YWx1ZUF4aXMuZGltKTsKICAgICAgdmFyIGNvb3JkSW5mbyA9IG1hcmtlclR5cGVDYWxjdWxhdG9yW2l0ZW0udHlwZV0oZGF0YSwgYXhpc0luZm8uYmFzZURhdGFEaW0sIGF4aXNJbmZvLnZhbHVlRGF0YURpbSwgb3RoZXJDb29yZEluZGV4LCB0YXJnZXRDb29yZEluZGV4KTsKICAgICAgaXRlbS5jb29yZCA9IGNvb3JkSW5mb1swXTsgLy8gRm9yY2UgdG8gdXNlIHRoZSB2YWx1ZSBvZiBjYWxjdWxhdGVkIHZhbHVlLgogICAgICAvLyBsZXQgaXRlbSB1c2UgdGhlIHZhbHVlIHdpdGhvdXQgc3RhY2suCgogICAgICBpdGVtLnZhbHVlID0gY29vcmRJbmZvWzFdOwogICAgfSBlbHNlIHsKICAgICAgLy8gRklYTUUgT25seSBoYXMgb25lIG9mIHhBeGlzIGFuZCB5QXhpcy4KICAgICAgdmFyIGNvb3JkID0gW2l0ZW0ueEF4aXMgIT0gbnVsbCA/IGl0ZW0ueEF4aXMgOiBpdGVtLnJhZGl1c0F4aXMsIGl0ZW0ueUF4aXMgIT0gbnVsbCA/IGl0ZW0ueUF4aXMgOiBpdGVtLmFuZ2xlQXhpc107IC8vIEVhY2ggY29vcmQgc3VwcG9ydCBtYXgsIG1pbiwgYXZlcmFnZQoKICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHsKICAgICAgICBpZiAobWFya2VyVHlwZUNhbGN1bGF0b3JbY29vcmRbaV1dKSB7CiAgICAgICAgICBjb29yZFtpXSA9IG51bUNhbGN1bGF0ZShkYXRhLCBkYXRhLm1hcERpbWVuc2lvbihkaW1zW2ldKSwgY29vcmRbaV0pOwogICAgICAgIH0KICAgICAgfQoKICAgICAgaXRlbS5jb29yZCA9IGNvb3JkOwogICAgfQogIH0KCiAgcmV0dXJuIGl0ZW07Cn0KCmZ1bmN0aW9uIGdldEF4aXNJbmZvKGl0ZW0sIGRhdGEsIGNvb3JkU3lzLCBzZXJpZXNNb2RlbCkgewogIHZhciByZXQgPSB7fTsKCiAgaWYgKGl0ZW0udmFsdWVJbmRleCAhPSBudWxsIHx8IGl0ZW0udmFsdWVEaW0gIT0gbnVsbCkgewogICAgcmV0LnZhbHVlRGF0YURpbSA9IGl0ZW0udmFsdWVJbmRleCAhPSBudWxsID8gZGF0YS5nZXREaW1lbnNpb24oaXRlbS52YWx1ZUluZGV4KSA6IGl0ZW0udmFsdWVEaW07CiAgICByZXQudmFsdWVBeGlzID0gY29vcmRTeXMuZ2V0QXhpcyhkYXRhRGltVG9Db29yZERpbShzZXJpZXNNb2RlbCwgcmV0LnZhbHVlRGF0YURpbSkpOwogICAgcmV0LmJhc2VBeGlzID0gY29vcmRTeXMuZ2V0T3RoZXJBeGlzKHJldC52YWx1ZUF4aXMpOwogICAgcmV0LmJhc2VEYXRhRGltID0gZGF0YS5tYXBEaW1lbnNpb24ocmV0LmJhc2VBeGlzLmRpbSk7CiAgfSBlbHNlIHsKICAgIHJldC5iYXNlQXhpcyA9IHNlcmllc01vZGVsLmdldEJhc2VBeGlzKCk7CiAgICByZXQudmFsdWVBeGlzID0gY29vcmRTeXMuZ2V0T3RoZXJBeGlzKHJldC5iYXNlQXhpcyk7CiAgICByZXQuYmFzZURhdGFEaW0gPSBkYXRhLm1hcERpbWVuc2lvbihyZXQuYmFzZUF4aXMuZGltKTsKICAgIHJldC52YWx1ZURhdGFEaW0gPSBkYXRhLm1hcERpbWVuc2lvbihyZXQudmFsdWVBeGlzLmRpbSk7CiAgfQoKICByZXR1cm4gcmV0Owp9CgpmdW5jdGlvbiBkYXRhRGltVG9Db29yZERpbShzZXJpZXNNb2RlbCwgZGF0YURpbSkgewogIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpOwogIHZhciBkaW1lbnNpb25zID0gZGF0YS5kaW1lbnNpb25zOwogIGRhdGFEaW0gPSBkYXRhLmdldERpbWVuc2lvbihkYXRhRGltKTsKCiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaW1lbnNpb25zLmxlbmd0aDsgaSsrKSB7CiAgICB2YXIgZGltSXRlbSA9IGRhdGEuZ2V0RGltZW5zaW9uSW5mbyhkaW1lbnNpb25zW2ldKTsKCiAgICBpZiAoZGltSXRlbS5uYW1lID09PSBkYXRhRGltKSB7CiAgICAgIHJldHVybiBkaW1JdGVtLmNvb3JkRGltOwogICAgfQogIH0KfQovKioKICogRmlsdGVyIGRhdGEgd2hpY2ggaXMgb3V0IG9mIGNvb3JkaW5hdGVTeXN0ZW0gcmFuZ2UKICogW2RhdGFGaWx0ZXIgZGVzY3JpcHRpb25dCiAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL2Nvb3JkLyp9IFtjb29yZFN5c10KICogQHBhcmFtICB7T2JqZWN0fSBpdGVtCiAqIEByZXR1cm4ge2Jvb2xlYW59CiAqLwoKCmZ1bmN0aW9uIGRhdGFGaWx0ZXIoY29vcmRTeXMsIGl0ZW0pIHsKICAvLyBBbHdhbHlzIHJldHVybiB0cnVlIGlmIHRoZXJlIGlzIG5vIGNvb3JkU3lzCiAgcmV0dXJuIGNvb3JkU3lzICYmIGNvb3JkU3lzLmNvbnRhaW5EYXRhICYmIGl0ZW0uY29vcmQgJiYgIWhhc1hPclkoaXRlbSkgPyBjb29yZFN5cy5jb250YWluRGF0YShpdGVtLmNvb3JkKSA6IHRydWU7Cn0KCmZ1bmN0aW9uIGRpbVZhbHVlR2V0dGVyKGl0ZW0sIGRpbU5hbWUsIGRhdGFJbmRleCwgZGltSW5kZXgpIHsKICAvLyB4LCB5LCByYWRpdXMsIGFuZ2xlCiAgaWYgKGRpbUluZGV4IDwgMikgewogICAgcmV0dXJuIGl0ZW0uY29vcmQgJiYgaXRlbS5jb29yZFtkaW1JbmRleF07CiAgfQoKICByZXR1cm4gaXRlbS52YWx1ZTsKfQoKZnVuY3Rpb24gbnVtQ2FsY3VsYXRlKGRhdGEsIHZhbHVlRGF0YURpbSwgdHlwZSkgewogIGlmICh0eXBlID09PSAnYXZlcmFnZScpIHsKICAgIHZhciBzdW0gPSAwOwogICAgdmFyIGNvdW50ID0gMDsKICAgIGRhdGEuZWFjaCh2YWx1ZURhdGFEaW0sIGZ1bmN0aW9uICh2YWwsIGlkeCkgewogICAgICBpZiAoIWlzTmFOKHZhbCkpIHsKICAgICAgICBzdW0gKz0gdmFsOwogICAgICAgIGNvdW50Kys7CiAgICAgIH0KICAgIH0pOwogICAgcmV0dXJuIHN1bSAvIGNvdW50OwogIH0gZWxzZSBpZiAodHlwZSA9PT0gJ21lZGlhbicpIHsKICAgIHJldHVybiBkYXRhLmdldE1lZGlhbih2YWx1ZURhdGFEaW0pOwogIH0gZWxzZSB7CiAgICAvLyBtYXggJiBtaW4KICAgIHJldHVybiBkYXRhLmdldERhdGFFeHRlbnQodmFsdWVEYXRhRGltLCB0cnVlKVt0eXBlID09PSAnbWF4JyA/IDEgOiAwXTsKICB9Cn0KCmV4cG9ydHMuZGF0YVRyYW5zZm9ybSA9IGRhdGFUcmFuc2Zvcm07CmV4cG9ydHMuZ2V0QXhpc0luZm8gPSBnZXRBeGlzSW5mbzsKZXhwb3J0cy5kYXRhRmlsdGVyID0gZGF0YUZpbHRlcjsKZXhwb3J0cy5kaW1WYWx1ZUdldHRlciA9IGRpbVZhbHVlR2V0dGVyOwpleHBvcnRzLm51bUNhbGN1bGF0ZSA9IG51bUNhbGN1bGF0ZTs="},{"version":3,"sources":["/Users/id-repair/Documents/SEOL/4c-dashboard/node_modules/echarts/lib/component/marker/markerHelper.js"],"names":["zrUtil","require","numberUtil","_dataStackHelper","isDimensionStacked","indexOf","hasXOrY","item","isNaN","parseFloat","x","y","hasXAndY","markerTypeCalculatorWithExtent","mlType","data","otherDataDim","targetDataDim","otherCoordIndex","targetCoordIndex","coordArr","stacked","calcDataDim","getCalculationInfo","value","numCalculate","dataIndex","indicesOfNearest","get","coordArrValue","precision","getPrecision","Math","min","toFixed","curry","markerTypeCalculator","max","average","dataTransform","seriesModel","getData","coordSys","coordinateSystem","isArray","coord","dims","dimensions","axisInfo","getAxisInfo","clone","type","baseAxis","valueAxis","dim","coordInfo","baseDataDim","valueDataDim","xAxis","radiusAxis","yAxis","angleAxis","i","mapDimension","ret","valueIndex","valueDim","getDimension","getAxis","dataDimToCoordDim","getOtherAxis","getBaseAxis","dataDim","length","dimItem","getDimensionInfo","name","coordDim","dataFilter","containData","dimValueGetter","dimName","dimIndex","sum","count","each","val","idx","getMedian","getDataExtent","exports"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar numberUtil = require(\"../../util/number\");\n\nvar _dataStackHelper = require(\"../../data/helper/dataStackHelper\");\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar indexOf = zrUtil.indexOf;\n\nfunction hasXOrY(item) {\n  return !(isNaN(parseFloat(item.x)) && isNaN(parseFloat(item.y)));\n}\n\nfunction hasXAndY(item) {\n  return !isNaN(parseFloat(item.x)) && !isNaN(parseFloat(item.y));\n} // Make it simple, do not visit all stacked value to count precision.\n// function getPrecision(data, valueAxisDim, dataIndex) {\n//     var precision = -1;\n//     var stackedDim = data.mapDimension(valueAxisDim);\n//     do {\n//         precision = Math.max(\n//             numberUtil.getPrecision(data.get(stackedDim, dataIndex)),\n//             precision\n//         );\n//         var stackedOnSeries = data.getCalculationInfo('stackedOnSeries');\n//         if (stackedOnSeries) {\n//             var byValue = data.get(data.getCalculationInfo('stackedByDimension'), dataIndex);\n//             data = stackedOnSeries.getData();\n//             dataIndex = data.indexOf(data.getCalculationInfo('stackedByDimension'), byValue);\n//             stackedDim = data.getCalculationInfo('stackedDimension');\n//         }\n//         else {\n//             data = null;\n//         }\n//     } while (data);\n//     return precision;\n// }\n\n\nfunction markerTypeCalculatorWithExtent(mlType, data, otherDataDim, targetDataDim, otherCoordIndex, targetCoordIndex) {\n  var coordArr = [];\n  var stacked = isDimensionStacked(data, targetDataDim\n  /*, otherDataDim*/\n  );\n  var calcDataDim = stacked ? data.getCalculationInfo('stackResultDimension') : targetDataDim;\n  var value = numCalculate(data, calcDataDim, mlType);\n  var dataIndex = data.indicesOfNearest(calcDataDim, value)[0];\n  coordArr[otherCoordIndex] = data.get(otherDataDim, dataIndex);\n  coordArr[targetCoordIndex] = data.get(calcDataDim, dataIndex);\n  var coordArrValue = data.get(targetDataDim, dataIndex); // Make it simple, do not visit all stacked value to count precision.\n\n  var precision = numberUtil.getPrecision(data.get(targetDataDim, dataIndex));\n  precision = Math.min(precision, 20);\n\n  if (precision >= 0) {\n    coordArr[targetCoordIndex] = +coordArr[targetCoordIndex].toFixed(precision);\n  }\n\n  return [coordArr, coordArrValue];\n}\n\nvar curry = zrUtil.curry; // TODO Specified percent\n\nvar markerTypeCalculator = {\n  /**\n   * @method\n   * @param {module:echarts/data/List} data\n   * @param {string} baseAxisDim\n   * @param {string} valueAxisDim\n   */\n  min: curry(markerTypeCalculatorWithExtent, 'min'),\n\n  /**\n   * @method\n   * @param {module:echarts/data/List} data\n   * @param {string} baseAxisDim\n   * @param {string} valueAxisDim\n   */\n  max: curry(markerTypeCalculatorWithExtent, 'max'),\n\n  /**\n   * @method\n   * @param {module:echarts/data/List} data\n   * @param {string} baseAxisDim\n   * @param {string} valueAxisDim\n   */\n  average: curry(markerTypeCalculatorWithExtent, 'average')\n};\n/**\n * Transform markPoint data item to format used in List by do the following\n * 1. Calculate statistic like `max`, `min`, `average`\n * 2. Convert `item.xAxis`, `item.yAxis` to `item.coord` array\n * @param  {module:echarts/model/Series} seriesModel\n * @param  {module:echarts/coord/*} [coordSys]\n * @param  {Object} item\n * @return {Object}\n */\n\nfunction dataTransform(seriesModel, item) {\n  var data = seriesModel.getData();\n  var coordSys = seriesModel.coordinateSystem; // 1. If not specify the position with pixel directly\n  // 2. If `coord` is not a data array. Which uses `xAxis`,\n  // `yAxis` to specify the coord on each dimension\n  // parseFloat first because item.x and item.y can be percent string like '20%'\n\n  if (item && !hasXAndY(item) && !zrUtil.isArray(item.coord) && coordSys) {\n    var dims = coordSys.dimensions;\n    var axisInfo = getAxisInfo(item, data, coordSys, seriesModel); // Clone the option\n    // Transform the properties xAxis, yAxis, radiusAxis, angleAxis, geoCoord to value\n\n    item = zrUtil.clone(item);\n\n    if (item.type && markerTypeCalculator[item.type] && axisInfo.baseAxis && axisInfo.valueAxis) {\n      var otherCoordIndex = indexOf(dims, axisInfo.baseAxis.dim);\n      var targetCoordIndex = indexOf(dims, axisInfo.valueAxis.dim);\n      var coordInfo = markerTypeCalculator[item.type](data, axisInfo.baseDataDim, axisInfo.valueDataDim, otherCoordIndex, targetCoordIndex);\n      item.coord = coordInfo[0]; // Force to use the value of calculated value.\n      // let item use the value without stack.\n\n      item.value = coordInfo[1];\n    } else {\n      // FIXME Only has one of xAxis and yAxis.\n      var coord = [item.xAxis != null ? item.xAxis : item.radiusAxis, item.yAxis != null ? item.yAxis : item.angleAxis]; // Each coord support max, min, average\n\n      for (var i = 0; i < 2; i++) {\n        if (markerTypeCalculator[coord[i]]) {\n          coord[i] = numCalculate(data, data.mapDimension(dims[i]), coord[i]);\n        }\n      }\n\n      item.coord = coord;\n    }\n  }\n\n  return item;\n}\n\nfunction getAxisInfo(item, data, coordSys, seriesModel) {\n  var ret = {};\n\n  if (item.valueIndex != null || item.valueDim != null) {\n    ret.valueDataDim = item.valueIndex != null ? data.getDimension(item.valueIndex) : item.valueDim;\n    ret.valueAxis = coordSys.getAxis(dataDimToCoordDim(seriesModel, ret.valueDataDim));\n    ret.baseAxis = coordSys.getOtherAxis(ret.valueAxis);\n    ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);\n  } else {\n    ret.baseAxis = seriesModel.getBaseAxis();\n    ret.valueAxis = coordSys.getOtherAxis(ret.baseAxis);\n    ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);\n    ret.valueDataDim = data.mapDimension(ret.valueAxis.dim);\n  }\n\n  return ret;\n}\n\nfunction dataDimToCoordDim(seriesModel, dataDim) {\n  var data = seriesModel.getData();\n  var dimensions = data.dimensions;\n  dataDim = data.getDimension(dataDim);\n\n  for (var i = 0; i < dimensions.length; i++) {\n    var dimItem = data.getDimensionInfo(dimensions[i]);\n\n    if (dimItem.name === dataDim) {\n      return dimItem.coordDim;\n    }\n  }\n}\n/**\n * Filter data which is out of coordinateSystem range\n * [dataFilter description]\n * @param  {module:echarts/coord/*} [coordSys]\n * @param  {Object} item\n * @return {boolean}\n */\n\n\nfunction dataFilter(coordSys, item) {\n  // Alwalys return true if there is no coordSys\n  return coordSys && coordSys.containData && item.coord && !hasXOrY(item) ? coordSys.containData(item.coord) : true;\n}\n\nfunction dimValueGetter(item, dimName, dataIndex, dimIndex) {\n  // x, y, radius, angle\n  if (dimIndex < 2) {\n    return item.coord && item.coord[dimIndex];\n  }\n\n  return item.value;\n}\n\nfunction numCalculate(data, valueDataDim, type) {\n  if (type === 'average') {\n    var sum = 0;\n    var count = 0;\n    data.each(valueDataDim, function (val, idx) {\n      if (!isNaN(val)) {\n        sum += val;\n        count++;\n      }\n    });\n    return sum / count;\n  } else if (type === 'median') {\n    return data.getMedian(valueDataDim);\n  } else {\n    // max & min\n    return data.getDataExtent(valueDataDim, true)[type === 'max' ? 1 : 0];\n  }\n}\n\nexports.dataTransform = dataTransform;\nexports.getAxisInfo = getAxisInfo;\nexports.dataFilter = dataFilter;\nexports.dimValueGetter = dimValueGetter;\nexports.numCalculate = numCalculate;"]}]}