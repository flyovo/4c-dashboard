{"remainingRequest":"/Users/id-repair/Documents/SEOL/4c-dashboard/node_modules/babel-loader/lib/index.js!/Users/id-repair/Documents/SEOL/4c-dashboard/node_modules/echarts/lib/component/dataZoom/AxisProxy.js","dependencies":[{"path":"/Users/id-repair/Documents/SEOL/4c-dashboard/node_modules/echarts/lib/component/dataZoom/AxisProxy.js","mtime":499162500000},{"path":"/Users/id-repair/Documents/SEOL/4c-dashboard/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/id-repair/Documents/SEOL/4c-dashboard/node_modules/babel-loader/lib/index.js","mtime":315532800000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:cmVxdWlyZSgiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlLmpzIik7CgpyZXF1aXJlKCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkubWFwLmpzIik7CgpyZXF1aXJlKCJjb3JlLWpzL21vZHVsZXMvZXMubnVtYmVyLnRvLWZpeGVkLmpzIik7CgovKgoqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmUKKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGUKKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbgoqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGUKKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlCiogIkxpY2Vuc2UiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZQoqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQKKgoqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wCioKKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsCiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4KKiAiQVMgSVMiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkKKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUKKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zCiogdW5kZXIgdGhlIExpY2Vuc2UuCiovCnZhciB6clV0aWwgPSByZXF1aXJlKCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWwiKTsKCnZhciBudW1iZXJVdGlsID0gcmVxdWlyZSgiLi4vLi4vdXRpbC9udW1iZXIiKTsKCnZhciBoZWxwZXIgPSByZXF1aXJlKCIuL2hlbHBlciIpOwoKdmFyIHNsaWRlck1vdmUgPSByZXF1aXJlKCIuLi9oZWxwZXIvc2xpZGVyTW92ZSIpOwovKgoqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmUKKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGUKKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbgoqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGUKKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlCiogIkxpY2Vuc2UiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZQoqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQKKgoqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wCioKKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsCiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4KKiAiQVMgSVMiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkKKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUKKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zCiogdW5kZXIgdGhlIExpY2Vuc2UuCiovCgoKdmFyIGVhY2ggPSB6clV0aWwuZWFjaDsKdmFyIGFzYyA9IG51bWJlclV0aWwuYXNjOwovKioKICogT3BlcmF0ZSBzaW5nbGUgYXhpcy4KICogT25lIGF4aXMgY2FuIG9ubHkgb3BlcmF0ZWQgYnkgb25lIGF4aXMgb3BlcmF0b3IuCiAqIERpZmZlcmVudCBkYXRhWm9vbU1vZGVscyBtYXkgYmUgZGVmaW5lZCB0byBvcGVyYXRlIHRoZSBzYW1lIGF4aXMuCiAqIChpLmUuICdpbnNpZGUnIGRhdGEgem9vbSBhbmQgJ3NsaWRlcicgZGF0YSB6b29tIGNvbXBvbmVudHMpCiAqIFNvIGRhdGFab29tTW9kZWxzIHNoYXJlIG9uZSBheGlzUHJveHkgaW4gdGhhdCBjYXNlLgogKgogKiBAY2xhc3MKICovCgp2YXIgQXhpc1Byb3h5ID0gZnVuY3Rpb24gQXhpc1Byb3h5KGRpbU5hbWUsIGF4aXNJbmRleCwgZGF0YVpvb21Nb2RlbCwgZWNNb2RlbCkgewogIC8qKgogICAqIEBwcml2YXRlCiAgICogQHR5cGUge3N0cmluZ30KICAgKi8KICB0aGlzLl9kaW1OYW1lID0gZGltTmFtZTsKICAvKioKICAgKiBAcHJpdmF0ZQogICAqLwoKICB0aGlzLl9heGlzSW5kZXggPSBheGlzSW5kZXg7CiAgLyoqCiAgICogQHByaXZhdGUKICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59CiAgICovCgogIHRoaXMuX3ZhbHVlV2luZG93OwogIC8qKgogICAqIEBwcml2YXRlCiAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fQogICAqLwoKICB0aGlzLl9wZXJjZW50V2luZG93OwogIC8qKgogICAqIEBwcml2YXRlCiAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fQogICAqLwoKICB0aGlzLl9kYXRhRXh0ZW50OwogIC8qKgogICAqIHttaW5TcGFuLCBtYXhTcGFuLCBtaW5WYWx1ZVNwYW4sIG1heFZhbHVlU3Bhbn0KICAgKiBAcHJpdmF0ZQogICAqIEB0eXBlIHtPYmplY3R9CiAgICovCgogIHRoaXMuX21pbk1heFNwYW47CiAgLyoqCiAgICogQHJlYWRPbmx5CiAgICogQHR5cGUge21vZHVsZTogZWNoYXJ0cy9tb2RlbC9HbG9iYWx9CiAgICovCgogIHRoaXMuZWNNb2RlbCA9IGVjTW9kZWw7CiAgLyoqCiAgICogQHByaXZhdGUKICAgKiBAdHlwZSB7bW9kdWxlOiBlY2hhcnRzL2NvbXBvbmVudC9kYXRhWm9vbS9EYXRhWm9vbU1vZGVsfQogICAqLwoKICB0aGlzLl9kYXRhWm9vbU1vZGVsID0gZGF0YVpvb21Nb2RlbDsgLy8gLyoqCiAgLy8gICogQHJlYWRPbmx5CiAgLy8gICogQHByaXZhdGUKICAvLyAgKi8KICAvLyB0aGlzLmhhc1Nlcmllc1N0YWNrZWQ7Cn07CgpBeGlzUHJveHkucHJvdG90eXBlID0gewogIGNvbnN0cnVjdG9yOiBBeGlzUHJveHksCgogIC8qKgogICAqIFdoZXRoZXIgdGhlIGF4aXNQcm94eSBpcyBob3N0ZWQgYnkgZGF0YVpvb21Nb2RlbC4KICAgKgogICAqIEBwdWJsaWMKICAgKiBAcGFyYW0ge21vZHVsZTogZWNoYXJ0cy9jb21wb25lbnQvZGF0YVpvb20vRGF0YVpvb21Nb2RlbH0gZGF0YVpvb21Nb2RlbAogICAqIEByZXR1cm4ge2Jvb2xlYW59CiAgICovCiAgaG9zdGVkQnk6IGZ1bmN0aW9uIGhvc3RlZEJ5KGRhdGFab29tTW9kZWwpIHsKICAgIHJldHVybiB0aGlzLl9kYXRhWm9vbU1vZGVsID09PSBkYXRhWm9vbU1vZGVsOwogIH0sCgogIC8qKgogICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBWYWx1ZSBjYW4gb25seSBiZSBOYU4gb3IgZmluaXRlIHZhbHVlLgogICAqLwogIGdldERhdGFWYWx1ZVdpbmRvdzogZnVuY3Rpb24gZ2V0RGF0YVZhbHVlV2luZG93KCkgewogICAgcmV0dXJuIHRoaXMuX3ZhbHVlV2luZG93LnNsaWNlKCk7CiAgfSwKCiAgLyoqCiAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59CiAgICovCiAgZ2V0RGF0YVBlcmNlbnRXaW5kb3c6IGZ1bmN0aW9uIGdldERhdGFQZXJjZW50V2luZG93KCkgewogICAgcmV0dXJuIHRoaXMuX3BlcmNlbnRXaW5kb3cuc2xpY2UoKTsKICB9LAoKICAvKioKICAgKiBAcHVibGljCiAgICogQHBhcmFtIHtudW1iZXJ9IGF4aXNJbmRleAogICAqIEByZXR1cm4ge0FycmF5fSBzZXJpZXNNb2RlbHMKICAgKi8KICBnZXRUYXJnZXRTZXJpZXNNb2RlbHM6IGZ1bmN0aW9uIGdldFRhcmdldFNlcmllc01vZGVscygpIHsKICAgIHZhciBzZXJpZXNNb2RlbHMgPSBbXTsKICAgIHZhciBlY01vZGVsID0gdGhpcy5lY01vZGVsOwogICAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkgewogICAgICBpZiAoaGVscGVyLmlzQ29vcmRTdXBwb3J0ZWQoc2VyaWVzTW9kZWwuZ2V0KCdjb29yZGluYXRlU3lzdGVtJykpKSB7CiAgICAgICAgdmFyIGRpbU5hbWUgPSB0aGlzLl9kaW1OYW1lOwogICAgICAgIHZhciBheGlzTW9kZWwgPSBlY01vZGVsLnF1ZXJ5Q29tcG9uZW50cyh7CiAgICAgICAgICBtYWluVHlwZTogZGltTmFtZSArICdBeGlzJywKICAgICAgICAgIGluZGV4OiBzZXJpZXNNb2RlbC5nZXQoZGltTmFtZSArICdBeGlzSW5kZXgnKSwKICAgICAgICAgIGlkOiBzZXJpZXNNb2RlbC5nZXQoZGltTmFtZSArICdBeGlzSWQnKQogICAgICAgIH0pWzBdOwoKICAgICAgICBpZiAodGhpcy5fYXhpc0luZGV4ID09PSAoYXhpc01vZGVsICYmIGF4aXNNb2RlbC5jb21wb25lbnRJbmRleCkpIHsKICAgICAgICAgIHNlcmllc01vZGVscy5wdXNoKHNlcmllc01vZGVsKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0sIHRoaXMpOwogICAgcmV0dXJuIHNlcmllc01vZGVsczsKICB9LAogIGdldEF4aXNNb2RlbDogZnVuY3Rpb24gZ2V0QXhpc01vZGVsKCkgewogICAgcmV0dXJuIHRoaXMuZWNNb2RlbC5nZXRDb21wb25lbnQodGhpcy5fZGltTmFtZSArICdBeGlzJywgdGhpcy5fYXhpc0luZGV4KTsKICB9LAogIGdldE90aGVyQXhpc01vZGVsOiBmdW5jdGlvbiBnZXRPdGhlckF4aXNNb2RlbCgpIHsKICAgIHZhciBheGlzRGltID0gdGhpcy5fZGltTmFtZTsKICAgIHZhciBlY01vZGVsID0gdGhpcy5lY01vZGVsOwogICAgdmFyIGF4aXNNb2RlbCA9IHRoaXMuZ2V0QXhpc01vZGVsKCk7CiAgICB2YXIgaXNDYXJ0ZXNpYW4gPSBheGlzRGltID09PSAneCcgfHwgYXhpc0RpbSA9PT0gJ3knOwogICAgdmFyIG90aGVyQXhpc0RpbTsKICAgIHZhciBjb29yZFN5c0luZGV4TmFtZTsKCiAgICBpZiAoaXNDYXJ0ZXNpYW4pIHsKICAgICAgY29vcmRTeXNJbmRleE5hbWUgPSAnZ3JpZEluZGV4JzsKICAgICAgb3RoZXJBeGlzRGltID0gYXhpc0RpbSA9PT0gJ3gnID8gJ3knIDogJ3gnOwogICAgfSBlbHNlIHsKICAgICAgY29vcmRTeXNJbmRleE5hbWUgPSAncG9sYXJJbmRleCc7CiAgICAgIG90aGVyQXhpc0RpbSA9IGF4aXNEaW0gPT09ICdhbmdsZScgPyAncmFkaXVzJyA6ICdhbmdsZSc7CiAgICB9CgogICAgdmFyIGZvdW5kT3RoZXJBeGlzTW9kZWw7CiAgICBlY01vZGVsLmVhY2hDb21wb25lbnQob3RoZXJBeGlzRGltICsgJ0F4aXMnLCBmdW5jdGlvbiAob3RoZXJBeGlzTW9kZWwpIHsKICAgICAgaWYgKChvdGhlckF4aXNNb2RlbC5nZXQoY29vcmRTeXNJbmRleE5hbWUpIHx8IDApID09PSAoYXhpc01vZGVsLmdldChjb29yZFN5c0luZGV4TmFtZSkgfHwgMCkpIHsKICAgICAgICBmb3VuZE90aGVyQXhpc01vZGVsID0gb3RoZXJBeGlzTW9kZWw7CiAgICAgIH0KICAgIH0pOwogICAgcmV0dXJuIGZvdW5kT3RoZXJBeGlzTW9kZWw7CiAgfSwKICBnZXRNaW5NYXhTcGFuOiBmdW5jdGlvbiBnZXRNaW5NYXhTcGFuKCkgewogICAgcmV0dXJuIHpyVXRpbC5jbG9uZSh0aGlzLl9taW5NYXhTcGFuKTsKICB9LAoKICAvKioKICAgKiBPbmx5IGNhbGN1bGF0ZSBieSBnaXZlbiByYW5nZSBhbmQgdGhpcy5fZGF0YUV4dGVudCwgZG8gbm90IGNoYW5nZSBhbnl0aGluZy4KICAgKgogICAqIEBwYXJhbSB7T2JqZWN0fSBvcHQKICAgKiBAcGFyYW0ge251bWJlcn0gW29wdC5zdGFydF0KICAgKiBAcGFyYW0ge251bWJlcn0gW29wdC5lbmRdCiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHQuc3RhcnRWYWx1ZV0KICAgKiBAcGFyYW0ge251bWJlcn0gW29wdC5lbmRWYWx1ZV0KICAgKi8KICBjYWxjdWxhdGVEYXRhV2luZG93OiBmdW5jdGlvbiBjYWxjdWxhdGVEYXRhV2luZG93KG9wdCkgewogICAgdmFyIGRhdGFFeHRlbnQgPSB0aGlzLl9kYXRhRXh0ZW50OwogICAgdmFyIGF4aXNNb2RlbCA9IHRoaXMuZ2V0QXhpc01vZGVsKCk7CiAgICB2YXIgc2NhbGUgPSBheGlzTW9kZWwuYXhpcy5zY2FsZTsKCiAgICB2YXIgcmFuZ2VQcm9wTW9kZSA9IHRoaXMuX2RhdGFab29tTW9kZWwuZ2V0UmFuZ2VQcm9wTW9kZSgpOwoKICAgIHZhciBwZXJjZW50RXh0ZW50ID0gWzAsIDEwMF07CiAgICB2YXIgcGVyY2VudFdpbmRvdyA9IFtdOwogICAgdmFyIHZhbHVlV2luZG93ID0gW107CiAgICB2YXIgaGFzUHJvcE1vZGVWYWx1ZTsKICAgIGVhY2goWydzdGFydCcsICdlbmQnXSwgZnVuY3Rpb24gKHByb3AsIGlkeCkgewogICAgICB2YXIgYm91bmRQZXJjZW50ID0gb3B0W3Byb3BdOwogICAgICB2YXIgYm91bmRWYWx1ZSA9IG9wdFtwcm9wICsgJ1ZhbHVlJ107IC8vIE5vdGljZTogZGF0YVpvb20gaXMgYmFzZWQgZWl0aGVyIG9uIGBwZXJjZW50UHJvcGAgKCdzdGFydCcsICdlbmQnKSBvcgogICAgICAvLyBvbiBgdmFsdWVQcm9wYCAoJ3N0YXJ0VmFsdWUnLCAnZW5kVmFsdWUnKS4gKFRoZXkgYXJlIGJhc2VkIG9uIHRoZSBkYXRhIGV4dGVudAogICAgICAvLyBidXQgbm90IG1pbi9tYXggb2YgYXhpcywgd2hpY2ggd2lsbCBiZSBjYWxjdWxhdGVkIGJ5IGRhdGEgd2luZG93IHRoZW4pLgogICAgICAvLyBUaGUgZm9ybWVyIG9uZSBpcyBzdWl0YWJsZSBmb3IgY2FzZXMgdGhhdCBhIGRhdGFab29tIGNvbXBvbmVudCBjb250cm9scyBtdWx0aXBsZQogICAgICAvLyBheGVzIHdpdGggZGlmZmVyZW50IHVuaXQgb3IgZXh0ZW50LCBhbmQgdGhlIGxhdHRlciBvbmUgaXMgc3VpdGFibGUgZm9yIGFjY3VyYXRlCiAgICAgIC8vIHpvb20gYnkgcGl4ZWwgKGUuZy4sIGluIGRhdGFab29tU2VsZWN0KS4KICAgICAgLy8gd2UgdXNlIGBnZXRSYW5nZVByb3BNb2RlKClgIHRvIG1hcmsgd2hpY2ggcHJvcCBpcyB1c2VkLiBgcmFuZ2VQcm9wTW9kZWAgaXMgdXBkYXRlZAogICAgICAvLyBvbmx5IHdoZW4gc2V0T3B0aW9uIG9yIGRpc3BhdGNoQWN0aW9uLCBvdGhlcndpc2UgaXQgcmVtYWlucyBpdHMgb3JpZ2luYWwgdmFsdWUuCiAgICAgIC8vIChXaHkgbm90IG9ubHkgcmVjb3JkIGBwZXJjZW50UHJvcGAgYW5kIGFsd2F5cyBtYXAgdG8gYHZhbHVlUHJvcGA/IEJlY2F1c2UKICAgICAgLy8gdGhlIG1hcCBgdmFsdWVQcm9wYCAtPiBgcGVyY2VudFByb3BgIC0+IGB2YWx1ZVByb3BgIHByb2JhYmx5IG5vdCB0aGUgb3JpZ2luYWwKICAgICAgLy8gYHZhbHVlUHJvcGAuIGNvbnNpZGVyIHR3byBheGVzIGNvbnN0cm9sbGVkIGJ5IG9uZSBkYXRhWm9vbS4gVGhleSBoYXZlIGRpZmZlcmVudAogICAgICAvLyBkYXRhIGV4dGVudC4gQWxsIG9mIHZhbHVlcyB0aGF0IGFyZSBvdmVyZmxvdyB0aGUgYGRhdGFFeHRlbnRgIHdpbGwgYmUgY2FsY3VsYXRlZAogICAgICAvLyB0byBwZXJjZW50ICcxMDAlJykuCgogICAgICBpZiAocmFuZ2VQcm9wTW9kZVtpZHhdID09PSAncGVyY2VudCcpIHsKICAgICAgICBib3VuZFBlcmNlbnQgPT0gbnVsbCAmJiAoYm91bmRQZXJjZW50ID0gcGVyY2VudEV4dGVudFtpZHhdKTsgLy8gVXNlIHNjYWxlLnBhcnNlIHRvIG1hdGggcm91bmQgZm9yIGNhdGVnb3J5IG9yIHRpbWUgYXhpcy4KCiAgICAgICAgYm91bmRWYWx1ZSA9IHNjYWxlLnBhcnNlKG51bWJlclV0aWwubGluZWFyTWFwKGJvdW5kUGVyY2VudCwgcGVyY2VudEV4dGVudCwgZGF0YUV4dGVudCkpOwogICAgICB9IGVsc2UgewogICAgICAgIGhhc1Byb3BNb2RlVmFsdWUgPSB0cnVlOwogICAgICAgIGJvdW5kVmFsdWUgPSBib3VuZFZhbHVlID09IG51bGwgPyBkYXRhRXh0ZW50W2lkeF0gOiBzY2FsZS5wYXJzZShib3VuZFZhbHVlKTsgLy8gQ2FsY3VsYXRpbmcgYHBlcmNlbnRgIGZyb20gYHZhbHVlYCBtYXkgYmUgbm90IGFjY3VyYXRlLCBiZWNhdXNlCiAgICAgICAgLy8gVGhpcyBjYWxjdWxhdGlvbiBjYW4gbm90IGJlIGludmVyc2VkLCBiZWNhdXNlIGFsbCBvZiB2YWx1ZXMgdGhhdAogICAgICAgIC8vIGFyZSBvdmVyZmxvdyB0aGUgYGRhdGFFeHRlbnRgIHdpbGwgYmUgY2FsY3VsYXRlZCB0byBwZXJjZW50ICcxMDAlJwoKICAgICAgICBib3VuZFBlcmNlbnQgPSBudW1iZXJVdGlsLmxpbmVhck1hcChib3VuZFZhbHVlLCBkYXRhRXh0ZW50LCBwZXJjZW50RXh0ZW50KTsKICAgICAgfSAvLyB2YWx1ZVdpbmRvd1tpZHhdID0gcm91bmQoYm91bmRWYWx1ZSk7CiAgICAgIC8vIHBlcmNlbnRXaW5kb3dbaWR4XSA9IHJvdW5kKGJvdW5kUGVyY2VudCk7CgoKICAgICAgdmFsdWVXaW5kb3dbaWR4XSA9IGJvdW5kVmFsdWU7CiAgICAgIHBlcmNlbnRXaW5kb3dbaWR4XSA9IGJvdW5kUGVyY2VudDsKICAgIH0pOwogICAgYXNjKHZhbHVlV2luZG93KTsKICAgIGFzYyhwZXJjZW50V2luZG93KTsgLy8gVGhlIHdpbmRvd3MgZnJvbSB1c2VyIGNhbGxpbmcgb2YgYGRpc3BhdGNoQWN0aW9uYCBtaWdodCBiZSBvdXQgb2YgdGhlIGV4dGVudCwKICAgIC8vIG9yIGRvIG5vdCBvYmV5IHRoZSBgbWluL21heFNwYW5gLCBgbWluL21heFZhbHVlU3BhbmAuIEJ1dCB3ZSBkb250IHJlc3RyaWN0IHdpbmRvdwogICAgLy8gYnkgYHpvb21Mb2NrYCBoZXJlLCBiZWNhdXNlIHdlIHNlZSBgem9vbUxvY2tgIGp1c3QgYXMgYSBpbnRlcmFjdGlvbiBjb25zdHJhaW50LAogICAgLy8gd2hlcmUgQVBJIGlzIGFibGUgdG8gaW5pdGlhbGl6ZS9tb2RpZnkgdGhlIHdpbmRvdyBzaXplIGV2ZW4gdGhvdWdoIGB6b29tTG9ja2AKICAgIC8vIHNwZWNpZmllZC4KCiAgICB2YXIgc3BhbnMgPSB0aGlzLl9taW5NYXhTcGFuOwogICAgaGFzUHJvcE1vZGVWYWx1ZSA/IHJlc3RyaWN0U2V0KHZhbHVlV2luZG93LCBwZXJjZW50V2luZG93LCBkYXRhRXh0ZW50LCBwZXJjZW50RXh0ZW50LCBmYWxzZSkgOiByZXN0cmljdFNldChwZXJjZW50V2luZG93LCB2YWx1ZVdpbmRvdywgcGVyY2VudEV4dGVudCwgZGF0YUV4dGVudCwgdHJ1ZSk7CgogICAgZnVuY3Rpb24gcmVzdHJpY3RTZXQoZnJvbVdpbmRvdywgdG9XaW5kb3csIGZyb21FeHRlbnQsIHRvRXh0ZW50LCB0b1ZhbHVlKSB7CiAgICAgIHZhciBzdWZmaXggPSB0b1ZhbHVlID8gJ1NwYW4nIDogJ1ZhbHVlU3Bhbic7CiAgICAgIHNsaWRlck1vdmUoMCwgZnJvbVdpbmRvdywgZnJvbUV4dGVudCwgJ2FsbCcsIHNwYW5zWydtaW4nICsgc3VmZml4XSwgc3BhbnNbJ21heCcgKyBzdWZmaXhdKTsKCiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7CiAgICAgICAgdG9XaW5kb3dbaV0gPSBudW1iZXJVdGlsLmxpbmVhck1hcChmcm9tV2luZG93W2ldLCBmcm9tRXh0ZW50LCB0b0V4dGVudCwgdHJ1ZSk7CiAgICAgICAgdG9WYWx1ZSAmJiAodG9XaW5kb3dbaV0gPSBzY2FsZS5wYXJzZSh0b1dpbmRvd1tpXSkpOwogICAgICB9CiAgICB9CgogICAgcmV0dXJuIHsKICAgICAgdmFsdWVXaW5kb3c6IHZhbHVlV2luZG93LAogICAgICBwZXJjZW50V2luZG93OiBwZXJjZW50V2luZG93CiAgICB9OwogIH0sCgogIC8qKgogICAqIE5vdGljZTogcmVzZXQgc2hvdWxkIG5vdCBiZSBjYWxsZWQgYmVmb3JlIHNlcmllcy5yZXN0b3JlRGF0YSgpIGNhbGxlZCwKICAgKiBzbyBpdCBpcyByZWNvbW1hbmRlZCB0byBiZSBjYWxsZWQgaW4gInByb2Nlc3Mgc3RhZ2UiIGJ1dCBub3QgIm1vZGVsIGluaXQKICAgKiBzdGFnZSIuCiAgICoKICAgKiBAcGFyYW0ge21vZHVsZTogZWNoYXJ0cy9jb21wb25lbnQvZGF0YVpvb20vRGF0YVpvb21Nb2RlbH0gZGF0YVpvb21Nb2RlbAogICAqLwogIHJlc2V0OiBmdW5jdGlvbiByZXNldChkYXRhWm9vbU1vZGVsKSB7CiAgICBpZiAoZGF0YVpvb21Nb2RlbCAhPT0gdGhpcy5fZGF0YVpvb21Nb2RlbCkgewogICAgICByZXR1cm47CiAgICB9CgogICAgdmFyIHRhcmdldFNlcmllcyA9IHRoaXMuZ2V0VGFyZ2V0U2VyaWVzTW9kZWxzKCk7IC8vIEN1bGN1bGF0ZSBkYXRhIHdpbmRvdyBhbmQgZGF0YSBleHRlbnQsIGFuZCByZWNvcmQgdGhlbS4KCiAgICB0aGlzLl9kYXRhRXh0ZW50ID0gY2FsY3VsYXRlRGF0YUV4dGVudCh0aGlzLCB0aGlzLl9kaW1OYW1lLCB0YXJnZXRTZXJpZXMpOyAvLyB0aGlzLmhhc1Nlcmllc1N0YWNrZWQgPSBmYWxzZTsKICAgIC8vIGVhY2godGFyZ2V0U2VyaWVzLCBmdW5jdGlvbiAoc2VyaWVzKSB7CiAgICAvLyB2YXIgZGF0YSA9IHNlcmllcy5nZXREYXRhKCk7CiAgICAvLyB2YXIgZGF0YURpbSA9IGRhdGEubWFwRGltZW5zaW9uKHRoaXMuX2RpbU5hbWUpOwogICAgLy8gdmFyIHN0YWNrZWREaW1lbnNpb24gPSBkYXRhLmdldENhbGN1bGF0aW9uSW5mbygnc3RhY2tlZERpbWVuc2lvbicpOwogICAgLy8gaWYgKHN0YWNrZWREaW1lbnNpb24gJiYgc3RhY2tlZERpbWVuc2lvbiA9PT0gZGF0YURpbSkgewogICAgLy8gdGhpcy5oYXNTZXJpZXNTdGFja2VkID0gdHJ1ZTsKICAgIC8vIH0KICAgIC8vIH0sIHRoaXMpOwogICAgLy8gYGNhbGN1bGF0ZURhdGFXaW5kb3dgIHVzZXMgbWluL21heFNwYW4uCgogICAgc2V0TWluTWF4U3Bhbih0aGlzKTsKICAgIHZhciBkYXRhV2luZG93ID0gdGhpcy5jYWxjdWxhdGVEYXRhV2luZG93KGRhdGFab29tTW9kZWwuc2V0dGxlZE9wdGlvbik7CiAgICB0aGlzLl92YWx1ZVdpbmRvdyA9IGRhdGFXaW5kb3cudmFsdWVXaW5kb3c7CiAgICB0aGlzLl9wZXJjZW50V2luZG93ID0gZGF0YVdpbmRvdy5wZXJjZW50V2luZG93OyAvLyBVcGRhdGUgYXhpcyBzZXR0aW5nIHRoZW4uCgogICAgc2V0QXhpc01vZGVsKHRoaXMpOwogIH0sCgogIC8qKgogICAqIEBwYXJhbSB7bW9kdWxlOiBlY2hhcnRzL2NvbXBvbmVudC9kYXRhWm9vbS9EYXRhWm9vbU1vZGVsfSBkYXRhWm9vbU1vZGVsCiAgICovCiAgcmVzdG9yZTogZnVuY3Rpb24gcmVzdG9yZShkYXRhWm9vbU1vZGVsKSB7CiAgICBpZiAoZGF0YVpvb21Nb2RlbCAhPT0gdGhpcy5fZGF0YVpvb21Nb2RlbCkgewogICAgICByZXR1cm47CiAgICB9CgogICAgdGhpcy5fdmFsdWVXaW5kb3cgPSB0aGlzLl9wZXJjZW50V2luZG93ID0gbnVsbDsKICAgIHNldEF4aXNNb2RlbCh0aGlzLCB0cnVlKTsKICB9LAoKICAvKioKICAgKiBAcGFyYW0ge21vZHVsZTogZWNoYXJ0cy9jb21wb25lbnQvZGF0YVpvb20vRGF0YVpvb21Nb2RlbH0gZGF0YVpvb21Nb2RlbAogICAqLwogIGZpbHRlckRhdGE6IGZ1bmN0aW9uIGZpbHRlckRhdGEoZGF0YVpvb21Nb2RlbCwgYXBpKSB7CiAgICBpZiAoZGF0YVpvb21Nb2RlbCAhPT0gdGhpcy5fZGF0YVpvb21Nb2RlbCkgewogICAgICByZXR1cm47CiAgICB9CgogICAgdmFyIGF4aXNEaW0gPSB0aGlzLl9kaW1OYW1lOwogICAgdmFyIHNlcmllc01vZGVscyA9IHRoaXMuZ2V0VGFyZ2V0U2VyaWVzTW9kZWxzKCk7CiAgICB2YXIgZmlsdGVyTW9kZSA9IGRhdGFab29tTW9kZWwuZ2V0KCdmaWx0ZXJNb2RlJyk7CiAgICB2YXIgdmFsdWVXaW5kb3cgPSB0aGlzLl92YWx1ZVdpbmRvdzsKCiAgICBpZiAoZmlsdGVyTW9kZSA9PT0gJ25vbmUnKSB7CiAgICAgIHJldHVybjsKICAgIH0gLy8gRklYTUUKICAgIC8vIFRvb2xib3ggbWF5IGhhcyBkYXRhWm9vbSBpbmplY3RlZC4gQW5kIGlmIHRoZXJlIGFyZSBzdGFja2VkIGJhciBjaGFydAogICAgLy8gd2l0aCBOYU4gZGF0YSwgTmFOIHdpbGwgYmUgZmlsdGVyZWQgYW5kIHN0YWNrIHdpbGwgYmUgd3JvbmcuCiAgICAvLyBTbyB3ZSBuZWVkIHRvIGZvcmNlIHRoZSBtb2RlIHRvIGJlIHNldCBlbXB0eS4KICAgIC8vIEluIGZlY3QsIGl0IGlzIG5vdCBhIGJpZyBkZWFsIHRoYXQgZG8gbm90IHN1cHBvcnQgZmlsdGVyTW9kZS0nZmlsdGVyJwogICAgLy8gd2hlbiB1c2luZyB0b29sYm94I2RhdGFab29tLCB1dGlsbCB0b29sdGlwI2RhdGFab29tIHN1cHBvcnQgInNpbmdsZSBheGlzCiAgICAvLyBzZWxlY3Rpb24iIHNvbWUgZGF5LCB3aGljaCBtaWdodCBuZWVkICJhZGFwdCB0byBkYXRhIGV4dGVudCBvbiB0aGUKICAgIC8vIG90aGVyQXhpcyIsIHdoaWNoIGlzIGRpc2FibGVkIGJ5IGZpbHRlck1vZGUtJ2VtcHR5Jy4KICAgIC8vIEJ1dCBjdXJyZW50bHksIHN0YWNrIGhhcyBiZWVuIGZpeGVkIHRvIGJhc2VkIG9uIHZhbHVlIGJ1dCBub3QgaW5kZXgsCiAgICAvLyBzbyB0aGlzIGlzIG5vdCBhbiBpc3N1ZSBhbnkgbW9yZS4KICAgIC8vIHZhciBvdGhlckF4aXNNb2RlbCA9IHRoaXMuZ2V0T3RoZXJBeGlzTW9kZWwoKTsKICAgIC8vIGlmIChkYXRhWm9vbU1vZGVsLmdldCgnJGZyb21Ub29sYm94JykKICAgIC8vICAgICAmJiBvdGhlckF4aXNNb2RlbAogICAgLy8gICAgICYmIG90aGVyQXhpc01vZGVsLmhhc1Nlcmllc1N0YWNrZWQKICAgIC8vICkgewogICAgLy8gICAgIGZpbHRlck1vZGUgPSAnZW1wdHknOwogICAgLy8gfQogICAgLy8gVE9ETwogICAgLy8gZmlsdGVyTW9kZSAnd2Vha0ZpbHRlcicgYW5kICdlbXB0eScgaXMgbm90IG9wdGltaXplZCBmb3IgaHVnZSBkYXRhIHlldC4KCgogICAgZWFjaChzZXJpZXNNb2RlbHMsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkgewogICAgICB2YXIgc2VyaWVzRGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTsKICAgICAgdmFyIGRhdGFEaW1zID0gc2VyaWVzRGF0YS5tYXBEaW1lbnNpb24oYXhpc0RpbSwgdHJ1ZSk7CgogICAgICBpZiAoIWRhdGFEaW1zLmxlbmd0aCkgewogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgaWYgKGZpbHRlck1vZGUgPT09ICd3ZWFrRmlsdGVyJykgewogICAgICAgIHNlcmllc0RhdGEuZmlsdGVyU2VsZihmdW5jdGlvbiAoZGF0YUluZGV4KSB7CiAgICAgICAgICB2YXIgbGVmdE91dDsKICAgICAgICAgIHZhciByaWdodE91dDsKICAgICAgICAgIHZhciBoYXNWYWx1ZTsKCiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFEaW1zLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHNlcmllc0RhdGEuZ2V0KGRhdGFEaW1zW2ldLCBkYXRhSW5kZXgpOwogICAgICAgICAgICB2YXIgdGhpc0hhc1ZhbHVlID0gIWlzTmFOKHZhbHVlKTsKICAgICAgICAgICAgdmFyIHRoaXNMZWZ0T3V0ID0gdmFsdWUgPCB2YWx1ZVdpbmRvd1swXTsKICAgICAgICAgICAgdmFyIHRoaXNSaWdodE91dCA9IHZhbHVlID4gdmFsdWVXaW5kb3dbMV07CgogICAgICAgICAgICBpZiAodGhpc0hhc1ZhbHVlICYmICF0aGlzTGVmdE91dCAmJiAhdGhpc1JpZ2h0T3V0KSB7CiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIHRoaXNIYXNWYWx1ZSAmJiAoaGFzVmFsdWUgPSB0cnVlKTsKICAgICAgICAgICAgdGhpc0xlZnRPdXQgJiYgKGxlZnRPdXQgPSB0cnVlKTsKICAgICAgICAgICAgdGhpc1JpZ2h0T3V0ICYmIChyaWdodE91dCA9IHRydWUpOwogICAgICAgICAgfSAvLyBJZiBib3RoIGxlZnQgb3V0IGFuZCByaWdodCBvdXQsIGRvIG5vdCBmaWx0ZXIuCgoKICAgICAgICAgIHJldHVybiBoYXNWYWx1ZSAmJiBsZWZ0T3V0ICYmIHJpZ2h0T3V0OwogICAgICAgIH0pOwogICAgICB9IGVsc2UgewogICAgICAgIGVhY2goZGF0YURpbXMsIGZ1bmN0aW9uIChkaW0pIHsKICAgICAgICAgIGlmIChmaWx0ZXJNb2RlID09PSAnZW1wdHknKSB7CiAgICAgICAgICAgIHNlcmllc01vZGVsLnNldERhdGEoc2VyaWVzRGF0YSA9IHNlcmllc0RhdGEubWFwKGRpbSwgZnVuY3Rpb24gKHZhbHVlKSB7CiAgICAgICAgICAgICAgcmV0dXJuICFpc0luV2luZG93KHZhbHVlKSA/IE5hTiA6IHZhbHVlOwogICAgICAgICAgICB9KSk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB2YXIgcmFuZ2UgPSB7fTsKICAgICAgICAgICAgcmFuZ2VbZGltXSA9IHZhbHVlV2luZG93OyAvLyBjb25zb2xlLnRpbWUoJ3NlbGVjdCcpOwoKICAgICAgICAgICAgc2VyaWVzRGF0YS5zZWxlY3RSYW5nZShyYW5nZSk7IC8vIGNvbnNvbGUudGltZUVuZCgnc2VsZWN0Jyk7CiAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgIH0KCiAgICAgIGVhY2goZGF0YURpbXMsIGZ1bmN0aW9uIChkaW0pIHsKICAgICAgICBzZXJpZXNEYXRhLnNldEFwcHJveGltYXRlRXh0ZW50KHZhbHVlV2luZG93LCBkaW0pOwogICAgICB9KTsKICAgIH0pOwoKICAgIGZ1bmN0aW9uIGlzSW5XaW5kb3codmFsdWUpIHsKICAgICAgcmV0dXJuIHZhbHVlID49IHZhbHVlV2luZG93WzBdICYmIHZhbHVlIDw9IHZhbHVlV2luZG93WzFdOwogICAgfQogIH0KfTsKCmZ1bmN0aW9uIGNhbGN1bGF0ZURhdGFFeHRlbnQoYXhpc1Byb3h5LCBheGlzRGltLCBzZXJpZXNNb2RlbHMpIHsKICB2YXIgZGF0YUV4dGVudCA9IFtJbmZpbml0eSwgLUluZmluaXR5XTsKICBlYWNoKHNlcmllc01vZGVscywgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7CiAgICB2YXIgc2VyaWVzRGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTsKCiAgICBpZiAoc2VyaWVzRGF0YSkgewogICAgICBlYWNoKHNlcmllc0RhdGEubWFwRGltZW5zaW9uKGF4aXNEaW0sIHRydWUpLCBmdW5jdGlvbiAoZGltKSB7CiAgICAgICAgdmFyIHNlcmllc0V4dGVudCA9IHNlcmllc0RhdGEuZ2V0QXBwcm94aW1hdGVFeHRlbnQoZGltKTsKICAgICAgICBzZXJpZXNFeHRlbnRbMF0gPCBkYXRhRXh0ZW50WzBdICYmIChkYXRhRXh0ZW50WzBdID0gc2VyaWVzRXh0ZW50WzBdKTsKICAgICAgICBzZXJpZXNFeHRlbnRbMV0gPiBkYXRhRXh0ZW50WzFdICYmIChkYXRhRXh0ZW50WzFdID0gc2VyaWVzRXh0ZW50WzFdKTsKICAgICAgfSk7CiAgICB9CiAgfSk7CgogIGlmIChkYXRhRXh0ZW50WzFdIDwgZGF0YUV4dGVudFswXSkgewogICAgZGF0YUV4dGVudCA9IFtOYU4sIE5hTl07CiAgfSAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gZ2V0ICJjb25zaXN0ZW50IiBleHRlbnQgd2hlbiBtb3JlIHRoZW4gb25lIGF4ZXMgaXMKICAvLyBjb250cm9sbGVkIGJ5IGEgYGRhdGFab29tYCwgb3RoZXJ3aXNlIHRob3NlIGF4ZXMgd2lsbCBub3QgYmUgc3luY2hyb25pemVkCiAgLy8gd2hlbiB6b29taW5nLiBCdXQgaXQgaXMgZGlmZmljdWx0IHRvIGtub3cgd2hhdCBpcyAiY29uc2lzdGVudCIsIGNvbnNpZGVyaW5nCiAgLy8gYXhlcyBoYXZlIGRpZmZlcmVudCB0eXBlIG9yIGV2ZW4gZGlmZmVyZW50IG1lYW5pbmdzIChGb3IgZXhhbXBsZSwgdHdvCiAgLy8gdGltZSBheGVzIGFyZSB1c2VkIHRvIGNvbXBhcmUgZGF0YSBvZiB0aGUgc2FtZSBkYXRlIGluIGRpZmZlcmVudCB5ZWFycykuCiAgLy8gU28gYmFzaWNhbGx5IGRhdGFab29tIGp1c3Qgb2J0YWlucyBleHRlbnQgYnkgc2VyaWVzLmRhdGEgKGluIGNhdGVnb3J5IGF4aXMKICAvLyBleHRlbnQgY2FuIGJlIG9idGFpbmVkIGZyb20gYXhpcy5kYXRhKS4KICAvLyBOZXZlcnRoZWxlc3MsIHVzZXIgY2FuIHNldCBtaW4vbWF4L3NjYWxlIG9uIGF4ZXMgdG8gbWFrZSBleHRlbnQgb2YgYXhlcwogIC8vIGNvbnNpc3RlbnQuCgoKICBmaXhFeHRlbnRCeUF4aXMoYXhpc1Byb3h5LCBkYXRhRXh0ZW50KTsKICByZXR1cm4gZGF0YUV4dGVudDsKfQoKZnVuY3Rpb24gZml4RXh0ZW50QnlBeGlzKGF4aXNQcm94eSwgZGF0YUV4dGVudCkgewogIHZhciBheGlzTW9kZWwgPSBheGlzUHJveHkuZ2V0QXhpc01vZGVsKCk7CiAgdmFyIG1pbiA9IGF4aXNNb2RlbC5nZXRNaW4odHJ1ZSk7IC8vIEZvciBjYXRlZ29yeSBheGlzLCBpZiBtaW4vbWF4L3NjYWxlIGFyZSBub3Qgc2V0LCBleHRlbnQgaXMgZGV0ZXJtaW5lZAogIC8vIGJ5IGF4aXMuZGF0YSBieSBkZWZhdWx0LgoKICB2YXIgaXNDYXRlZ29yeUF4aXMgPSBheGlzTW9kZWwuZ2V0KCd0eXBlJykgPT09ICdjYXRlZ29yeSc7CiAgdmFyIGF4aXNEYXRhTGVuID0gaXNDYXRlZ29yeUF4aXMgJiYgYXhpc01vZGVsLmdldENhdGVnb3JpZXMoKS5sZW5ndGg7CgogIGlmIChtaW4gIT0gbnVsbCAmJiBtaW4gIT09ICdkYXRhTWluJyAmJiB0eXBlb2YgbWluICE9PSAnZnVuY3Rpb24nKSB7CiAgICBkYXRhRXh0ZW50WzBdID0gbWluOwogIH0gZWxzZSBpZiAoaXNDYXRlZ29yeUF4aXMpIHsKICAgIGRhdGFFeHRlbnRbMF0gPSBheGlzRGF0YUxlbiA+IDAgPyAwIDogTmFOOwogIH0KCiAgdmFyIG1heCA9IGF4aXNNb2RlbC5nZXRNYXgodHJ1ZSk7CgogIGlmIChtYXggIT0gbnVsbCAmJiBtYXggIT09ICdkYXRhTWF4JyAmJiB0eXBlb2YgbWF4ICE9PSAnZnVuY3Rpb24nKSB7CiAgICBkYXRhRXh0ZW50WzFdID0gbWF4OwogIH0gZWxzZSBpZiAoaXNDYXRlZ29yeUF4aXMpIHsKICAgIGRhdGFFeHRlbnRbMV0gPSBheGlzRGF0YUxlbiA+IDAgPyBheGlzRGF0YUxlbiAtIDEgOiBOYU47CiAgfQoKICBpZiAoIWF4aXNNb2RlbC5nZXQoJ3NjYWxlJywgdHJ1ZSkpIHsKICAgIGRhdGFFeHRlbnRbMF0gPiAwICYmIChkYXRhRXh0ZW50WzBdID0gMCk7CiAgICBkYXRhRXh0ZW50WzFdIDwgMCAmJiAoZGF0YUV4dGVudFsxXSA9IDApOwogIH0gLy8gRm9yIHZhbHVlIGF4aXMsIGlmIG1pbi9tYXgvc2NhbGUgYXJlIG5vdCBzZXQsIHdlIGp1c3QgdXNlIHRoZSBleHRlbnQgb2J0YWluZWQKICAvLyBieSBzZXJpZXMgZGF0YSwgd2hpY2ggbWF5IGJlIGEgbGl0dGxlIGRpZmZlcmVudCBmcm9tIHRoZSBleHRlbnQgY2FsY3VsYXRlZCBieQogIC8vIGBheGlzSGVscGVyLmdldFNjYWxlRXh0ZW50YC4gQnV0IHRoZSBkaWZmZXJlbnQganVzdCBhZmZlY3RzIHRoZSBleHBlcmllbmNlIGEKICAvLyBsaXR0bGUgd2hlbiB6b29taW5nLiBTbyBpdCB3aWxsIG5vdCBiZSBmaXhlZCB1bnRpbCBzb21lIHVzZXJzIHJlcXVpcmUgaXQgc3Ryb25nbHkuCgoKICByZXR1cm4gZGF0YUV4dGVudDsKfQoKZnVuY3Rpb24gc2V0QXhpc01vZGVsKGF4aXNQcm94eSwgaXNSZXN0b3JlKSB7CiAgdmFyIGF4aXNNb2RlbCA9IGF4aXNQcm94eS5nZXRBeGlzTW9kZWwoKTsKICB2YXIgcGVyY2VudFdpbmRvdyA9IGF4aXNQcm94eS5fcGVyY2VudFdpbmRvdzsKICB2YXIgdmFsdWVXaW5kb3cgPSBheGlzUHJveHkuX3ZhbHVlV2luZG93OwoKICBpZiAoIXBlcmNlbnRXaW5kb3cpIHsKICAgIHJldHVybjsKICB9IC8vIFswLCA1MDBdOiBhcmJpdHJhcnkgdmFsdWUsIGd1ZXNzIGF4aXMgZXh0ZW50LgoKCiAgdmFyIHByZWNpc2lvbiA9IG51bWJlclV0aWwuZ2V0UGl4ZWxQcmVjaXNpb24odmFsdWVXaW5kb3csIFswLCA1MDBdKTsKICBwcmVjaXNpb24gPSBNYXRoLm1pbihwcmVjaXNpb24sIDIwKTsgLy8gaXNSZXN0b3JlIG9yIGlzRnVsbAoKICB2YXIgdXNlT3JpZ2luID0gaXNSZXN0b3JlIHx8IHBlcmNlbnRXaW5kb3dbMF0gPT09IDAgJiYgcGVyY2VudFdpbmRvd1sxXSA9PT0gMTAwOwogIGF4aXNNb2RlbC5zZXRSYW5nZSh1c2VPcmlnaW4gPyBudWxsIDogK3ZhbHVlV2luZG93WzBdLnRvRml4ZWQocHJlY2lzaW9uKSwgdXNlT3JpZ2luID8gbnVsbCA6ICt2YWx1ZVdpbmRvd1sxXS50b0ZpeGVkKHByZWNpc2lvbikpOwp9CgpmdW5jdGlvbiBzZXRNaW5NYXhTcGFuKGF4aXNQcm94eSkgewogIHZhciBtaW5NYXhTcGFuID0gYXhpc1Byb3h5Ll9taW5NYXhTcGFuID0ge307CiAgdmFyIGRhdGFab29tTW9kZWwgPSBheGlzUHJveHkuX2RhdGFab29tTW9kZWw7CiAgdmFyIGRhdGFFeHRlbnQgPSBheGlzUHJveHkuX2RhdGFFeHRlbnQ7CiAgZWFjaChbJ21pbicsICdtYXgnXSwgZnVuY3Rpb24gKG1pbk1heCkgewogICAgdmFyIHBlcmNlbnRTcGFuID0gZGF0YVpvb21Nb2RlbC5nZXQobWluTWF4ICsgJ1NwYW4nKTsKICAgIHZhciB2YWx1ZVNwYW4gPSBkYXRhWm9vbU1vZGVsLmdldChtaW5NYXggKyAnVmFsdWVTcGFuJyk7CiAgICB2YWx1ZVNwYW4gIT0gbnVsbCAmJiAodmFsdWVTcGFuID0gYXhpc1Byb3h5LmdldEF4aXNNb2RlbCgpLmF4aXMuc2NhbGUucGFyc2UodmFsdWVTcGFuKSk7IC8vIG1pblZhbHVlU3BhbiBhbmQgbWF4VmFsdWVTcGFuIGhhcyBoaWdoZXIgcHJpb3JpdHkgdGhhbiBtaW5TcGFuIGFuZCBtYXhTcGFuCgogICAgaWYgKHZhbHVlU3BhbiAhPSBudWxsKSB7CiAgICAgIHBlcmNlbnRTcGFuID0gbnVtYmVyVXRpbC5saW5lYXJNYXAoZGF0YUV4dGVudFswXSArIHZhbHVlU3BhbiwgZGF0YUV4dGVudCwgWzAsIDEwMF0sIHRydWUpOwogICAgfSBlbHNlIGlmIChwZXJjZW50U3BhbiAhPSBudWxsKSB7CiAgICAgIHZhbHVlU3BhbiA9IG51bWJlclV0aWwubGluZWFyTWFwKHBlcmNlbnRTcGFuLCBbMCwgMTAwXSwgZGF0YUV4dGVudCwgdHJ1ZSkgLSBkYXRhRXh0ZW50WzBdOwogICAgfQoKICAgIG1pbk1heFNwYW5bbWluTWF4ICsgJ1NwYW4nXSA9IHBlcmNlbnRTcGFuOwogICAgbWluTWF4U3BhblttaW5NYXggKyAnVmFsdWVTcGFuJ10gPSB2YWx1ZVNwYW47CiAgfSk7Cn0KCnZhciBfZGVmYXVsdCA9IEF4aXNQcm94eTsKbW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDs="},{"version":3,"sources":["/Users/id-repair/Documents/SEOL/4c-dashboard/node_modules/echarts/lib/component/dataZoom/AxisProxy.js"],"names":["zrUtil","require","numberUtil","helper","sliderMove","each","asc","AxisProxy","dimName","axisIndex","dataZoomModel","ecModel","_dimName","_axisIndex","_valueWindow","_percentWindow","_dataExtent","_minMaxSpan","_dataZoomModel","prototype","constructor","hostedBy","getDataValueWindow","slice","getDataPercentWindow","getTargetSeriesModels","seriesModels","eachSeries","seriesModel","isCoordSupported","get","axisModel","queryComponents","mainType","index","id","componentIndex","push","getAxisModel","getComponent","getOtherAxisModel","axisDim","isCartesian","otherAxisDim","coordSysIndexName","foundOtherAxisModel","eachComponent","otherAxisModel","getMinMaxSpan","clone","calculateDataWindow","opt","dataExtent","scale","axis","rangePropMode","getRangePropMode","percentExtent","percentWindow","valueWindow","hasPropModeValue","prop","idx","boundPercent","boundValue","parse","linearMap","spans","restrictSet","fromWindow","toWindow","fromExtent","toExtent","toValue","suffix","i","reset","targetSeries","calculateDataExtent","setMinMaxSpan","dataWindow","settledOption","setAxisModel","restore","filterData","api","filterMode","seriesData","getData","dataDims","mapDimension","length","filterSelf","dataIndex","leftOut","rightOut","hasValue","value","thisHasValue","isNaN","thisLeftOut","thisRightOut","dim","setData","map","isInWindow","NaN","range","selectRange","setApproximateExtent","axisProxy","Infinity","seriesExtent","getApproximateExtent","fixExtentByAxis","min","getMin","isCategoryAxis","axisDataLen","getCategories","max","getMax","isRestore","precision","getPixelPrecision","Math","useOrigin","setRange","toFixed","minMaxSpan","minMax","percentSpan","valueSpan","_default","module","exports"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar numberUtil = require(\"../../util/number\");\n\nvar helper = require(\"./helper\");\n\nvar sliderMove = require(\"../helper/sliderMove\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar each = zrUtil.each;\nvar asc = numberUtil.asc;\n/**\n * Operate single axis.\n * One axis can only operated by one axis operator.\n * Different dataZoomModels may be defined to operate the same axis.\n * (i.e. 'inside' data zoom and 'slider' data zoom components)\n * So dataZoomModels share one axisProxy in that case.\n *\n * @class\n */\n\nvar AxisProxy = function (dimName, axisIndex, dataZoomModel, ecModel) {\n  /**\n   * @private\n   * @type {string}\n   */\n  this._dimName = dimName;\n  /**\n   * @private\n   */\n\n  this._axisIndex = axisIndex;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._valueWindow;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._percentWindow;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._dataExtent;\n  /**\n   * {minSpan, maxSpan, minValueSpan, maxValueSpan}\n   * @private\n   * @type {Object}\n   */\n\n  this._minMaxSpan;\n  /**\n   * @readOnly\n   * @type {module: echarts/model/Global}\n   */\n\n  this.ecModel = ecModel;\n  /**\n   * @private\n   * @type {module: echarts/component/dataZoom/DataZoomModel}\n   */\n\n  this._dataZoomModel = dataZoomModel; // /**\n  //  * @readOnly\n  //  * @private\n  //  */\n  // this.hasSeriesStacked;\n};\n\nAxisProxy.prototype = {\n  constructor: AxisProxy,\n\n  /**\n   * Whether the axisProxy is hosted by dataZoomModel.\n   *\n   * @public\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   * @return {boolean}\n   */\n  hostedBy: function (dataZoomModel) {\n    return this._dataZoomModel === dataZoomModel;\n  },\n\n  /**\n   * @return {Array.<number>} Value can only be NaN or finite value.\n   */\n  getDataValueWindow: function () {\n    return this._valueWindow.slice();\n  },\n\n  /**\n   * @return {Array.<number>}\n   */\n  getDataPercentWindow: function () {\n    return this._percentWindow.slice();\n  },\n\n  /**\n   * @public\n   * @param {number} axisIndex\n   * @return {Array} seriesModels\n   */\n  getTargetSeriesModels: function () {\n    var seriesModels = [];\n    var ecModel = this.ecModel;\n    ecModel.eachSeries(function (seriesModel) {\n      if (helper.isCoordSupported(seriesModel.get('coordinateSystem'))) {\n        var dimName = this._dimName;\n        var axisModel = ecModel.queryComponents({\n          mainType: dimName + 'Axis',\n          index: seriesModel.get(dimName + 'AxisIndex'),\n          id: seriesModel.get(dimName + 'AxisId')\n        })[0];\n\n        if (this._axisIndex === (axisModel && axisModel.componentIndex)) {\n          seriesModels.push(seriesModel);\n        }\n      }\n    }, this);\n    return seriesModels;\n  },\n  getAxisModel: function () {\n    return this.ecModel.getComponent(this._dimName + 'Axis', this._axisIndex);\n  },\n  getOtherAxisModel: function () {\n    var axisDim = this._dimName;\n    var ecModel = this.ecModel;\n    var axisModel = this.getAxisModel();\n    var isCartesian = axisDim === 'x' || axisDim === 'y';\n    var otherAxisDim;\n    var coordSysIndexName;\n\n    if (isCartesian) {\n      coordSysIndexName = 'gridIndex';\n      otherAxisDim = axisDim === 'x' ? 'y' : 'x';\n    } else {\n      coordSysIndexName = 'polarIndex';\n      otherAxisDim = axisDim === 'angle' ? 'radius' : 'angle';\n    }\n\n    var foundOtherAxisModel;\n    ecModel.eachComponent(otherAxisDim + 'Axis', function (otherAxisModel) {\n      if ((otherAxisModel.get(coordSysIndexName) || 0) === (axisModel.get(coordSysIndexName) || 0)) {\n        foundOtherAxisModel = otherAxisModel;\n      }\n    });\n    return foundOtherAxisModel;\n  },\n  getMinMaxSpan: function () {\n    return zrUtil.clone(this._minMaxSpan);\n  },\n\n  /**\n   * Only calculate by given range and this._dataExtent, do not change anything.\n   *\n   * @param {Object} opt\n   * @param {number} [opt.start]\n   * @param {number} [opt.end]\n   * @param {number} [opt.startValue]\n   * @param {number} [opt.endValue]\n   */\n  calculateDataWindow: function (opt) {\n    var dataExtent = this._dataExtent;\n    var axisModel = this.getAxisModel();\n    var scale = axisModel.axis.scale;\n\n    var rangePropMode = this._dataZoomModel.getRangePropMode();\n\n    var percentExtent = [0, 100];\n    var percentWindow = [];\n    var valueWindow = [];\n    var hasPropModeValue;\n    each(['start', 'end'], function (prop, idx) {\n      var boundPercent = opt[prop];\n      var boundValue = opt[prop + 'Value']; // Notice: dataZoom is based either on `percentProp` ('start', 'end') or\n      // on `valueProp` ('startValue', 'endValue'). (They are based on the data extent\n      // but not min/max of axis, which will be calculated by data window then).\n      // The former one is suitable for cases that a dataZoom component controls multiple\n      // axes with different unit or extent, and the latter one is suitable for accurate\n      // zoom by pixel (e.g., in dataZoomSelect).\n      // we use `getRangePropMode()` to mark which prop is used. `rangePropMode` is updated\n      // only when setOption or dispatchAction, otherwise it remains its original value.\n      // (Why not only record `percentProp` and always map to `valueProp`? Because\n      // the map `valueProp` -> `percentProp` -> `valueProp` probably not the original\n      // `valueProp`. consider two axes constrolled by one dataZoom. They have different\n      // data extent. All of values that are overflow the `dataExtent` will be calculated\n      // to percent '100%').\n\n      if (rangePropMode[idx] === 'percent') {\n        boundPercent == null && (boundPercent = percentExtent[idx]); // Use scale.parse to math round for category or time axis.\n\n        boundValue = scale.parse(numberUtil.linearMap(boundPercent, percentExtent, dataExtent));\n      } else {\n        hasPropModeValue = true;\n        boundValue = boundValue == null ? dataExtent[idx] : scale.parse(boundValue); // Calculating `percent` from `value` may be not accurate, because\n        // This calculation can not be inversed, because all of values that\n        // are overflow the `dataExtent` will be calculated to percent '100%'\n\n        boundPercent = numberUtil.linearMap(boundValue, dataExtent, percentExtent);\n      } // valueWindow[idx] = round(boundValue);\n      // percentWindow[idx] = round(boundPercent);\n\n\n      valueWindow[idx] = boundValue;\n      percentWindow[idx] = boundPercent;\n    });\n    asc(valueWindow);\n    asc(percentWindow); // The windows from user calling of `dispatchAction` might be out of the extent,\n    // or do not obey the `min/maxSpan`, `min/maxValueSpan`. But we dont restrict window\n    // by `zoomLock` here, because we see `zoomLock` just as a interaction constraint,\n    // where API is able to initialize/modify the window size even though `zoomLock`\n    // specified.\n\n    var spans = this._minMaxSpan;\n    hasPropModeValue ? restrictSet(valueWindow, percentWindow, dataExtent, percentExtent, false) : restrictSet(percentWindow, valueWindow, percentExtent, dataExtent, true);\n\n    function restrictSet(fromWindow, toWindow, fromExtent, toExtent, toValue) {\n      var suffix = toValue ? 'Span' : 'ValueSpan';\n      sliderMove(0, fromWindow, fromExtent, 'all', spans['min' + suffix], spans['max' + suffix]);\n\n      for (var i = 0; i < 2; i++) {\n        toWindow[i] = numberUtil.linearMap(fromWindow[i], fromExtent, toExtent, true);\n        toValue && (toWindow[i] = scale.parse(toWindow[i]));\n      }\n    }\n\n    return {\n      valueWindow: valueWindow,\n      percentWindow: percentWindow\n    };\n  },\n\n  /**\n   * Notice: reset should not be called before series.restoreData() called,\n   * so it is recommanded to be called in \"process stage\" but not \"model init\n   * stage\".\n   *\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   */\n  reset: function (dataZoomModel) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    }\n\n    var targetSeries = this.getTargetSeriesModels(); // Culculate data window and data extent, and record them.\n\n    this._dataExtent = calculateDataExtent(this, this._dimName, targetSeries); // this.hasSeriesStacked = false;\n    // each(targetSeries, function (series) {\n    // var data = series.getData();\n    // var dataDim = data.mapDimension(this._dimName);\n    // var stackedDimension = data.getCalculationInfo('stackedDimension');\n    // if (stackedDimension && stackedDimension === dataDim) {\n    // this.hasSeriesStacked = true;\n    // }\n    // }, this);\n    // `calculateDataWindow` uses min/maxSpan.\n\n    setMinMaxSpan(this);\n    var dataWindow = this.calculateDataWindow(dataZoomModel.settledOption);\n    this._valueWindow = dataWindow.valueWindow;\n    this._percentWindow = dataWindow.percentWindow; // Update axis setting then.\n\n    setAxisModel(this);\n  },\n\n  /**\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   */\n  restore: function (dataZoomModel) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    }\n\n    this._valueWindow = this._percentWindow = null;\n    setAxisModel(this, true);\n  },\n\n  /**\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   */\n  filterData: function (dataZoomModel, api) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    }\n\n    var axisDim = this._dimName;\n    var seriesModels = this.getTargetSeriesModels();\n    var filterMode = dataZoomModel.get('filterMode');\n    var valueWindow = this._valueWindow;\n\n    if (filterMode === 'none') {\n      return;\n    } // FIXME\n    // Toolbox may has dataZoom injected. And if there are stacked bar chart\n    // with NaN data, NaN will be filtered and stack will be wrong.\n    // So we need to force the mode to be set empty.\n    // In fect, it is not a big deal that do not support filterMode-'filter'\n    // when using toolbox#dataZoom, utill tooltip#dataZoom support \"single axis\n    // selection\" some day, which might need \"adapt to data extent on the\n    // otherAxis\", which is disabled by filterMode-'empty'.\n    // But currently, stack has been fixed to based on value but not index,\n    // so this is not an issue any more.\n    // var otherAxisModel = this.getOtherAxisModel();\n    // if (dataZoomModel.get('$fromToolbox')\n    //     && otherAxisModel\n    //     && otherAxisModel.hasSeriesStacked\n    // ) {\n    //     filterMode = 'empty';\n    // }\n    // TODO\n    // filterMode 'weakFilter' and 'empty' is not optimized for huge data yet.\n\n\n    each(seriesModels, function (seriesModel) {\n      var seriesData = seriesModel.getData();\n      var dataDims = seriesData.mapDimension(axisDim, true);\n\n      if (!dataDims.length) {\n        return;\n      }\n\n      if (filterMode === 'weakFilter') {\n        seriesData.filterSelf(function (dataIndex) {\n          var leftOut;\n          var rightOut;\n          var hasValue;\n\n          for (var i = 0; i < dataDims.length; i++) {\n            var value = seriesData.get(dataDims[i], dataIndex);\n            var thisHasValue = !isNaN(value);\n            var thisLeftOut = value < valueWindow[0];\n            var thisRightOut = value > valueWindow[1];\n\n            if (thisHasValue && !thisLeftOut && !thisRightOut) {\n              return true;\n            }\n\n            thisHasValue && (hasValue = true);\n            thisLeftOut && (leftOut = true);\n            thisRightOut && (rightOut = true);\n          } // If both left out and right out, do not filter.\n\n\n          return hasValue && leftOut && rightOut;\n        });\n      } else {\n        each(dataDims, function (dim) {\n          if (filterMode === 'empty') {\n            seriesModel.setData(seriesData = seriesData.map(dim, function (value) {\n              return !isInWindow(value) ? NaN : value;\n            }));\n          } else {\n            var range = {};\n            range[dim] = valueWindow; // console.time('select');\n\n            seriesData.selectRange(range); // console.timeEnd('select');\n          }\n        });\n      }\n\n      each(dataDims, function (dim) {\n        seriesData.setApproximateExtent(valueWindow, dim);\n      });\n    });\n\n    function isInWindow(value) {\n      return value >= valueWindow[0] && value <= valueWindow[1];\n    }\n  }\n};\n\nfunction calculateDataExtent(axisProxy, axisDim, seriesModels) {\n  var dataExtent = [Infinity, -Infinity];\n  each(seriesModels, function (seriesModel) {\n    var seriesData = seriesModel.getData();\n\n    if (seriesData) {\n      each(seriesData.mapDimension(axisDim, true), function (dim) {\n        var seriesExtent = seriesData.getApproximateExtent(dim);\n        seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);\n        seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);\n      });\n    }\n  });\n\n  if (dataExtent[1] < dataExtent[0]) {\n    dataExtent = [NaN, NaN];\n  } // It is important to get \"consistent\" extent when more then one axes is\n  // controlled by a `dataZoom`, otherwise those axes will not be synchronized\n  // when zooming. But it is difficult to know what is \"consistent\", considering\n  // axes have different type or even different meanings (For example, two\n  // time axes are used to compare data of the same date in different years).\n  // So basically dataZoom just obtains extent by series.data (in category axis\n  // extent can be obtained from axis.data).\n  // Nevertheless, user can set min/max/scale on axes to make extent of axes\n  // consistent.\n\n\n  fixExtentByAxis(axisProxy, dataExtent);\n  return dataExtent;\n}\n\nfunction fixExtentByAxis(axisProxy, dataExtent) {\n  var axisModel = axisProxy.getAxisModel();\n  var min = axisModel.getMin(true); // For category axis, if min/max/scale are not set, extent is determined\n  // by axis.data by default.\n\n  var isCategoryAxis = axisModel.get('type') === 'category';\n  var axisDataLen = isCategoryAxis && axisModel.getCategories().length;\n\n  if (min != null && min !== 'dataMin' && typeof min !== 'function') {\n    dataExtent[0] = min;\n  } else if (isCategoryAxis) {\n    dataExtent[0] = axisDataLen > 0 ? 0 : NaN;\n  }\n\n  var max = axisModel.getMax(true);\n\n  if (max != null && max !== 'dataMax' && typeof max !== 'function') {\n    dataExtent[1] = max;\n  } else if (isCategoryAxis) {\n    dataExtent[1] = axisDataLen > 0 ? axisDataLen - 1 : NaN;\n  }\n\n  if (!axisModel.get('scale', true)) {\n    dataExtent[0] > 0 && (dataExtent[0] = 0);\n    dataExtent[1] < 0 && (dataExtent[1] = 0);\n  } // For value axis, if min/max/scale are not set, we just use the extent obtained\n  // by series data, which may be a little different from the extent calculated by\n  // `axisHelper.getScaleExtent`. But the different just affects the experience a\n  // little when zooming. So it will not be fixed until some users require it strongly.\n\n\n  return dataExtent;\n}\n\nfunction setAxisModel(axisProxy, isRestore) {\n  var axisModel = axisProxy.getAxisModel();\n  var percentWindow = axisProxy._percentWindow;\n  var valueWindow = axisProxy._valueWindow;\n\n  if (!percentWindow) {\n    return;\n  } // [0, 500]: arbitrary value, guess axis extent.\n\n\n  var precision = numberUtil.getPixelPrecision(valueWindow, [0, 500]);\n  precision = Math.min(precision, 20); // isRestore or isFull\n\n  var useOrigin = isRestore || percentWindow[0] === 0 && percentWindow[1] === 100;\n  axisModel.setRange(useOrigin ? null : +valueWindow[0].toFixed(precision), useOrigin ? null : +valueWindow[1].toFixed(precision));\n}\n\nfunction setMinMaxSpan(axisProxy) {\n  var minMaxSpan = axisProxy._minMaxSpan = {};\n  var dataZoomModel = axisProxy._dataZoomModel;\n  var dataExtent = axisProxy._dataExtent;\n  each(['min', 'max'], function (minMax) {\n    var percentSpan = dataZoomModel.get(minMax + 'Span');\n    var valueSpan = dataZoomModel.get(minMax + 'ValueSpan');\n    valueSpan != null && (valueSpan = axisProxy.getAxisModel().axis.scale.parse(valueSpan)); // minValueSpan and maxValueSpan has higher priority than minSpan and maxSpan\n\n    if (valueSpan != null) {\n      percentSpan = numberUtil.linearMap(dataExtent[0] + valueSpan, dataExtent, [0, 100], true);\n    } else if (percentSpan != null) {\n      valueSpan = numberUtil.linearMap(percentSpan, [0, 100], dataExtent, true) - dataExtent[0];\n    }\n\n    minMaxSpan[minMax + 'Span'] = percentSpan;\n    minMaxSpan[minMax + 'ValueSpan'] = valueSpan;\n  });\n}\n\nvar _default = AxisProxy;\nmodule.exports = _default;"]}]}