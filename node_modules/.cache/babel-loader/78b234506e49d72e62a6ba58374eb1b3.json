{"remainingRequest":"/Users/id-repair/Documents/SEOL/4c-dashboard/node_modules/babel-loader/lib/index.js!/Users/id-repair/Documents/SEOL/4c-dashboard/node_modules/echarts/lib/data/helper/sourceHelper.js","dependencies":[{"path":"/Users/id-repair/Documents/SEOL/4c-dashboard/node_modules/echarts/lib/data/helper/sourceHelper.js","mtime":499162500000},{"path":"/Users/id-repair/Documents/SEOL/4c-dashboard/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/id-repair/Documents/SEOL/4c-dashboard/node_modules/babel-loader/lib/index.js","mtime":315532800000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:cmVxdWlyZSgiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcC5qcyIpOwoKcmVxdWlyZSgiY29yZS1qcy9tb2R1bGVzL2VzLmZ1bmN0aW9uLm5hbWUuanMiKTsKCnJlcXVpcmUoImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZS5qcyIpOwoKLyoKKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lCiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlCiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24KKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlCiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZQoqICJMaWNlbnNlIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2UKKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0CioKKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMAoqCiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLAoqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuCiogIkFTIElTIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZCiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlCiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucwoqIHVuZGVyIHRoZSBMaWNlbnNlLgoqLwp2YXIgX2NvbmZpZyA9IHJlcXVpcmUoIi4uLy4uL2NvbmZpZyIpOwoKdmFyIF9fREVWX18gPSBfY29uZmlnLl9fREVWX187Cgp2YXIgX21vZGVsID0gcmVxdWlyZSgiLi4vLi4vdXRpbC9tb2RlbCIpOwoKdmFyIG1ha2VJbm5lciA9IF9tb2RlbC5tYWtlSW5uZXI7CnZhciBnZXREYXRhSXRlbVZhbHVlID0gX21vZGVsLmdldERhdGFJdGVtVmFsdWU7Cgp2YXIgX3V0aWwgPSByZXF1aXJlKCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWwiKTsKCnZhciBjcmVhdGVIYXNoTWFwID0gX3V0aWwuY3JlYXRlSGFzaE1hcDsKdmFyIGVhY2ggPSBfdXRpbC5lYWNoOwp2YXIgbWFwID0gX3V0aWwubWFwOwp2YXIgaXNBcnJheSA9IF91dGlsLmlzQXJyYXk7CnZhciBpc1N0cmluZyA9IF91dGlsLmlzU3RyaW5nOwp2YXIgaXNPYmplY3QgPSBfdXRpbC5pc09iamVjdDsKdmFyIGlzVHlwZWRBcnJheSA9IF91dGlsLmlzVHlwZWRBcnJheTsKdmFyIGlzQXJyYXlMaWtlID0gX3V0aWwuaXNBcnJheUxpa2U7CnZhciBleHRlbmQgPSBfdXRpbC5leHRlbmQ7CnZhciBhc3NlcnQgPSBfdXRpbC5hc3NlcnQ7Cgp2YXIgU291cmNlID0gcmVxdWlyZSgiLi4vU291cmNlIik7Cgp2YXIgX3NvdXJjZVR5cGUgPSByZXF1aXJlKCIuL3NvdXJjZVR5cGUiKTsKCnZhciBTT1VSQ0VfRk9STUFUX09SSUdJTkFMID0gX3NvdXJjZVR5cGUuU09VUkNFX0ZPUk1BVF9PUklHSU5BTDsKdmFyIFNPVVJDRV9GT1JNQVRfQVJSQVlfUk9XUyA9IF9zb3VyY2VUeXBlLlNPVVJDRV9GT1JNQVRfQVJSQVlfUk9XUzsKdmFyIFNPVVJDRV9GT1JNQVRfT0JKRUNUX1JPV1MgPSBfc291cmNlVHlwZS5TT1VSQ0VfRk9STUFUX09CSkVDVF9ST1dTOwp2YXIgU09VUkNFX0ZPUk1BVF9LRVlFRF9DT0xVTU5TID0gX3NvdXJjZVR5cGUuU09VUkNFX0ZPUk1BVF9LRVlFRF9DT0xVTU5TOwp2YXIgU09VUkNFX0ZPUk1BVF9VTktOT1dOID0gX3NvdXJjZVR5cGUuU09VUkNFX0ZPUk1BVF9VTktOT1dOOwp2YXIgU09VUkNFX0ZPUk1BVF9UWVBFRF9BUlJBWSA9IF9zb3VyY2VUeXBlLlNPVVJDRV9GT1JNQVRfVFlQRURfQVJSQVk7CnZhciBTRVJJRVNfTEFZT1VUX0JZX1JPVyA9IF9zb3VyY2VUeXBlLlNFUklFU19MQVlPVVRfQllfUk9XOwovKgoqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmUKKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGUKKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbgoqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGUKKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlCiogIkxpY2Vuc2UiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZQoqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQKKgoqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wCioKKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsCiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4KKiAiQVMgSVMiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkKKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUKKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zCiogdW5kZXIgdGhlIExpY2Vuc2UuCiovCi8vIFRoZSByZXN1bHQgb2YgYGd1ZXNzT3JkaW5hbGAuCgp2YXIgQkVfT1JESU5BTCA9IHsKICBNdXN0OiAxLAogIC8vIEVuY291bnRlciBzdHJpbmcgYnV0IG5vdCAnLScgYW5kIG5vdCBudW1iZXItbGlrZS4KICBNaWdodDogMiwKICAvLyBFbmNvdW50ZXIgc3RyaW5nIGJ1dCBudW1iZXItbGlrZS4KICBOb3Q6IDMgLy8gT3RoZXIgY2FzZXMKCn07CnZhciBpbm5lciA9IG1ha2VJbm5lcigpOwovKioKICogQHNlZSB7bW9kdWxlOmVjaGFydHMvZGF0YS9Tb3VyY2V9CiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29tcG9uZW50L2RhdGFzZXQvRGF0YXNldE1vZGVsfSBkYXRhc2V0TW9kZWwKICogQHJldHVybiB7c3RyaW5nfSBzb3VyY2VGb3JtYXQKICovCgpmdW5jdGlvbiBkZXRlY3RTb3VyY2VGb3JtYXQoZGF0YXNldE1vZGVsKSB7CiAgdmFyIGRhdGEgPSBkYXRhc2V0TW9kZWwub3B0aW9uLnNvdXJjZTsKICB2YXIgc291cmNlRm9ybWF0ID0gU09VUkNFX0ZPUk1BVF9VTktOT1dOOwoKICBpZiAoaXNUeXBlZEFycmF5KGRhdGEpKSB7CiAgICBzb3VyY2VGb3JtYXQgPSBTT1VSQ0VfRk9STUFUX1RZUEVEX0FSUkFZOwogIH0gZWxzZSBpZiAoaXNBcnJheShkYXRhKSkgewogICAgLy8gRklYTUUgV2hldGhlciB0b2xlcmF0ZSBudWxsIGluIHRvcCBsZXZlbCBhcnJheT8KICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkgewogICAgICBzb3VyY2VGb3JtYXQgPSBTT1VSQ0VfRk9STUFUX0FSUkFZX1JPV1M7CiAgICB9CgogICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHsKICAgICAgdmFyIGl0ZW0gPSBkYXRhW2ldOwoKICAgICAgaWYgKGl0ZW0gPT0gbnVsbCkgewogICAgICAgIGNvbnRpbnVlOwogICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoaXRlbSkpIHsKICAgICAgICBzb3VyY2VGb3JtYXQgPSBTT1VSQ0VfRk9STUFUX0FSUkFZX1JPV1M7CiAgICAgICAgYnJlYWs7CiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoaXRlbSkpIHsKICAgICAgICBzb3VyY2VGb3JtYXQgPSBTT1VSQ0VfRk9STUFUX09CSkVDVF9ST1dTOwogICAgICAgIGJyZWFrOwogICAgICB9CiAgICB9CiAgfSBlbHNlIGlmIChpc09iamVjdChkYXRhKSkgewogICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHsKICAgICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBpc0FycmF5TGlrZShkYXRhW2tleV0pKSB7CiAgICAgICAgc291cmNlRm9ybWF0ID0gU09VUkNFX0ZPUk1BVF9LRVlFRF9DT0xVTU5TOwogICAgICAgIGJyZWFrOwogICAgICB9CiAgICB9CiAgfSBlbHNlIGlmIChkYXRhICE9IG51bGwpIHsKICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkYXRhJyk7CiAgfQoKICBpbm5lcihkYXRhc2V0TW9kZWwpLnNvdXJjZUZvcm1hdCA9IHNvdXJjZUZvcm1hdDsKfQovKioKICogW1NjZW5hcmlvc106CiAqICgxKSBQcm92aWRlIHNvdXJjZSBkYXRhIGRpcmVjdGx5OgogKiAgICAgc2VyaWVzOiB7CiAqICAgICAgICAgZW5jb2RlOiB7Li4ufSwKICogICAgICAgICBkaW1lbnNpb25zOiBbLi4uXQogKiAgICAgICAgIHNlcmllc0xheW91dEJ5OiAncm93JywKICogICAgICAgICBkYXRhOiBbWy4uLl1dCiAqICAgICB9CiAqICgyKSBSZWZlciB0byBkYXRhc2V0TW9kZWwuCiAqICAgICBzZXJpZXM6IFt7CiAqICAgICAgICAgZW5jb2RlOiB7Li4ufQogKiAgICAgICAgIC8vIElnbm9yZSBkYXRhc2V0SW5kZXggbWVhbnMgYGRhdGFzZXRJbmRleDogMGAKICogICAgICAgICAvLyBhbmQgdGhlIGRpbWVuc2lvbnMgZGVmaW5hdGlvbiBpbiBkYXRhc2V0IGlzIHVzZWQKICogICAgIH0sIHsKICogICAgICAgICBlbmNvZGU6IHsuLi59LAogKiAgICAgICAgIHNlcmllc0xheW91dEJ5OiAnY29sdW1uJywKICogICAgICAgICBkYXRhc2V0SW5kZXg6IDEKICogICAgIH1dCiAqCiAqIEdldCBkYXRhIGZyb20gc2VyaWVzIGl0c2VsZiBvciBkYXRzZXQuCiAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL2RhdGEvU291cmNlfSBzb3VyY2UKICovCgoKZnVuY3Rpb24gZ2V0U291cmNlKHNlcmllc01vZGVsKSB7CiAgcmV0dXJuIGlubmVyKHNlcmllc01vZGVsKS5zb3VyY2U7Cn0KLyoqCiAqIE1VU1QgYmUgY2FsbGVkIGJlZm9yZSBtZXJnZU9wdGlvbiBvZiBhbGwgc2VyaWVzLgogKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbAogKi8KCgpmdW5jdGlvbiByZXNldFNvdXJjZURlZmF1bHRlcihlY01vZGVsKSB7CiAgLy8gYGRhdGFzZXRNYXBgIGlzIHVzZWQgdG8gbWFrZSBkZWZhdWx0IGVuY29kZS4KICBpbm5lcihlY01vZGVsKS5kYXRhc2V0TWFwID0gY3JlYXRlSGFzaE1hcCgpOwp9Ci8qKgogKiBbQ2F1dGlvbl06CiAqIE1VU1QgYmUgY2FsbGVkIGFmdGVyIHNlcmllcyBvcHRpb24gbWVyZ2VkIGFuZAogKiBiZWZvcmUgInNlcmllcy5nZXRJbml0YWlsRGF0YSgpIiBjYWxsZWQuCiAqCiAqIFtUaGUgcnVsZSBvZiBtYWtpbmcgZGVmYXVsdCBlbmNvZGVdOgogKiBDYXRlZ29yeSBheGlzIChpZiBleGlzdHMpIGFsd2F5IG1hcCB0byB0aGUgZmlyc3QgZGltZW5zaW9uLgogKiBFYWNoIG90aGVyIGF4aXMgb2NjdXBpZXMgYSBzdWJzZXF1ZW50IGRpbWVuc2lvbi4KICoKICogW1doeSBtYWtlIGRlZmF1bHQgZW5jb2RlXToKICogU2ltcGxpZnkgdGhlIHR5cGluZyBvZiBlbmNvZGUgaW4gb3B0aW9uLCBhdm9pZGluZyB0aGUgY2FzZSBsaWtlIHRoYXQ6CiAqIHNlcmllczogW3tlbmNvZGU6IHt4OiAwLCB5OiAxfX0sIHtlbmNvZGU6IHt4OiAwLCB5OiAyfX0sIHtlbmNvZGU6IHt4OiAwLCB5OiAzfX1dLAogKiB3aGVyZSB0aGUgInkiIGhhdmUgdG8gYmUgbWFudWFsbHkgdHlwZWQgYXMgIjEsIDIsIDMsIC4uLiIuCiAqCiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzfSBzZXJpZXNNb2RlbAogKi8KCgpmdW5jdGlvbiBwcmVwYXJlU291cmNlKHNlcmllc01vZGVsKSB7CiAgdmFyIHNlcmllc09wdGlvbiA9IHNlcmllc01vZGVsLm9wdGlvbjsKICB2YXIgZGF0YSA9IHNlcmllc09wdGlvbi5kYXRhOwogIHZhciBzb3VyY2VGb3JtYXQgPSBpc1R5cGVkQXJyYXkoZGF0YSkgPyBTT1VSQ0VfRk9STUFUX1RZUEVEX0FSUkFZIDogU09VUkNFX0ZPUk1BVF9PUklHSU5BTDsKICB2YXIgZnJvbURhdGFzZXQgPSBmYWxzZTsKICB2YXIgc2VyaWVzTGF5b3V0QnkgPSBzZXJpZXNPcHRpb24uc2VyaWVzTGF5b3V0Qnk7CiAgdmFyIHNvdXJjZUhlYWRlciA9IHNlcmllc09wdGlvbi5zb3VyY2VIZWFkZXI7CiAgdmFyIGRpbWVuc2lvbnNEZWZpbmUgPSBzZXJpZXNPcHRpb24uZGltZW5zaW9uczsKICB2YXIgZGF0YXNldE1vZGVsID0gZ2V0RGF0YXNldE1vZGVsKHNlcmllc01vZGVsKTsKCiAgaWYgKGRhdGFzZXRNb2RlbCkgewogICAgdmFyIGRhdGFzZXRPcHRpb24gPSBkYXRhc2V0TW9kZWwub3B0aW9uOwogICAgZGF0YSA9IGRhdGFzZXRPcHRpb24uc291cmNlOwogICAgc291cmNlRm9ybWF0ID0gaW5uZXIoZGF0YXNldE1vZGVsKS5zb3VyY2VGb3JtYXQ7CiAgICBmcm9tRGF0YXNldCA9IHRydWU7IC8vIFRoZXNlIHNldHRpbmdzIGZyb20gc2VyaWVzIGhhcyBoaWdoZXIgcHJpb3JpdHkuCgogICAgc2VyaWVzTGF5b3V0QnkgPSBzZXJpZXNMYXlvdXRCeSB8fCBkYXRhc2V0T3B0aW9uLnNlcmllc0xheW91dEJ5OwogICAgc291cmNlSGVhZGVyID09IG51bGwgJiYgKHNvdXJjZUhlYWRlciA9IGRhdGFzZXRPcHRpb24uc291cmNlSGVhZGVyKTsKICAgIGRpbWVuc2lvbnNEZWZpbmUgPSBkaW1lbnNpb25zRGVmaW5lIHx8IGRhdGFzZXRPcHRpb24uZGltZW5zaW9uczsKICB9CgogIHZhciBjb21wbGV0ZVJlc3VsdCA9IGNvbXBsZXRlQnlTb3VyY2VEYXRhKGRhdGEsIHNvdXJjZUZvcm1hdCwgc2VyaWVzTGF5b3V0QnksIHNvdXJjZUhlYWRlciwgZGltZW5zaW9uc0RlZmluZSk7CiAgaW5uZXIoc2VyaWVzTW9kZWwpLnNvdXJjZSA9IG5ldyBTb3VyY2UoewogICAgZGF0YTogZGF0YSwKICAgIGZyb21EYXRhc2V0OiBmcm9tRGF0YXNldCwKICAgIHNlcmllc0xheW91dEJ5OiBzZXJpZXNMYXlvdXRCeSwKICAgIHNvdXJjZUZvcm1hdDogc291cmNlRm9ybWF0LAogICAgZGltZW5zaW9uc0RlZmluZTogY29tcGxldGVSZXN1bHQuZGltZW5zaW9uc0RlZmluZSwKICAgIHN0YXJ0SW5kZXg6IGNvbXBsZXRlUmVzdWx0LnN0YXJ0SW5kZXgsCiAgICBkaW1lbnNpb25zRGV0ZWN0Q291bnQ6IGNvbXBsZXRlUmVzdWx0LmRpbWVuc2lvbnNEZXRlY3RDb3VudCwKICAgIC8vIE5vdGU6IGRhdGFzZXQgb3B0aW9uIGRvZXMgbm90IGhhdmUgYGVuY29kZWAuCiAgICBlbmNvZGVEZWZpbmU6IHNlcmllc09wdGlvbi5lbmNvZGUKICB9KTsKfSAvLyByZXR1cm4ge3N0YXJ0SW5kZXgsIGRpbWVuc2lvbnNEZWZpbmUsIGRpbWVuc2lvbnNDb3VudH0KCgpmdW5jdGlvbiBjb21wbGV0ZUJ5U291cmNlRGF0YShkYXRhLCBzb3VyY2VGb3JtYXQsIHNlcmllc0xheW91dEJ5LCBzb3VyY2VIZWFkZXIsIGRpbWVuc2lvbnNEZWZpbmUpIHsKICBpZiAoIWRhdGEpIHsKICAgIHJldHVybiB7CiAgICAgIGRpbWVuc2lvbnNEZWZpbmU6IG5vcm1hbGl6ZURpbWVuc2lvbnNEZWZpbmUoZGltZW5zaW9uc0RlZmluZSkKICAgIH07CiAgfQoKICB2YXIgZGltZW5zaW9uc0RldGVjdENvdW50OwogIHZhciBzdGFydEluZGV4OwoKICBpZiAoc291cmNlRm9ybWF0ID09PSBTT1VSQ0VfRk9STUFUX0FSUkFZX1JPV1MpIHsKICAgIC8vIFJ1bGU6IE1vc3Qgb2YgdGhlIGZpcnN0IGxpbmUgYXJlIHN0cmluZzogaXQgaXMgaGVhZGVyLgogICAgLy8gQ2F1dGlvbjogY29uc2lkZXIgYSBsaW5lIHdpdGggNSBzdHJpbmcgYW5kIDEgbnVtYmVyLAogICAgLy8gaXQgc3RpbGwgY2FuIG5vdCBiZSBzdXJlIGl0IGlzIGEgaGVhZCwgYmVjYXVzZSB0aGUKICAgIC8vIDUgc3RyaW5nIG1heSBiZSA1IHZhbHVlcyBvZiBjYXRlZ29yeSBjb2x1bW5zLgogICAgaWYgKHNvdXJjZUhlYWRlciA9PT0gJ2F1dG8nIHx8IHNvdXJjZUhlYWRlciA9PSBudWxsKSB7CiAgICAgIGFycmF5Um93c1RyYXZlbEZpcnN0KGZ1bmN0aW9uICh2YWwpIHsKICAgICAgICAvLyAnLScgaXMgcmVnYXJkZWQgYXMgbnVsbC91bmRlZmluZWQuCiAgICAgICAgaWYgKHZhbCAhPSBudWxsICYmIHZhbCAhPT0gJy0nKSB7CiAgICAgICAgICBpZiAoaXNTdHJpbmcodmFsKSkgewogICAgICAgICAgICBzdGFydEluZGV4ID09IG51bGwgJiYgKHN0YXJ0SW5kZXggPSAxKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHN0YXJ0SW5kZXggPSAwOwogICAgICAgICAgfQogICAgICAgIH0gLy8gMTAgaXMgYW4gZXhwZXJpZW5jZSBudW1iZXIsIGF2b2lkIGxvbmcgbG9vcC4KCiAgICAgIH0sIHNlcmllc0xheW91dEJ5LCBkYXRhLCAxMCk7CiAgICB9IGVsc2UgewogICAgICBzdGFydEluZGV4ID0gc291cmNlSGVhZGVyID8gMSA6IDA7CiAgICB9CgogICAgaWYgKCFkaW1lbnNpb25zRGVmaW5lICYmIHN0YXJ0SW5kZXggPT09IDEpIHsKICAgICAgZGltZW5zaW9uc0RlZmluZSA9IFtdOwogICAgICBhcnJheVJvd3NUcmF2ZWxGaXJzdChmdW5jdGlvbiAodmFsLCBpbmRleCkgewogICAgICAgIGRpbWVuc2lvbnNEZWZpbmVbaW5kZXhdID0gdmFsICE9IG51bGwgPyB2YWwgOiAnJzsKICAgICAgfSwgc2VyaWVzTGF5b3V0QnksIGRhdGEpOwogICAgfQoKICAgIGRpbWVuc2lvbnNEZXRlY3RDb3VudCA9IGRpbWVuc2lvbnNEZWZpbmUgPyBkaW1lbnNpb25zRGVmaW5lLmxlbmd0aCA6IHNlcmllc0xheW91dEJ5ID09PSBTRVJJRVNfTEFZT1VUX0JZX1JPVyA/IGRhdGEubGVuZ3RoIDogZGF0YVswXSA/IGRhdGFbMF0ubGVuZ3RoIDogbnVsbDsKICB9IGVsc2UgaWYgKHNvdXJjZUZvcm1hdCA9PT0gU09VUkNFX0ZPUk1BVF9PQkpFQ1RfUk9XUykgewogICAgaWYgKCFkaW1lbnNpb25zRGVmaW5lKSB7CiAgICAgIGRpbWVuc2lvbnNEZWZpbmUgPSBvYmplY3RSb3dzQ29sbGVjdERpbWVuc2lvbnMoZGF0YSk7CiAgICB9CiAgfSBlbHNlIGlmIChzb3VyY2VGb3JtYXQgPT09IFNPVVJDRV9GT1JNQVRfS0VZRURfQ09MVU1OUykgewogICAgaWYgKCFkaW1lbnNpb25zRGVmaW5lKSB7CiAgICAgIGRpbWVuc2lvbnNEZWZpbmUgPSBbXTsKICAgICAgZWFjaChkYXRhLCBmdW5jdGlvbiAoY29sQXJyLCBrZXkpIHsKICAgICAgICBkaW1lbnNpb25zRGVmaW5lLnB1c2goa2V5KTsKICAgICAgfSk7CiAgICB9CiAgfSBlbHNlIGlmIChzb3VyY2VGb3JtYXQgPT09IFNPVVJDRV9GT1JNQVRfT1JJR0lOQUwpIHsKICAgIHZhciB2YWx1ZTAgPSBnZXREYXRhSXRlbVZhbHVlKGRhdGFbMF0pOwogICAgZGltZW5zaW9uc0RldGVjdENvdW50ID0gaXNBcnJheSh2YWx1ZTApICYmIHZhbHVlMC5sZW5ndGggfHwgMTsKICB9IGVsc2UgaWYgKHNvdXJjZUZvcm1hdCA9PT0gU09VUkNFX0ZPUk1BVF9UWVBFRF9BUlJBWSkge30KCiAgcmV0dXJuIHsKICAgIHN0YXJ0SW5kZXg6IHN0YXJ0SW5kZXgsCiAgICBkaW1lbnNpb25zRGVmaW5lOiBub3JtYWxpemVEaW1lbnNpb25zRGVmaW5lKGRpbWVuc2lvbnNEZWZpbmUpLAogICAgZGltZW5zaW9uc0RldGVjdENvdW50OiBkaW1lbnNpb25zRGV0ZWN0Q291bnQKICB9Owp9IC8vIENvbnNpZGVyIGRpbWVuc2lvbnMgZGVmaW5lZCBsaWtlIFsnQScsICdwcmljZScsICdCJywgJ3ByaWNlJywgJ0MnLCAncHJpY2UnXSwKLy8gd2hpY2ggaXMgcmVhc29uYWJsZS4gQnV0IGRpbWVuc2lvbiBuYW1lIGlzIGR1cGxpY2F0ZWQuCi8vIFJldHVybnMgdW5kZWZpbmVkIG9yIGFuIGFycmF5IGNvbnRhaW5zIG9ubHkgb2JqZWN0IHdpdGhvdXQgbnVsbC91bmRlZmllbmQgb3Igc3RyaW5nLgoKCmZ1bmN0aW9uIG5vcm1hbGl6ZURpbWVuc2lvbnNEZWZpbmUoZGltZW5zaW9uc0RlZmluZSkgewogIGlmICghZGltZW5zaW9uc0RlZmluZSkgewogICAgLy8gVGhlIG1lYW5pbmcgb2YgbnVsbC91bmRlZmluZWQgaXMgZGlmZmVyZW50IGZyb20gZW1wdHkgYXJyYXkuCiAgICByZXR1cm47CiAgfQoKICB2YXIgbmFtZU1hcCA9IGNyZWF0ZUhhc2hNYXAoKTsKICByZXR1cm4gbWFwKGRpbWVuc2lvbnNEZWZpbmUsIGZ1bmN0aW9uIChpdGVtLCBpbmRleCkgewogICAgaXRlbSA9IGV4dGVuZCh7fSwgaXNPYmplY3QoaXRlbSkgPyBpdGVtIDogewogICAgICBuYW1lOiBpdGVtCiAgICB9KTsgLy8gVXNlciBjYW4gc2V0IG51bGwgaW4gZGltZW5zaW9ucy4KICAgIC8vIFdlIGRvbnQgYXV0byBzcGVjaWZ5IG5hbWUsIG90aGV3aXNlIGEgZ2l2ZW4gbmFtZSBtYXkKICAgIC8vIGNhdXNlIGl0IGJlIHJlZmVyZWQgdW5leHBlY3RlZGx5LgoKICAgIGlmIChpdGVtLm5hbWUgPT0gbnVsbCkgewogICAgICByZXR1cm4gaXRlbTsKICAgIH0gLy8gQWxzbyBjb25zaWRlciBudW1iZXIgZm9ybSBsaWtlIDIwMTIuCgoKICAgIGl0ZW0ubmFtZSArPSAnJzsgLy8gVXNlciBtYXkgYWxzbyBzcGVjaWZ5IGRpc3BsYXlOYW1lLgogICAgLy8gZGlzcGxheU5hbWUgd2lsbCBhbHdheXMgZXhpc3RzIGV4Y2VwdCB1c2VyIG5vdAogICAgLy8gc3BlY2lmaWVkIG9yIGRpbSBuYW1lIGlzIG5vdCBzcGVjaWZpZWQgb3IgZGV0ZWN0ZWQuCiAgICAvLyAoQSBhdXRvIGdlbmVyYXRlZCBkaW0gbmFtZSB3aWxsIG5vdCBiZSB1c2VkIGFzCiAgICAvLyBkaXNwbGF5TmFtZSkuCgogICAgaWYgKGl0ZW0uZGlzcGxheU5hbWUgPT0gbnVsbCkgewogICAgICBpdGVtLmRpc3BsYXlOYW1lID0gaXRlbS5uYW1lOwogICAgfQoKICAgIHZhciBleGlzdCA9IG5hbWVNYXAuZ2V0KGl0ZW0ubmFtZSk7CgogICAgaWYgKCFleGlzdCkgewogICAgICBuYW1lTWFwLnNldChpdGVtLm5hbWUsIHsKICAgICAgICBjb3VudDogMQogICAgICB9KTsKICAgIH0gZWxzZSB7CiAgICAgIGl0ZW0ubmFtZSArPSAnLScgKyBleGlzdC5jb3VudCsrOwogICAgfQoKICAgIHJldHVybiBpdGVtOwogIH0pOwp9CgpmdW5jdGlvbiBhcnJheVJvd3NUcmF2ZWxGaXJzdChjYiwgc2VyaWVzTGF5b3V0QnksIGRhdGEsIG1heExvb3ApIHsKICBtYXhMb29wID09IG51bGwgJiYgKG1heExvb3AgPSBJbmZpbml0eSk7CgogIGlmIChzZXJpZXNMYXlvdXRCeSA9PT0gU0VSSUVTX0xBWU9VVF9CWV9ST1cpIHsKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGggJiYgaSA8IG1heExvb3A7IGkrKykgewogICAgICBjYihkYXRhW2ldID8gZGF0YVtpXVswXSA6IG51bGwsIGkpOwogICAgfQogIH0gZWxzZSB7CiAgICB2YXIgdmFsdWUwID0gZGF0YVswXSB8fCBbXTsKCiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlMC5sZW5ndGggJiYgaSA8IG1heExvb3A7IGkrKykgewogICAgICBjYih2YWx1ZTBbaV0sIGkpOwogICAgfQogIH0KfQoKZnVuY3Rpb24gb2JqZWN0Um93c0NvbGxlY3REaW1lbnNpb25zKGRhdGEpIHsKICB2YXIgZmlyc3RJbmRleCA9IDA7CiAgdmFyIG9iajsKCiAgd2hpbGUgKGZpcnN0SW5kZXggPCBkYXRhLmxlbmd0aCAmJiAhKG9iaiA9IGRhdGFbZmlyc3RJbmRleCsrXSkpIHt9IC8vIGpzaGludCBpZ25vcmU6IGxpbmUKCgogIGlmIChvYmopIHsKICAgIHZhciBkaW1lbnNpb25zID0gW107CiAgICBlYWNoKG9iaiwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHsKICAgICAgZGltZW5zaW9ucy5wdXNoKGtleSk7CiAgICB9KTsKICAgIHJldHVybiBkaW1lbnNpb25zOwogIH0KfQovKioKICogW1RoZSBzdHJhdGVneSBvZiB0aGUgYXJyZW5nbWVudCBvZiBkYXRhIGRpbWVuc2lvbnMgZm9yIGRhdGFzZXRdOgogKiAidmFsdWUgd2F5IjogYWxsIGF4ZXMgYXJlIG5vbi1jYXRlZ29yeSBheGVzLiBTbyBzZXJpZXMgb25lIGJ5IG9uZSB0YWtlCiAqICAgICBzZXZlcmFsICh0aGUgbnVtYmVyIGlzIGNvb3JkU3lzRGltcy5sZW5ndGgpIGRpbWVuc2lvbnMgZnJvbSBkYXRhc2V0LgogKiAgICAgVGhlIHJlc3VsdCBvZiBkYXRhIGFycmVuZ21lbnQgb2YgZGF0YSBkaW1lbnNpb25zIGxpa2U6CiAqICAgICB8IHNlcjBfeCB8IHNlcjBfeSB8IHNlcjFfeCB8IHNlcjFfeSB8IHNlcjJfeCB8IHNlcjJfeSB8CiAqICJjYXRlZ29yeSB3YXkiOiBhdCBsZWFzdCBvbmUgYXhpcyBpcyBjYXRlZ29yeSBheGlzLiBTbyB0aGUgdGhlIGZpcnN0IGRhdGEKICogICAgIGRpbWVuc2lvbiBpcyBhbHdheXMgbWFwcGVkIHRvIHRoZSBmaXJzdCBjYXRlZ29yeSBheGlzIGFuZCBzaGFyZWQgYnkKICogICAgIGFsbCBvZiB0aGUgc2VyaWVzLiBUaGUgb3RoZXIgZGF0YSBkaW1lbnNpb25zIGFyZSB0YWtlbiBieSBzZXJpZXMgbGlrZQogKiAgICAgInZhbHVlIHdheSIgZG9lcy4KICogICAgIFRoZSByZXN1bHQgb2YgZGF0YSBhcnJlbmdtZW50IG9mIGRhdGEgZGltZW5zaW9ucyBsaWtlOgogKiAgICAgfCBzZXJfc2hhcmVkX3ggfCBzZXIwX3kgfCBzZXIxX3kgfCBzZXIyX3kgfAogKgogKiBAcGFyYW0ge0FycmF5LjxPYmplY3R8c3RyaW5nPn0gY29vcmREaW1lbnNpb25zIFt7bmFtZTogPHN0cmluZz4sIHR5cGU6IDxzdHJpbmc+LCBkaW1zRGVmOiA8QXJyYXk+fSwgLi4uXQogKiBAcGFyYW0ge21vZHVsZTptb2RlbC9TZXJpZXN9IHNlcmllc01vZGVsCiAqIEBwYXJhbSB7bW9kdWxlOmRhdGEvU291cmNlfSBzb3VyY2UKICogQHJldHVybiB7T2JqZWN0fSBlbmNvZGUgTmV2ZXIgYmUgYG51bGwvdW5kZWZpbmVkYC4KICovCgoKZnVuY3Rpb24gbWFrZVNlcmllc0VuY29kZUZvckF4aXNDb29yZFN5cyhjb29yZERpbWVuc2lvbnMsIHNlcmllc01vZGVsLCBzb3VyY2UpIHsKICB2YXIgZW5jb2RlID0ge307CiAgdmFyIGRhdGFzZXRNb2RlbCA9IGdldERhdGFzZXRNb2RlbChzZXJpZXNNb2RlbCk7IC8vIEN1cnJlbnRseSBvbmx5IG1ha2UgZGVmYXVsdCB3aGVuIHVzaW5nIGRhdGFzZXQsIHV0aWwgbW9yZSByZXFpcmVtZW50cyBvY2N1ci4KCiAgaWYgKCFkYXRhc2V0TW9kZWwgfHwgIWNvb3JkRGltZW5zaW9ucykgewogICAgcmV0dXJuIGVuY29kZTsKICB9CgogIHZhciBlbmNvZGVJdGVtTmFtZSA9IFtdOwogIHZhciBlbmNvZGVTZXJpZXNOYW1lID0gW107CiAgdmFyIGVjTW9kZWwgPSBzZXJpZXNNb2RlbC5lY01vZGVsOwogIHZhciBkYXRhc2V0TWFwID0gaW5uZXIoZWNNb2RlbCkuZGF0YXNldE1hcDsKICB2YXIga2V5ID0gZGF0YXNldE1vZGVsLnVpZCArICdfJyArIHNvdXJjZS5zZXJpZXNMYXlvdXRCeTsKICB2YXIgYmFzZUNhdGVnb3J5RGltSW5kZXg7CiAgdmFyIGNhdGVnb3J5V2F5VmFsdWVEaW1TdGFydDsKICBjb29yZERpbWVuc2lvbnMgPSBjb29yZERpbWVuc2lvbnMuc2xpY2UoKTsKICBlYWNoKGNvb3JkRGltZW5zaW9ucywgZnVuY3Rpb24gKGNvb3JkRGltSW5mbywgY29vcmREaW1JZHgpIHsKICAgICFpc09iamVjdChjb29yZERpbUluZm8pICYmIChjb29yZERpbWVuc2lvbnNbY29vcmREaW1JZHhdID0gewogICAgICBuYW1lOiBjb29yZERpbUluZm8KICAgIH0pOwoKICAgIGlmIChjb29yZERpbUluZm8udHlwZSA9PT0gJ29yZGluYWwnICYmIGJhc2VDYXRlZ29yeURpbUluZGV4ID09IG51bGwpIHsKICAgICAgYmFzZUNhdGVnb3J5RGltSW5kZXggPSBjb29yZERpbUlkeDsKICAgICAgY2F0ZWdvcnlXYXlWYWx1ZURpbVN0YXJ0ID0gZ2V0RGF0YURpbUNvdW50T25Db29yZERpbShjb29yZERpbWVuc2lvbnNbY29vcmREaW1JZHhdKTsKICAgIH0KCiAgICBlbmNvZGVbY29vcmREaW1JbmZvLm5hbWVdID0gW107CiAgfSk7CiAgdmFyIGRhdGFzZXRSZWNvcmQgPSBkYXRhc2V0TWFwLmdldChrZXkpIHx8IGRhdGFzZXRNYXAuc2V0KGtleSwgewogICAgY2F0ZWdvcnlXYXlEaW06IGNhdGVnb3J5V2F5VmFsdWVEaW1TdGFydCwKICAgIHZhbHVlV2F5RGltOiAwCiAgfSk7IC8vIFRPRE8KICAvLyBBdXRvIGRldGVjdCBmaXJzdCB0aW1lIGF4aXMgYW5kIGRvIGFycmFuZ2VtZW50LgoKICBlYWNoKGNvb3JkRGltZW5zaW9ucywgZnVuY3Rpb24gKGNvb3JkRGltSW5mbywgY29vcmREaW1JZHgpIHsKICAgIHZhciBjb29yZERpbU5hbWUgPSBjb29yZERpbUluZm8ubmFtZTsKICAgIHZhciBjb3VudCA9IGdldERhdGFEaW1Db3VudE9uQ29vcmREaW0oY29vcmREaW1JbmZvKTsgLy8gSW4gdmFsdWUgd2F5LgoKICAgIGlmIChiYXNlQ2F0ZWdvcnlEaW1JbmRleCA9PSBudWxsKSB7CiAgICAgIHZhciBzdGFydCA9IGRhdGFzZXRSZWNvcmQudmFsdWVXYXlEaW07CiAgICAgIHB1c2hEaW0oZW5jb2RlW2Nvb3JkRGltTmFtZV0sIHN0YXJ0LCBjb3VudCk7CiAgICAgIHB1c2hEaW0oZW5jb2RlU2VyaWVzTmFtZSwgc3RhcnQsIGNvdW50KTsKICAgICAgZGF0YXNldFJlY29yZC52YWx1ZVdheURpbSArPSBjb3VudDsgLy8gPz8/IFRPRE8gZ2l2ZSBhIGJldHRlciBkZWZhdWx0IHNlcmllcyBuYW1lIHJ1bGU/CiAgICAgIC8vIGVzcGVjaWFsbHkgd2hlbiBlbmNvZGUgeCB5IHNwZWNpZmllZC4KICAgICAgLy8gY29uc2lkZXI6IHdoZW4gbXV0aXBsZSBzZXJpZXMgc2hhcmUgb25lIGRpbWVuc2lvbgogICAgICAvLyBjYXRlZ29yeSBheGlzLCBzZXJpZXMgbmFtZSBzaG91bGQgYmV0dGVyIHVzZQogICAgICAvLyB0aGUgb3RoZXIgZGltc2lvbiBuYW1lLiBPbiB0aGUgb3RoZXIgaGFuZCwgdXNlCiAgICAgIC8vIGJvdGggZGltZW5zaW9ucyBuYW1lLgogICAgfSAvLyBJbiBjYXRlZ29yeSB3YXksIHRoZSBmaXJzdCBjYXRlZ29yeSBheGlzLgogICAgZWxzZSBpZiAoYmFzZUNhdGVnb3J5RGltSW5kZXggPT09IGNvb3JkRGltSWR4KSB7CiAgICAgICAgcHVzaERpbShlbmNvZGVbY29vcmREaW1OYW1lXSwgMCwgY291bnQpOwogICAgICAgIHB1c2hEaW0oZW5jb2RlSXRlbU5hbWUsIDAsIGNvdW50KTsKICAgICAgfSAvLyBJbiBjYXRlZ29yeSB3YXksIHRoZSBvdGhlciBheGlzLgogICAgICBlbHNlIHsKICAgICAgICAgIHZhciBzdGFydCA9IGRhdGFzZXRSZWNvcmQuY2F0ZWdvcnlXYXlEaW07CiAgICAgICAgICBwdXNoRGltKGVuY29kZVtjb29yZERpbU5hbWVdLCBzdGFydCwgY291bnQpOwogICAgICAgICAgcHVzaERpbShlbmNvZGVTZXJpZXNOYW1lLCBzdGFydCwgY291bnQpOwogICAgICAgICAgZGF0YXNldFJlY29yZC5jYXRlZ29yeVdheURpbSArPSBjb3VudDsKICAgICAgICB9CiAgfSk7CgogIGZ1bmN0aW9uIHB1c2hEaW0oZGltSWR4QXJyLCBpZHhGcm9tLCBpZHhDb3VudCkgewogICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHhDb3VudDsgaSsrKSB7CiAgICAgIGRpbUlkeEFyci5wdXNoKGlkeEZyb20gKyBpKTsKICAgIH0KICB9CgogIGZ1bmN0aW9uIGdldERhdGFEaW1Db3VudE9uQ29vcmREaW0oY29vcmREaW1JbmZvKSB7CiAgICB2YXIgZGltc0RlZiA9IGNvb3JkRGltSW5mby5kaW1zRGVmOwogICAgcmV0dXJuIGRpbXNEZWYgPyBkaW1zRGVmLmxlbmd0aCA6IDE7CiAgfQoKICBlbmNvZGVJdGVtTmFtZS5sZW5ndGggJiYgKGVuY29kZS5pdGVtTmFtZSA9IGVuY29kZUl0ZW1OYW1lKTsKICBlbmNvZGVTZXJpZXNOYW1lLmxlbmd0aCAmJiAoZW5jb2RlLnNlcmllc05hbWUgPSBlbmNvZGVTZXJpZXNOYW1lKTsKICByZXR1cm4gZW5jb2RlOwp9Ci8qKgogKiBXb3JrIGZvciBkYXRhIGxpa2UgW3tuYW1lOiAuLi4sIHZhbHVlOiAuLi59LCAuLi5dLgogKgogKiBAcGFyYW0ge21vZHVsZTptb2RlbC9TZXJpZXN9IHNlcmllc01vZGVsCiAqIEBwYXJhbSB7bW9kdWxlOmRhdGEvU291cmNlfSBzb3VyY2UKICogQHJldHVybiB7T2JqZWN0fSBlbmNvZGUgTmV2ZXIgYmUgYG51bGwvdW5kZWZpbmVkYC4KICovCgoKZnVuY3Rpb24gbWFrZVNlcmllc0VuY29kZUZvck5hbWVCYXNlZChzZXJpZXNNb2RlbCwgc291cmNlLCBkaW1Db3VudCkgewogIHZhciBlbmNvZGUgPSB7fTsKICB2YXIgZGF0YXNldE1vZGVsID0gZ2V0RGF0YXNldE1vZGVsKHNlcmllc01vZGVsKTsgLy8gQ3VycmVudGx5IG9ubHkgbWFrZSBkZWZhdWx0IHdoZW4gdXNpbmcgZGF0YXNldCwgdXRpbCBtb3JlIHJlcWlyZW1lbnRzIG9jY3VyLgoKICBpZiAoIWRhdGFzZXRNb2RlbCkgewogICAgcmV0dXJuIGVuY29kZTsKICB9CgogIHZhciBzb3VyY2VGb3JtYXQgPSBzb3VyY2Uuc291cmNlRm9ybWF0OwogIHZhciBkaW1lbnNpb25zRGVmaW5lID0gc291cmNlLmRpbWVuc2lvbnNEZWZpbmU7CiAgdmFyIHBvdGVudGlhbE5hbWVEaW1JbmRleDsKCiAgaWYgKHNvdXJjZUZvcm1hdCA9PT0gU09VUkNFX0ZPUk1BVF9PQkpFQ1RfUk9XUyB8fCBzb3VyY2VGb3JtYXQgPT09IFNPVVJDRV9GT1JNQVRfS0VZRURfQ09MVU1OUykgewogICAgZWFjaChkaW1lbnNpb25zRGVmaW5lLCBmdW5jdGlvbiAoZGltLCBpZHgpIHsKICAgICAgaWYgKChpc09iamVjdChkaW0pID8gZGltLm5hbWUgOiBkaW0pID09PSAnbmFtZScpIHsKICAgICAgICBwb3RlbnRpYWxOYW1lRGltSW5kZXggPSBpZHg7CiAgICAgIH0KICAgIH0pOwogIH0gLy8gaWR4UmVzdWx0OiB7diwgbn0uCgoKICB2YXIgaWR4UmVzdWx0ID0gZnVuY3Rpb24gKCkgewogICAgdmFyIGlkeFJlczAgPSB7fTsKICAgIHZhciBpZHhSZXMxID0ge307CiAgICB2YXIgZ3Vlc3NSZWNvcmRzID0gW107IC8vIDUgaXMgYW4gZXhwZXJpZW5jZSB2YWx1ZS4KCiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oNSwgZGltQ291bnQpOyBpIDwgbGVuOyBpKyspIHsKICAgICAgdmFyIGd1ZXNzUmVzdWx0ID0gZG9HdWVzc09yZGluYWwoc291cmNlLmRhdGEsIHNvdXJjZUZvcm1hdCwgc291cmNlLnNlcmllc0xheW91dEJ5LCBkaW1lbnNpb25zRGVmaW5lLCBzb3VyY2Uuc3RhcnRJbmRleCwgaSk7CiAgICAgIGd1ZXNzUmVjb3Jkcy5wdXNoKGd1ZXNzUmVzdWx0KTsKICAgICAgdmFyIGlzUHVyZU51bWJlciA9IGd1ZXNzUmVzdWx0ID09PSBCRV9PUkRJTkFMLk5vdDsgLy8gW1N0cmF0ZWd5IG9mIGlkeFJlczBdOiBmaW5kIHRoZSBmaXJzdCBCRV9PUkRJTkFMLk5vdCBhcyB0aGUgdmFsdWUgZGltLAogICAgICAvLyBhbmQgdGhlbiBmaW5kIGEgbmFtZSBkaW0gd2l0aCB0aGUgcHJpb3JpdHk6CiAgICAgIC8vICJCRV9PUkRJTkFMLk1pZ2h0fEJFX09SRElOQUwuTXVzdCIgPiAib3RoZXIgZGltIiA+ICJ0aGUgdmFsdWUgZGltIGl0c2VsZiIuCgogICAgICBpZiAoaXNQdXJlTnVtYmVyICYmIGlkeFJlczAudiA9PSBudWxsICYmIGkgIT09IHBvdGVudGlhbE5hbWVEaW1JbmRleCkgewogICAgICAgIGlkeFJlczAudiA9IGk7CiAgICAgIH0KCiAgICAgIGlmIChpZHhSZXMwLm4gPT0gbnVsbCB8fCBpZHhSZXMwLm4gPT09IGlkeFJlczAudiB8fCAhaXNQdXJlTnVtYmVyICYmIGd1ZXNzUmVjb3Jkc1tpZHhSZXMwLm5dID09PSBCRV9PUkRJTkFMLk5vdCkgewogICAgICAgIGlkeFJlczAubiA9IGk7CiAgICAgIH0KCiAgICAgIGlmIChmdWxmaWxsZWQoaWR4UmVzMCkgJiYgZ3Vlc3NSZWNvcmRzW2lkeFJlczAubl0gIT09IEJFX09SRElOQUwuTm90KSB7CiAgICAgICAgcmV0dXJuIGlkeFJlczA7CiAgICAgIH0gLy8gW1N0cmF0ZWd5IG9mIGlkeFJlczFdOiBpZiBpZHhSZXMwIG5vdCBzYXRpc2ZpZWQgKHRoYXQgaXMsIG5vIEJFX09SRElOQUwuTm90KSwKICAgICAgLy8gZmluZCB0aGUgZmlyc3QgQkVfT1JESU5BTC5NaWdodCBhcyB0aGUgdmFsdWUgZGltLAogICAgICAvLyBhbmQgdGhlbiBmaW5kIGEgbmFtZSBkaW0gd2l0aCB0aGUgcHJpb3JpdHk6CiAgICAgIC8vICJvdGhlciBkaW0iID4gInRoZSB2YWx1ZSBkaW0gaXRzZWxmIi4KICAgICAgLy8gVGhhdCBpcyBmb3IgYmFja3dhcmQgY29tcGF0OiBudW1iZXItbGlrZSAoZS5nLiwgYCczJ2AsIGAnNTUnYCkgY2FuIGJlCiAgICAgIC8vIHRyZWF0ZWQgYXMgbnVtYmVyLgoKCiAgICAgIGlmICghaXNQdXJlTnVtYmVyKSB7CiAgICAgICAgaWYgKGd1ZXNzUmVzdWx0ID09PSBCRV9PUkRJTkFMLk1pZ2h0ICYmIGlkeFJlczEudiA9PSBudWxsICYmIGkgIT09IHBvdGVudGlhbE5hbWVEaW1JbmRleCkgewogICAgICAgICAgaWR4UmVzMS52ID0gaTsKICAgICAgICB9CgogICAgICAgIGlmIChpZHhSZXMxLm4gPT0gbnVsbCB8fCBpZHhSZXMxLm4gPT09IGlkeFJlczEudikgewogICAgICAgICAgaWR4UmVzMS5uID0gaTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KCiAgICBmdW5jdGlvbiBmdWxmaWxsZWQoaWR4UmVzdWx0KSB7CiAgICAgIHJldHVybiBpZHhSZXN1bHQudiAhPSBudWxsICYmIGlkeFJlc3VsdC5uICE9IG51bGw7CiAgICB9CgogICAgcmV0dXJuIGZ1bGZpbGxlZChpZHhSZXMwKSA/IGlkeFJlczAgOiBmdWxmaWxsZWQoaWR4UmVzMSkgPyBpZHhSZXMxIDogbnVsbDsKICB9KCk7CgogIGlmIChpZHhSZXN1bHQpIHsKICAgIGVuY29kZS52YWx1ZSA9IGlkeFJlc3VsdC52OyAvLyBgcG90ZW50aWFsTmFtZURpbUluZGV4YCBoYXMgaGlnaGVzdCBwcmlvcml0eS4KCiAgICB2YXIgbmFtZURpbUluZGV4ID0gcG90ZW50aWFsTmFtZURpbUluZGV4ICE9IG51bGwgPyBwb3RlbnRpYWxOYW1lRGltSW5kZXggOiBpZHhSZXN1bHQubjsgLy8gQnkgZGVmYXVsdCwgbGFiZWwgdXNlIGl0ZW1OYW1lIGluIGNoYXJ0cy4KICAgIC8vIFNvIHdlIGRvbnQgc2V0IGVuY29kZUxhYmVsIGhlcmUuCgogICAgZW5jb2RlLml0ZW1OYW1lID0gW25hbWVEaW1JbmRleF07CiAgICBlbmNvZGUuc2VyaWVzTmFtZSA9IFtuYW1lRGltSW5kZXhdOwogIH0KCiAgcmV0dXJuIGVuY29kZTsKfQovKioKICogSWYgcmV0dXJuIG51bGwvdW5kZWZpbmVkLCBpbmRpY2F0ZSB0aGF0IHNob3VsZCBub3QgdXNlIGRhdGFzZXRNb2RlbC4KICovCgoKZnVuY3Rpb24gZ2V0RGF0YXNldE1vZGVsKHNlcmllc01vZGVsKSB7CiAgdmFyIG9wdGlvbiA9IHNlcmllc01vZGVsLm9wdGlvbjsgLy8gQ2F1dGlvbjogY29uc2lkZXIgdGhlIHNjZW5hcmlvOgogIC8vIEEgZGF0YXNldCBpcyBkZWNsYXJlZCBhbmQgYSBzZXJpZXMgaXMgbm90IGV4cGVjdGVkIHRvIHVzZSB0aGUgZGF0YXNldCwKICAvLyBhbmQgYXQgdGhlIGJlZ2lubmluZyBgc2V0T3B0aW9uKHtzZXJpZXM6IHsgbm9EYXRhIH0pYCAoanVzdCBwcmVwYXJlIG90aGVyCiAgLy8gb3B0aW9uIGJ1dCBubyBkYXRhKSwgdGhlbiBgc2V0T3B0aW9uKHtzZXJpZXM6IHtkYXRhOiBbLi4uXX0pOyBJbiB0aGlzIGNhc2UsCiAgLy8gdGhlIHVzZXIgc2hvdWxkIHNldCBhbiBlbXB0eSBhcnJheSB0byBhdm9pZCB0aGF0IGRhdGFzZXQgaXMgdXNlZCBieSBkZWZhdWx0LgoKICB2YXIgdGhpc0RhdGEgPSBvcHRpb24uZGF0YTsKCiAgaWYgKCF0aGlzRGF0YSkgewogICAgcmV0dXJuIHNlcmllc01vZGVsLmVjTW9kZWwuZ2V0Q29tcG9uZW50KCdkYXRhc2V0Jywgb3B0aW9uLmRhdGFzZXRJbmRleCB8fCAwKTsKICB9Cn0KLyoqCiAqIFRoZSBydWxlIHNob3VsZCBub3QgYmUgY29tcGxleCwgb3RoZXJ3aXNlIHVzZXIgbWlnaHQgbm90CiAqIGJlIGFibGUgdG8ga25vd24gd2hlcmUgdGhlIGRhdGEgaXMgd3JvbmcuCiAqIFRoZSBjb2RlIGlzIHVnbHksIGJ1dCBob3cgdG8gbWFrZSBpdCBuZWF0PwogKgogKiBAcGFyYW0ge21vZHVsZTplY2hhcnMvZGF0YS9Tb3VyY2V9IHNvdXJjZQogKiBAcGFyYW0ge251bWJlcn0gZGltSW5kZXgKICogQHJldHVybiB7QkVfT1JESU5BTH0gZ3Vlc3MgcmVzdWx0LgogKi8KCgpmdW5jdGlvbiBndWVzc09yZGluYWwoc291cmNlLCBkaW1JbmRleCkgewogIHJldHVybiBkb0d1ZXNzT3JkaW5hbChzb3VyY2UuZGF0YSwgc291cmNlLnNvdXJjZUZvcm1hdCwgc291cmNlLnNlcmllc0xheW91dEJ5LCBzb3VyY2UuZGltZW5zaW9uc0RlZmluZSwgc291cmNlLnN0YXJ0SW5kZXgsIGRpbUluZGV4KTsKfSAvLyBkaW1JbmRleCBtYXkgYmUgb3ZlcmZsb3cgc291cmNlIGRhdGEuCi8vIHJldHVybiB7QkVfT1JESU5BTH0KCgpmdW5jdGlvbiBkb0d1ZXNzT3JkaW5hbChkYXRhLCBzb3VyY2VGb3JtYXQsIHNlcmllc0xheW91dEJ5LCBkaW1lbnNpb25zRGVmaW5lLCBzdGFydEluZGV4LCBkaW1JbmRleCkgewogIHZhciByZXN1bHQ7IC8vIEV4cGVyaWVuY2UgdmFsdWUuCgogIHZhciBtYXhMb29wID0gNTsKCiAgaWYgKGlzVHlwZWRBcnJheShkYXRhKSkgewogICAgcmV0dXJuIEJFX09SRElOQUwuTm90OwogIH0gLy8gV2hlbiBzb3VyY2VUeXBlIGlzICdvYmplY3RSb3dzJyBvciAna2V5ZWRDb2x1bW5zJywgZGltZW5zaW9uc0RlZmluZQogIC8vIGFsd2F5cyBleGlzdHMgaW4gc291cmNlLgoKCiAgdmFyIGRpbU5hbWU7CiAgdmFyIGRpbVR5cGU7CgogIGlmIChkaW1lbnNpb25zRGVmaW5lKSB7CiAgICB2YXIgZGltRGVmSXRlbSA9IGRpbWVuc2lvbnNEZWZpbmVbZGltSW5kZXhdOwoKICAgIGlmIChpc09iamVjdChkaW1EZWZJdGVtKSkgewogICAgICBkaW1OYW1lID0gZGltRGVmSXRlbS5uYW1lOwogICAgICBkaW1UeXBlID0gZGltRGVmSXRlbS50eXBlOwogICAgfSBlbHNlIGlmIChpc1N0cmluZyhkaW1EZWZJdGVtKSkgewogICAgICBkaW1OYW1lID0gZGltRGVmSXRlbTsKICAgIH0KICB9CgogIGlmIChkaW1UeXBlICE9IG51bGwpIHsKICAgIHJldHVybiBkaW1UeXBlID09PSAnb3JkaW5hbCcgPyBCRV9PUkRJTkFMLk11c3QgOiBCRV9PUkRJTkFMLk5vdDsKICB9CgogIGlmIChzb3VyY2VGb3JtYXQgPT09IFNPVVJDRV9GT1JNQVRfQVJSQVlfUk9XUykgewogICAgaWYgKHNlcmllc0xheW91dEJ5ID09PSBTRVJJRVNfTEFZT1VUX0JZX1JPVykgewogICAgICB2YXIgc2FtcGxlID0gZGF0YVtkaW1JbmRleF07CgogICAgICBmb3IgKHZhciBpID0gMDsgaSA8IChzYW1wbGUgfHwgW10pLmxlbmd0aCAmJiBpIDwgbWF4TG9vcDsgaSsrKSB7CiAgICAgICAgaWYgKChyZXN1bHQgPSBkZXRlY3RWYWx1ZShzYW1wbGVbc3RhcnRJbmRleCArIGldKSkgIT0gbnVsbCkgewogICAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgICB9CiAgICAgIH0KICAgIH0gZWxzZSB7CiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGggJiYgaSA8IG1heExvb3A7IGkrKykgewogICAgICAgIHZhciByb3cgPSBkYXRhW3N0YXJ0SW5kZXggKyBpXTsKCiAgICAgICAgaWYgKHJvdyAmJiAocmVzdWx0ID0gZGV0ZWN0VmFsdWUocm93W2RpbUluZGV4XSkpICE9IG51bGwpIHsKICAgICAgICAgIHJldHVybiByZXN1bHQ7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgfSBlbHNlIGlmIChzb3VyY2VGb3JtYXQgPT09IFNPVVJDRV9GT1JNQVRfT0JKRUNUX1JPV1MpIHsKICAgIGlmICghZGltTmFtZSkgewogICAgICByZXR1cm4gQkVfT1JESU5BTC5Ob3Q7CiAgICB9CgogICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aCAmJiBpIDwgbWF4TG9vcDsgaSsrKSB7CiAgICAgIHZhciBpdGVtID0gZGF0YVtpXTsKCiAgICAgIGlmIChpdGVtICYmIChyZXN1bHQgPSBkZXRlY3RWYWx1ZShpdGVtW2RpbU5hbWVdKSkgIT0gbnVsbCkgewogICAgICAgIHJldHVybiByZXN1bHQ7CiAgICAgIH0KICAgIH0KICB9IGVsc2UgaWYgKHNvdXJjZUZvcm1hdCA9PT0gU09VUkNFX0ZPUk1BVF9LRVlFRF9DT0xVTU5TKSB7CiAgICBpZiAoIWRpbU5hbWUpIHsKICAgICAgcmV0dXJuIEJFX09SRElOQUwuTm90OwogICAgfQoKICAgIHZhciBzYW1wbGUgPSBkYXRhW2RpbU5hbWVdOwoKICAgIGlmICghc2FtcGxlIHx8IGlzVHlwZWRBcnJheShzYW1wbGUpKSB7CiAgICAgIHJldHVybiBCRV9PUkRJTkFMLk5vdDsKICAgIH0KCiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNhbXBsZS5sZW5ndGggJiYgaSA8IG1heExvb3A7IGkrKykgewogICAgICBpZiAoKHJlc3VsdCA9IGRldGVjdFZhbHVlKHNhbXBsZVtpXSkpICE9IG51bGwpIHsKICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICB9CiAgICB9CiAgfSBlbHNlIGlmIChzb3VyY2VGb3JtYXQgPT09IFNPVVJDRV9GT1JNQVRfT1JJR0lOQUwpIHsKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGggJiYgaSA8IG1heExvb3A7IGkrKykgewogICAgICB2YXIgaXRlbSA9IGRhdGFbaV07CiAgICAgIHZhciB2YWwgPSBnZXREYXRhSXRlbVZhbHVlKGl0ZW0pOwoKICAgICAgaWYgKCFpc0FycmF5KHZhbCkpIHsKICAgICAgICByZXR1cm4gQkVfT1JESU5BTC5Ob3Q7CiAgICAgIH0KCiAgICAgIGlmICgocmVzdWx0ID0gZGV0ZWN0VmFsdWUodmFsW2RpbUluZGV4XSkpICE9IG51bGwpIHsKICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICB9CiAgICB9CiAgfQoKICBmdW5jdGlvbiBkZXRlY3RWYWx1ZSh2YWwpIHsKICAgIHZhciBiZVN0ciA9IGlzU3RyaW5nKHZhbCk7IC8vIENvbnNpZGVyIHVzYWdlIGNvbnZlbmllbmNlLCAnMScsICcyJyB3aWxsIGJlIHRyZWF0ZWQgYXMgIm51bWJlciIuCiAgICAvLyBgaXNGaW5pdCgnJylgIGdldCBgdHJ1ZWAuCgogICAgaWYgKHZhbCAhPSBudWxsICYmIGlzRmluaXRlKHZhbCkgJiYgdmFsICE9PSAnJykgewogICAgICByZXR1cm4gYmVTdHIgPyBCRV9PUkRJTkFMLk1pZ2h0IDogQkVfT1JESU5BTC5Ob3Q7CiAgICB9IGVsc2UgaWYgKGJlU3RyICYmIHZhbCAhPT0gJy0nKSB7CiAgICAgIHJldHVybiBCRV9PUkRJTkFMLk11c3Q7CiAgICB9CiAgfQoKICByZXR1cm4gQkVfT1JESU5BTC5Ob3Q7Cn0KCmV4cG9ydHMuQkVfT1JESU5BTCA9IEJFX09SRElOQUw7CmV4cG9ydHMuZGV0ZWN0U291cmNlRm9ybWF0ID0gZGV0ZWN0U291cmNlRm9ybWF0OwpleHBvcnRzLmdldFNvdXJjZSA9IGdldFNvdXJjZTsKZXhwb3J0cy5yZXNldFNvdXJjZURlZmF1bHRlciA9IHJlc2V0U291cmNlRGVmYXVsdGVyOwpleHBvcnRzLnByZXBhcmVTb3VyY2UgPSBwcmVwYXJlU291cmNlOwpleHBvcnRzLm1ha2VTZXJpZXNFbmNvZGVGb3JBeGlzQ29vcmRTeXMgPSBtYWtlU2VyaWVzRW5jb2RlRm9yQXhpc0Nvb3JkU3lzOwpleHBvcnRzLm1ha2VTZXJpZXNFbmNvZGVGb3JOYW1lQmFzZWQgPSBtYWtlU2VyaWVzRW5jb2RlRm9yTmFtZUJhc2VkOwpleHBvcnRzLmd1ZXNzT3JkaW5hbCA9IGd1ZXNzT3JkaW5hbDs="},{"version":3,"sources":["/Users/id-repair/Documents/SEOL/4c-dashboard/node_modules/echarts/lib/data/helper/sourceHelper.js"],"names":["_config","require","__DEV__","_model","makeInner","getDataItemValue","_util","createHashMap","each","map","isArray","isString","isObject","isTypedArray","isArrayLike","extend","assert","Source","_sourceType","SOURCE_FORMAT_ORIGINAL","SOURCE_FORMAT_ARRAY_ROWS","SOURCE_FORMAT_OBJECT_ROWS","SOURCE_FORMAT_KEYED_COLUMNS","SOURCE_FORMAT_UNKNOWN","SOURCE_FORMAT_TYPED_ARRAY","SERIES_LAYOUT_BY_ROW","BE_ORDINAL","Must","Might","Not","inner","detectSourceFormat","datasetModel","data","option","source","sourceFormat","length","i","len","item","key","hasOwnProperty","Error","getSource","seriesModel","resetSourceDefaulter","ecModel","datasetMap","prepareSource","seriesOption","fromDataset","seriesLayoutBy","sourceHeader","dimensionsDefine","dimensions","getDatasetModel","datasetOption","completeResult","completeBySourceData","startIndex","dimensionsDetectCount","encodeDefine","encode","normalizeDimensionsDefine","arrayRowsTravelFirst","val","index","objectRowsCollectDimensions","colArr","push","value0","nameMap","name","displayName","exist","get","set","count","cb","maxLoop","Infinity","firstIndex","obj","value","makeSeriesEncodeForAxisCoordSys","coordDimensions","encodeItemName","encodeSeriesName","uid","baseCategoryDimIndex","categoryWayValueDimStart","slice","coordDimInfo","coordDimIdx","type","getDataDimCountOnCoordDim","datasetRecord","categoryWayDim","valueWayDim","coordDimName","start","pushDim","dimIdxArr","idxFrom","idxCount","dimsDef","itemName","seriesName","makeSeriesEncodeForNameBased","dimCount","potentialNameDimIndex","dim","idx","idxResult","idxRes0","idxRes1","guessRecords","Math","min","guessResult","doGuessOrdinal","isPureNumber","v","n","fulfilled","nameDimIndex","thisData","getComponent","datasetIndex","guessOrdinal","dimIndex","result","dimName","dimType","dimDefItem","sample","detectValue","row","beStr","isFinite","exports"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar _model = require(\"../../util/model\");\n\nvar makeInner = _model.makeInner;\nvar getDataItemValue = _model.getDataItemValue;\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar createHashMap = _util.createHashMap;\nvar each = _util.each;\nvar map = _util.map;\nvar isArray = _util.isArray;\nvar isString = _util.isString;\nvar isObject = _util.isObject;\nvar isTypedArray = _util.isTypedArray;\nvar isArrayLike = _util.isArrayLike;\nvar extend = _util.extend;\nvar assert = _util.assert;\n\nvar Source = require(\"../Source\");\n\nvar _sourceType = require(\"./sourceType\");\n\nvar SOURCE_FORMAT_ORIGINAL = _sourceType.SOURCE_FORMAT_ORIGINAL;\nvar SOURCE_FORMAT_ARRAY_ROWS = _sourceType.SOURCE_FORMAT_ARRAY_ROWS;\nvar SOURCE_FORMAT_OBJECT_ROWS = _sourceType.SOURCE_FORMAT_OBJECT_ROWS;\nvar SOURCE_FORMAT_KEYED_COLUMNS = _sourceType.SOURCE_FORMAT_KEYED_COLUMNS;\nvar SOURCE_FORMAT_UNKNOWN = _sourceType.SOURCE_FORMAT_UNKNOWN;\nvar SOURCE_FORMAT_TYPED_ARRAY = _sourceType.SOURCE_FORMAT_TYPED_ARRAY;\nvar SERIES_LAYOUT_BY_ROW = _sourceType.SERIES_LAYOUT_BY_ROW;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// The result of `guessOrdinal`.\nvar BE_ORDINAL = {\n  Must: 1,\n  // Encounter string but not '-' and not number-like.\n  Might: 2,\n  // Encounter string but number-like.\n  Not: 3 // Other cases\n\n};\nvar inner = makeInner();\n/**\n * @see {module:echarts/data/Source}\n * @param {module:echarts/component/dataset/DatasetModel} datasetModel\n * @return {string} sourceFormat\n */\n\nfunction detectSourceFormat(datasetModel) {\n  var data = datasetModel.option.source;\n  var sourceFormat = SOURCE_FORMAT_UNKNOWN;\n\n  if (isTypedArray(data)) {\n    sourceFormat = SOURCE_FORMAT_TYPED_ARRAY;\n  } else if (isArray(data)) {\n    // FIXME Whether tolerate null in top level array?\n    if (data.length === 0) {\n      sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;\n    }\n\n    for (var i = 0, len = data.length; i < len; i++) {\n      var item = data[i];\n\n      if (item == null) {\n        continue;\n      } else if (isArray(item)) {\n        sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;\n        break;\n      } else if (isObject(item)) {\n        sourceFormat = SOURCE_FORMAT_OBJECT_ROWS;\n        break;\n      }\n    }\n  } else if (isObject(data)) {\n    for (var key in data) {\n      if (data.hasOwnProperty(key) && isArrayLike(data[key])) {\n        sourceFormat = SOURCE_FORMAT_KEYED_COLUMNS;\n        break;\n      }\n    }\n  } else if (data != null) {\n    throw new Error('Invalid data');\n  }\n\n  inner(datasetModel).sourceFormat = sourceFormat;\n}\n/**\n * [Scenarios]:\n * (1) Provide source data directly:\n *     series: {\n *         encode: {...},\n *         dimensions: [...]\n *         seriesLayoutBy: 'row',\n *         data: [[...]]\n *     }\n * (2) Refer to datasetModel.\n *     series: [{\n *         encode: {...}\n *         // Ignore datasetIndex means `datasetIndex: 0`\n *         // and the dimensions defination in dataset is used\n *     }, {\n *         encode: {...},\n *         seriesLayoutBy: 'column',\n *         datasetIndex: 1\n *     }]\n *\n * Get data from series itself or datset.\n * @return {module:echarts/data/Source} source\n */\n\n\nfunction getSource(seriesModel) {\n  return inner(seriesModel).source;\n}\n/**\n * MUST be called before mergeOption of all series.\n * @param {module:echarts/model/Global} ecModel\n */\n\n\nfunction resetSourceDefaulter(ecModel) {\n  // `datasetMap` is used to make default encode.\n  inner(ecModel).datasetMap = createHashMap();\n}\n/**\n * [Caution]:\n * MUST be called after series option merged and\n * before \"series.getInitailData()\" called.\n *\n * [The rule of making default encode]:\n * Category axis (if exists) alway map to the first dimension.\n * Each other axis occupies a subsequent dimension.\n *\n * [Why make default encode]:\n * Simplify the typing of encode in option, avoiding the case like that:\n * series: [{encode: {x: 0, y: 1}}, {encode: {x: 0, y: 2}}, {encode: {x: 0, y: 3}}],\n * where the \"y\" have to be manually typed as \"1, 2, 3, ...\".\n *\n * @param {module:echarts/model/Series} seriesModel\n */\n\n\nfunction prepareSource(seriesModel) {\n  var seriesOption = seriesModel.option;\n  var data = seriesOption.data;\n  var sourceFormat = isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL;\n  var fromDataset = false;\n  var seriesLayoutBy = seriesOption.seriesLayoutBy;\n  var sourceHeader = seriesOption.sourceHeader;\n  var dimensionsDefine = seriesOption.dimensions;\n  var datasetModel = getDatasetModel(seriesModel);\n\n  if (datasetModel) {\n    var datasetOption = datasetModel.option;\n    data = datasetOption.source;\n    sourceFormat = inner(datasetModel).sourceFormat;\n    fromDataset = true; // These settings from series has higher priority.\n\n    seriesLayoutBy = seriesLayoutBy || datasetOption.seriesLayoutBy;\n    sourceHeader == null && (sourceHeader = datasetOption.sourceHeader);\n    dimensionsDefine = dimensionsDefine || datasetOption.dimensions;\n  }\n\n  var completeResult = completeBySourceData(data, sourceFormat, seriesLayoutBy, sourceHeader, dimensionsDefine);\n  inner(seriesModel).source = new Source({\n    data: data,\n    fromDataset: fromDataset,\n    seriesLayoutBy: seriesLayoutBy,\n    sourceFormat: sourceFormat,\n    dimensionsDefine: completeResult.dimensionsDefine,\n    startIndex: completeResult.startIndex,\n    dimensionsDetectCount: completeResult.dimensionsDetectCount,\n    // Note: dataset option does not have `encode`.\n    encodeDefine: seriesOption.encode\n  });\n} // return {startIndex, dimensionsDefine, dimensionsCount}\n\n\nfunction completeBySourceData(data, sourceFormat, seriesLayoutBy, sourceHeader, dimensionsDefine) {\n  if (!data) {\n    return {\n      dimensionsDefine: normalizeDimensionsDefine(dimensionsDefine)\n    };\n  }\n\n  var dimensionsDetectCount;\n  var startIndex;\n\n  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {\n    // Rule: Most of the first line are string: it is header.\n    // Caution: consider a line with 5 string and 1 number,\n    // it still can not be sure it is a head, because the\n    // 5 string may be 5 values of category columns.\n    if (sourceHeader === 'auto' || sourceHeader == null) {\n      arrayRowsTravelFirst(function (val) {\n        // '-' is regarded as null/undefined.\n        if (val != null && val !== '-') {\n          if (isString(val)) {\n            startIndex == null && (startIndex = 1);\n          } else {\n            startIndex = 0;\n          }\n        } // 10 is an experience number, avoid long loop.\n\n      }, seriesLayoutBy, data, 10);\n    } else {\n      startIndex = sourceHeader ? 1 : 0;\n    }\n\n    if (!dimensionsDefine && startIndex === 1) {\n      dimensionsDefine = [];\n      arrayRowsTravelFirst(function (val, index) {\n        dimensionsDefine[index] = val != null ? val : '';\n      }, seriesLayoutBy, data);\n    }\n\n    dimensionsDetectCount = dimensionsDefine ? dimensionsDefine.length : seriesLayoutBy === SERIES_LAYOUT_BY_ROW ? data.length : data[0] ? data[0].length : null;\n  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {\n    if (!dimensionsDefine) {\n      dimensionsDefine = objectRowsCollectDimensions(data);\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {\n    if (!dimensionsDefine) {\n      dimensionsDefine = [];\n      each(data, function (colArr, key) {\n        dimensionsDefine.push(key);\n      });\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {\n    var value0 = getDataItemValue(data[0]);\n    dimensionsDetectCount = isArray(value0) && value0.length || 1;\n  } else if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {}\n\n  return {\n    startIndex: startIndex,\n    dimensionsDefine: normalizeDimensionsDefine(dimensionsDefine),\n    dimensionsDetectCount: dimensionsDetectCount\n  };\n} // Consider dimensions defined like ['A', 'price', 'B', 'price', 'C', 'price'],\n// which is reasonable. But dimension name is duplicated.\n// Returns undefined or an array contains only object without null/undefiend or string.\n\n\nfunction normalizeDimensionsDefine(dimensionsDefine) {\n  if (!dimensionsDefine) {\n    // The meaning of null/undefined is different from empty array.\n    return;\n  }\n\n  var nameMap = createHashMap();\n  return map(dimensionsDefine, function (item, index) {\n    item = extend({}, isObject(item) ? item : {\n      name: item\n    }); // User can set null in dimensions.\n    // We dont auto specify name, othewise a given name may\n    // cause it be refered unexpectedly.\n\n    if (item.name == null) {\n      return item;\n    } // Also consider number form like 2012.\n\n\n    item.name += ''; // User may also specify displayName.\n    // displayName will always exists except user not\n    // specified or dim name is not specified or detected.\n    // (A auto generated dim name will not be used as\n    // displayName).\n\n    if (item.displayName == null) {\n      item.displayName = item.name;\n    }\n\n    var exist = nameMap.get(item.name);\n\n    if (!exist) {\n      nameMap.set(item.name, {\n        count: 1\n      });\n    } else {\n      item.name += '-' + exist.count++;\n    }\n\n    return item;\n  });\n}\n\nfunction arrayRowsTravelFirst(cb, seriesLayoutBy, data, maxLoop) {\n  maxLoop == null && (maxLoop = Infinity);\n\n  if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {\n    for (var i = 0; i < data.length && i < maxLoop; i++) {\n      cb(data[i] ? data[i][0] : null, i);\n    }\n  } else {\n    var value0 = data[0] || [];\n\n    for (var i = 0; i < value0.length && i < maxLoop; i++) {\n      cb(value0[i], i);\n    }\n  }\n}\n\nfunction objectRowsCollectDimensions(data) {\n  var firstIndex = 0;\n  var obj;\n\n  while (firstIndex < data.length && !(obj = data[firstIndex++])) {} // jshint ignore: line\n\n\n  if (obj) {\n    var dimensions = [];\n    each(obj, function (value, key) {\n      dimensions.push(key);\n    });\n    return dimensions;\n  }\n}\n/**\n * [The strategy of the arrengment of data dimensions for dataset]:\n * \"value way\": all axes are non-category axes. So series one by one take\n *     several (the number is coordSysDims.length) dimensions from dataset.\n *     The result of data arrengment of data dimensions like:\n *     | ser0_x | ser0_y | ser1_x | ser1_y | ser2_x | ser2_y |\n * \"category way\": at least one axis is category axis. So the the first data\n *     dimension is always mapped to the first category axis and shared by\n *     all of the series. The other data dimensions are taken by series like\n *     \"value way\" does.\n *     The result of data arrengment of data dimensions like:\n *     | ser_shared_x | ser0_y | ser1_y | ser2_y |\n *\n * @param {Array.<Object|string>} coordDimensions [{name: <string>, type: <string>, dimsDef: <Array>}, ...]\n * @param {module:model/Series} seriesModel\n * @param {module:data/Source} source\n * @return {Object} encode Never be `null/undefined`.\n */\n\n\nfunction makeSeriesEncodeForAxisCoordSys(coordDimensions, seriesModel, source) {\n  var encode = {};\n  var datasetModel = getDatasetModel(seriesModel); // Currently only make default when using dataset, util more reqirements occur.\n\n  if (!datasetModel || !coordDimensions) {\n    return encode;\n  }\n\n  var encodeItemName = [];\n  var encodeSeriesName = [];\n  var ecModel = seriesModel.ecModel;\n  var datasetMap = inner(ecModel).datasetMap;\n  var key = datasetModel.uid + '_' + source.seriesLayoutBy;\n  var baseCategoryDimIndex;\n  var categoryWayValueDimStart;\n  coordDimensions = coordDimensions.slice();\n  each(coordDimensions, function (coordDimInfo, coordDimIdx) {\n    !isObject(coordDimInfo) && (coordDimensions[coordDimIdx] = {\n      name: coordDimInfo\n    });\n\n    if (coordDimInfo.type === 'ordinal' && baseCategoryDimIndex == null) {\n      baseCategoryDimIndex = coordDimIdx;\n      categoryWayValueDimStart = getDataDimCountOnCoordDim(coordDimensions[coordDimIdx]);\n    }\n\n    encode[coordDimInfo.name] = [];\n  });\n  var datasetRecord = datasetMap.get(key) || datasetMap.set(key, {\n    categoryWayDim: categoryWayValueDimStart,\n    valueWayDim: 0\n  }); // TODO\n  // Auto detect first time axis and do arrangement.\n\n  each(coordDimensions, function (coordDimInfo, coordDimIdx) {\n    var coordDimName = coordDimInfo.name;\n    var count = getDataDimCountOnCoordDim(coordDimInfo); // In value way.\n\n    if (baseCategoryDimIndex == null) {\n      var start = datasetRecord.valueWayDim;\n      pushDim(encode[coordDimName], start, count);\n      pushDim(encodeSeriesName, start, count);\n      datasetRecord.valueWayDim += count; // ??? TODO give a better default series name rule?\n      // especially when encode x y specified.\n      // consider: when mutiple series share one dimension\n      // category axis, series name should better use\n      // the other dimsion name. On the other hand, use\n      // both dimensions name.\n    } // In category way, the first category axis.\n    else if (baseCategoryDimIndex === coordDimIdx) {\n        pushDim(encode[coordDimName], 0, count);\n        pushDim(encodeItemName, 0, count);\n      } // In category way, the other axis.\n      else {\n          var start = datasetRecord.categoryWayDim;\n          pushDim(encode[coordDimName], start, count);\n          pushDim(encodeSeriesName, start, count);\n          datasetRecord.categoryWayDim += count;\n        }\n  });\n\n  function pushDim(dimIdxArr, idxFrom, idxCount) {\n    for (var i = 0; i < idxCount; i++) {\n      dimIdxArr.push(idxFrom + i);\n    }\n  }\n\n  function getDataDimCountOnCoordDim(coordDimInfo) {\n    var dimsDef = coordDimInfo.dimsDef;\n    return dimsDef ? dimsDef.length : 1;\n  }\n\n  encodeItemName.length && (encode.itemName = encodeItemName);\n  encodeSeriesName.length && (encode.seriesName = encodeSeriesName);\n  return encode;\n}\n/**\n * Work for data like [{name: ..., value: ...}, ...].\n *\n * @param {module:model/Series} seriesModel\n * @param {module:data/Source} source\n * @return {Object} encode Never be `null/undefined`.\n */\n\n\nfunction makeSeriesEncodeForNameBased(seriesModel, source, dimCount) {\n  var encode = {};\n  var datasetModel = getDatasetModel(seriesModel); // Currently only make default when using dataset, util more reqirements occur.\n\n  if (!datasetModel) {\n    return encode;\n  }\n\n  var sourceFormat = source.sourceFormat;\n  var dimensionsDefine = source.dimensionsDefine;\n  var potentialNameDimIndex;\n\n  if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS || sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {\n    each(dimensionsDefine, function (dim, idx) {\n      if ((isObject(dim) ? dim.name : dim) === 'name') {\n        potentialNameDimIndex = idx;\n      }\n    });\n  } // idxResult: {v, n}.\n\n\n  var idxResult = function () {\n    var idxRes0 = {};\n    var idxRes1 = {};\n    var guessRecords = []; // 5 is an experience value.\n\n    for (var i = 0, len = Math.min(5, dimCount); i < len; i++) {\n      var guessResult = doGuessOrdinal(source.data, sourceFormat, source.seriesLayoutBy, dimensionsDefine, source.startIndex, i);\n      guessRecords.push(guessResult);\n      var isPureNumber = guessResult === BE_ORDINAL.Not; // [Strategy of idxRes0]: find the first BE_ORDINAL.Not as the value dim,\n      // and then find a name dim with the priority:\n      // \"BE_ORDINAL.Might|BE_ORDINAL.Must\" > \"other dim\" > \"the value dim itself\".\n\n      if (isPureNumber && idxRes0.v == null && i !== potentialNameDimIndex) {\n        idxRes0.v = i;\n      }\n\n      if (idxRes0.n == null || idxRes0.n === idxRes0.v || !isPureNumber && guessRecords[idxRes0.n] === BE_ORDINAL.Not) {\n        idxRes0.n = i;\n      }\n\n      if (fulfilled(idxRes0) && guessRecords[idxRes0.n] !== BE_ORDINAL.Not) {\n        return idxRes0;\n      } // [Strategy of idxRes1]: if idxRes0 not satisfied (that is, no BE_ORDINAL.Not),\n      // find the first BE_ORDINAL.Might as the value dim,\n      // and then find a name dim with the priority:\n      // \"other dim\" > \"the value dim itself\".\n      // That is for backward compat: number-like (e.g., `'3'`, `'55'`) can be\n      // treated as number.\n\n\n      if (!isPureNumber) {\n        if (guessResult === BE_ORDINAL.Might && idxRes1.v == null && i !== potentialNameDimIndex) {\n          idxRes1.v = i;\n        }\n\n        if (idxRes1.n == null || idxRes1.n === idxRes1.v) {\n          idxRes1.n = i;\n        }\n      }\n    }\n\n    function fulfilled(idxResult) {\n      return idxResult.v != null && idxResult.n != null;\n    }\n\n    return fulfilled(idxRes0) ? idxRes0 : fulfilled(idxRes1) ? idxRes1 : null;\n  }();\n\n  if (idxResult) {\n    encode.value = idxResult.v; // `potentialNameDimIndex` has highest priority.\n\n    var nameDimIndex = potentialNameDimIndex != null ? potentialNameDimIndex : idxResult.n; // By default, label use itemName in charts.\n    // So we dont set encodeLabel here.\n\n    encode.itemName = [nameDimIndex];\n    encode.seriesName = [nameDimIndex];\n  }\n\n  return encode;\n}\n/**\n * If return null/undefined, indicate that should not use datasetModel.\n */\n\n\nfunction getDatasetModel(seriesModel) {\n  var option = seriesModel.option; // Caution: consider the scenario:\n  // A dataset is declared and a series is not expected to use the dataset,\n  // and at the beginning `setOption({series: { noData })` (just prepare other\n  // option but no data), then `setOption({series: {data: [...]}); In this case,\n  // the user should set an empty array to avoid that dataset is used by default.\n\n  var thisData = option.data;\n\n  if (!thisData) {\n    return seriesModel.ecModel.getComponent('dataset', option.datasetIndex || 0);\n  }\n}\n/**\n * The rule should not be complex, otherwise user might not\n * be able to known where the data is wrong.\n * The code is ugly, but how to make it neat?\n *\n * @param {module:echars/data/Source} source\n * @param {number} dimIndex\n * @return {BE_ORDINAL} guess result.\n */\n\n\nfunction guessOrdinal(source, dimIndex) {\n  return doGuessOrdinal(source.data, source.sourceFormat, source.seriesLayoutBy, source.dimensionsDefine, source.startIndex, dimIndex);\n} // dimIndex may be overflow source data.\n// return {BE_ORDINAL}\n\n\nfunction doGuessOrdinal(data, sourceFormat, seriesLayoutBy, dimensionsDefine, startIndex, dimIndex) {\n  var result; // Experience value.\n\n  var maxLoop = 5;\n\n  if (isTypedArray(data)) {\n    return BE_ORDINAL.Not;\n  } // When sourceType is 'objectRows' or 'keyedColumns', dimensionsDefine\n  // always exists in source.\n\n\n  var dimName;\n  var dimType;\n\n  if (dimensionsDefine) {\n    var dimDefItem = dimensionsDefine[dimIndex];\n\n    if (isObject(dimDefItem)) {\n      dimName = dimDefItem.name;\n      dimType = dimDefItem.type;\n    } else if (isString(dimDefItem)) {\n      dimName = dimDefItem;\n    }\n  }\n\n  if (dimType != null) {\n    return dimType === 'ordinal' ? BE_ORDINAL.Must : BE_ORDINAL.Not;\n  }\n\n  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {\n    if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {\n      var sample = data[dimIndex];\n\n      for (var i = 0; i < (sample || []).length && i < maxLoop; i++) {\n        if ((result = detectValue(sample[startIndex + i])) != null) {\n          return result;\n        }\n      }\n    } else {\n      for (var i = 0; i < data.length && i < maxLoop; i++) {\n        var row = data[startIndex + i];\n\n        if (row && (result = detectValue(row[dimIndex])) != null) {\n          return result;\n        }\n      }\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {\n    if (!dimName) {\n      return BE_ORDINAL.Not;\n    }\n\n    for (var i = 0; i < data.length && i < maxLoop; i++) {\n      var item = data[i];\n\n      if (item && (result = detectValue(item[dimName])) != null) {\n        return result;\n      }\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {\n    if (!dimName) {\n      return BE_ORDINAL.Not;\n    }\n\n    var sample = data[dimName];\n\n    if (!sample || isTypedArray(sample)) {\n      return BE_ORDINAL.Not;\n    }\n\n    for (var i = 0; i < sample.length && i < maxLoop; i++) {\n      if ((result = detectValue(sample[i])) != null) {\n        return result;\n      }\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {\n    for (var i = 0; i < data.length && i < maxLoop; i++) {\n      var item = data[i];\n      var val = getDataItemValue(item);\n\n      if (!isArray(val)) {\n        return BE_ORDINAL.Not;\n      }\n\n      if ((result = detectValue(val[dimIndex])) != null) {\n        return result;\n      }\n    }\n  }\n\n  function detectValue(val) {\n    var beStr = isString(val); // Consider usage convenience, '1', '2' will be treated as \"number\".\n    // `isFinit('')` get `true`.\n\n    if (val != null && isFinite(val) && val !== '') {\n      return beStr ? BE_ORDINAL.Might : BE_ORDINAL.Not;\n    } else if (beStr && val !== '-') {\n      return BE_ORDINAL.Must;\n    }\n  }\n\n  return BE_ORDINAL.Not;\n}\n\nexports.BE_ORDINAL = BE_ORDINAL;\nexports.detectSourceFormat = detectSourceFormat;\nexports.getSource = getSource;\nexports.resetSourceDefaulter = resetSourceDefaulter;\nexports.prepareSource = prepareSource;\nexports.makeSeriesEncodeForAxisCoordSys = makeSeriesEncodeForAxisCoordSys;\nexports.makeSeriesEncodeForNameBased = makeSeriesEncodeForNameBased;\nexports.guessOrdinal = guessOrdinal;"]}]}